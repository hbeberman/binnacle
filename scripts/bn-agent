#!/usr/bin/env bash
# shellcheck disable=SC2016  # Backticks in prompts are intentional literals
# Unified Agent Launcher - combines agent.sh and containeragent.sh functionality
set -e

# Ensure ~/.local/bin is first in PATH to use latest 'just install' binary
export PATH="$HOME/.local/bin:$PATH"

# Dependency checking - fail fast with clear remediation hints
check_dependencies() {
    local missing_deps=()
    local error_msg=""

    # Check for bn binary
    if ! command -v bn &>/dev/null; then
        missing_deps+=("bn")
        error_msg+="  ‚ùå bn: Binnacle CLI not found\n"
        error_msg+="     Install: See README.md for installation instructions\n"
        error_msg+="     Or build from source: cargo install --path .\n\n"
    fi

    # Check for jq
    if ! command -v jq &>/dev/null; then
        missing_deps+=("jq")
        error_msg+="  ‚ùå jq: JSON processor not found\n"
        error_msg+="     Install on Ubuntu/Debian: sudo apt-get install jq\n"
        error_msg+="     Install on macOS: brew install jq\n"
        error_msg+="     Install on Fedora: sudo dnf install jq\n\n"
    fi

    # Check for GitHub Copilot CLI (using bn system copilot path)
    if ! bn system copilot path &>/dev/null; then
        missing_deps+=("copilot")
        error_msg+="  ‚ùå GitHub Copilot CLI: Not found or not configured\n"
        error_msg+="     Install: bn system copilot install\n"
        error_msg+="     Or manually: See https://docs.github.com/en/copilot/using-github-copilot/using-github-copilot-in-the-command-line\n\n"
    fi

    # Report all missing dependencies
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo "‚ùå Missing required dependencies:" >&2
        echo "" >&2
        echo -e "$error_msg" >&2
        echo "Please install the missing dependencies and try again." >&2
        exit 1
    fi
}

# Run dependency checks before processing arguments
check_dependencies

# Map CLI agent types to internal config names
# CLI uses stable names: auto, qa
# Internal uses: worker, ask
map_agent_type() {
    case "$1" in
        auto) echo "worker" ;;
        qa)   echo "ask" ;;
        *)    echo "$1" ;;
    esac
}

# Get tool permissions from bn config agents show
# Returns arrays suitable for copilot --allow-tool and --deny-tool flags
# Hard-errors if bn config agents is not available (no fallback)
get_agent_tools() {
    local agent_type="$1"
    local config_name
    config_name=$(map_agent_type "$agent_type")
    
    local agent_json
    if ! agent_json=$(bn config agents show "$config_name" 2>/dev/null); then
        echo "‚ùå Failed to get agent configuration for: $config_name" >&2
        echo "   Ensure bn is built with the agents module" >&2
        exit 1
    fi
    
    # Extract tools_allow and tools_deny arrays
    local tools_allow tools_deny
    tools_allow=$(echo "$agent_json" | jq -r '.tools_allow[]? // empty')
    tools_deny=$(echo "$agent_json" | jq -r '.tools_deny[]? // empty')
    
    # Build TOOLS array with proper quoting
    # Using printf %q ensures shell metacharacters are escaped
    TOOLS=()
    while IFS= read -r tool; do
        if [[ -n "$tool" ]]; then
            # Escape the tool string to prevent shell injection
            local escaped_tool
            escaped_tool=$(printf '%s' "$tool")
            TOOLS+=(--allow-tool "$escaped_tool")
        fi
    done <<< "$tools_allow"
    
    # Build BLOCKED_TOOLS array from deny list with proper quoting
    BLOCKED_TOOLS=()
    while IFS= read -r tool; do
        if [[ -n "$tool" ]]; then
            # Escape the tool string to prevent shell injection
            local escaped_tool
            escaped_tool=$(printf '%s' "$tool")
            BLOCKED_TOOLS+=(--deny-tool "$escaped_tool")
        fi
    done <<< "$tools_deny"
}

usage() {
    cat << 'EOF'
Usage: bn-agent [OPTIONS] <agent-type> [args]

Agent Types:
  auto        Pick from 'bn ready' - runs in CONTAINER by default
  do "desc"   Work on custom task - runs on HOST
  prd         Render ideas into PRDs - runs on HOST
  buddy       Quick entry for bugs/tasks/ideas - runs on HOST
  qa          Interactive Q&A about the repository (read-only) - runs on HOST
  free        General purpose with binnacle - runs on HOST

Options:
  --host              Force host execution (even for 'auto')
  --container         Force container execution (for 'buddy' or 'prd')
  --once              Run once and exit (disable default looping)
  --drain             Batch processing mode: loop until 'bn ready' returns 0,
                      then exit gracefully. Mutually exclusive with --once.
                      See DRAIN MODE below for details.
  --show-tools        Show resolved tool permissions and exit (for debugging)
  --cpus LIMIT        CPU limit for container mode
  --memory LIMIT      Memory limit for container mode
  --merge-target BRANCH  Branch to merge into (container mode, default: main)
  --no-merge          Disable auto-merge on exit (container mode)
  --name NAME         Container name (container mode)

Environment Variables:
  BN_MCP_LIFECYCLE    Control MCP lifecycle prompts (default: true)
                      Set to "false" to disable MCP orient/goodbye guidance
  BN_DRAIN_JSON       When set to "1", output JSON summary to stderr on drain
                      completion or interruption (useful for CI/CD integrations)

Drain Mode:
  The --drain flag enables batch processing mode, useful for CI/CD pipelines,
  overnight processing, or any scenario where you want to process all available
  work and then stop.

  Behavior:
    ‚Ä¢ Pre-flight check: exits immediately if no work available at startup
    ‚Ä¢ Between iterations: checks 'bn ready' after each agent completes
    ‚Ä¢ Exits with code 0 when all work is drained
    ‚Ä¢ Counts both ready tasks AND bugs (not just queued items)

  Exit reasons (shown in summary):
    ‚Ä¢ no_work_remaining  - Normal completion, all work processed
    ‚Ä¢ immediate_no_work  - No work at startup (pre-flight)
    ‚Ä¢ interrupted        - Ctrl+C or signal received

  Flag interactions:
    (none)       Loop forever, sleep 10s when idle
    --once       Run exactly once, then exit
    --drain      Loop until 'bn ready' returns 0
    --once --drain  ERROR: conflicting flags

Examples:
  bn-agent auto                       # Run auto worker in container (loops by default)
  bn-agent --host auto                # Run auto worker on host
  bn-agent --once auto                # Run auto worker once and exit
  bn-agent --drain auto               # Process all tasks and exit when done
  BN_DRAIN_JSON=1 bn-agent --drain auto  # Same, with JSON summary to stderr
  bn-agent do "fix the login bug"    # Run custom task on host
  bn-agent prd                        # Run PRD writer on host
  bn-agent --container buddy          # Run buddy in container
  bn-agent --container prd            # Run PRD writer in container
  bn-agent --cpus 2 --memory 4g auto # Container with resource limits
EOF
    exit 1
}

# Require at least one argument
[[ $# -lt 1 ]] && usage

# Parse global options
FORCE_HOST=false
FORCE_CONTAINER=false
ONCE_MODE=false
DRAIN_MODE=false
SHOW_TOOLS=false
CPUS=""
MEMORY=""
MERGE_TARGET="main"
NO_MERGE=""
NAME=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --host)
            FORCE_HOST=true
            shift
            ;;
        --container)
            FORCE_CONTAINER=true
            shift
            ;;
        --once)
            ONCE_MODE=true
            shift
            ;;
        --drain)
            DRAIN_MODE=true
            shift
            ;;
        --show-tools)
            SHOW_TOOLS=true
            shift
            ;;
        --cpus)
            CPUS="$2"
            shift 2
            ;;
        --memory)
            MEMORY="$2"
            shift 2
            ;;
        --merge-target)
            MERGE_TARGET="$2"
            shift 2
            ;;
        --no-merge)
            NO_MERGE="true"
            shift
            ;;
        --name)
            NAME="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        *)
            # First non-option argument is the agent type
            break
            ;;
    esac
done

[[ $# -lt 1 ]] && usage

AGENT_TYPE="$1"
shift

# Determine execution mode: container or host
# Default: auto ‚Üí container, everything else ‚Üí host
# Can be overridden with --host or --container flag
USE_CONTAINER=false
if [[ "$AGENT_TYPE" == "auto" && "$FORCE_HOST" == "false" ]]; then
    USE_CONTAINER=true
fi
# Allow buddy and prd to run in container mode when --container is specified
if [[ ("$AGENT_TYPE" == "buddy" || "$AGENT_TYPE" == "prd") && "$FORCE_CONTAINER" == "true" ]]; then
    USE_CONTAINER=true
fi
# Validate conflicting flags
if [[ "$FORCE_HOST" == "true" && "$FORCE_CONTAINER" == "true" ]]; then
    echo "Error: Cannot specify both --host and --container flags"
    exit 1
fi
if [[ "$ONCE_MODE" == "true" && "$DRAIN_MODE" == "true" ]]; then
    echo "Error: --once and --drain are mutually exclusive"
    exit 1
fi

# Helper function to check how much work is available
# Returns combined count of ready tasks + bugs
# Used by both drain mode and idle sleep loop
check_work_remaining() {
    local ready_json
    ready_json=$(bn ready 2>/dev/null) || { echo "0"; return; }
    local task_count bug_count
    task_count=$(echo "$ready_json" | jq -r '.count // 0')
    bug_count=$(echo "$ready_json" | jq -r '.bug_count // 0')
    echo $((task_count + bug_count))
}

# Helper function to get prompt from bn config agents emit
# Maps CLI names (auto, qa) to internal names (worker, ask)
get_agent_prompt() {
    local agent_type="$1"
    local config_name
    config_name=$(map_agent_type "$agent_type")
    
    local prompt
    if ! prompt=$(bn config agents emit "$config_name" -H 2>&1); then
        echo "‚ùå Failed to get prompt for agent: $config_name" >&2
        echo "   Error: $prompt" >&2
        exit 1
    fi
    echo "$prompt"
}

# Helper function to get MCP lifecycle prompt
get_mcp_lifecycle() {
    local agent_type="$1"
    # Planner types get the planner-specific lifecycle blurb
    if [[ "$agent_type" == "prd" ]]; then
        bn system emit mcp-lifecycle-planner -H 2>/dev/null || true
    else
        bn system emit mcp-lifecycle -H 2>/dev/null || true
    fi
}

# Check if MCP lifecycle prompts should be added (default: true)
BN_MCP_LIFECYCLE="${BN_MCP_LIFECYCLE:-true}"

# Build prompt based on agent type (CLI names map to internal names)
case "$AGENT_TYPE" in
    auto)
        PROMPT=$(get_agent_prompt auto)
        [[ "$BN_MCP_LIFECYCLE" == "true" ]] && PROMPT+=$'\n\n'$(get_mcp_lifecycle worker)
        get_agent_tools worker
        ;;
    do)
        [[ $# -lt 1 ]] && { echo "Error: 'do' requires a description argument"; usage; }
        [[ $# -gt 1 ]] && { echo "Error: Too many arguments. Did you forget to quote the description?"; echo "  Try: bn-agent do \"$*\""; exit 1; }
        DESC="$1"
        PROMPT=$(get_agent_prompt do)
        # Replace {description} placeholder with actual description
        PROMPT=$(echo "$PROMPT" | awk -v desc="$DESC" '{gsub(/{description}/, desc); print}')
        [[ "$BN_MCP_LIFECYCLE" == "true" ]] && PROMPT+=$'\n\n'$(get_mcp_lifecycle do)
        get_agent_tools do
        ;;
    prd)
        PROMPT=$(get_agent_prompt prd)
        [[ "$BN_MCP_LIFECYCLE" == "true" ]] && PROMPT+=$'\n\n'$(get_mcp_lifecycle prd)
        get_agent_tools prd
        ;;
    buddy)
        PROMPT=$(get_agent_prompt buddy)
        [[ "$BN_MCP_LIFECYCLE" == "true" ]] && PROMPT+=$'\n\n'$(get_mcp_lifecycle buddy)
        get_agent_tools buddy
        ;;
    free)
        PROMPT=$(get_agent_prompt free)
        [[ "$BN_MCP_LIFECYCLE" == "true" ]] && PROMPT+=$'\n\n'$(get_mcp_lifecycle free)
        get_agent_tools free
        ;;
    qa)
        PROMPT=$(get_agent_prompt qa)
        [[ "$BN_MCP_LIFECYCLE" == "true" ]] && PROMPT+=$'\n\n'$(get_mcp_lifecycle ask)
        get_agent_tools ask
        ;;
    *)
        echo "Error: Unknown agent type '$AGENT_TYPE'"
        usage
        ;;
esac

# Handle --show-tools flag: display resolved tools and exit
if [[ "$SHOW_TOOLS" == "true" ]]; then
    echo "Agent Type: $AGENT_TYPE"
    internal_name=$(map_agent_type "$AGENT_TYPE")
    echo ""
    echo "Allowed Tools:"
    for arg in "${TOOLS[@]}"; do
        if [[ "$arg" == "--allow-tool" ]]; then
            continue
        fi
        echo "  $arg"
    done
    echo ""
    echo "Blocked Tools:"
    for arg in "${BLOCKED_TOOLS[@]}"; do
        if [[ "$arg" == "--deny-tool" ]]; then
            continue
        fi
        echo "  $arg"
    done
    echo ""
    echo "Source: $(bn config agents show "$internal_name" 2>/dev/null | jq -r '.source // "unknown"')"
    exit 0
fi

# Run agent in appropriate mode
if [[ "$USE_CONTAINER" == "true" ]]; then
    # Container mode
    echo "Launching agent in CONTAINER mode (agent type: $AGENT_TYPE)"

    # Check for container infrastructure dependencies (fail fast, no fallback)
    echo "Checking container infrastructure..."

    # Check for ctr command
    if ! command -v ctr &>/dev/null; then
        echo "‚ùå Container infrastructure not available" >&2
        echo "" >&2
        echo "   Missing: containerd (ctr command)" >&2
        echo "" >&2
        echo "   Installation:" >&2
        echo "     Ubuntu/Debian: sudo apt-get install containerd" >&2
        echo "     macOS: brew install containerd" >&2
        echo "     Fedora: sudo dnf install containerd" >&2
        echo "" >&2
        echo "   For rootless containerd setup, run: bn container --help" >&2
        exit 1
    fi

    # Verify containerd is actually running
    if ! bn container list --quiet &>/dev/null; then
        echo "‚ùå Containerd is not running or not accessible" >&2
        echo "" >&2
        echo "   Troubleshooting:" >&2
        echo "     ‚Ä¢ Rootless: Check if \$XDG_RUNTIME_DIR/containerd/containerd.sock exists" >&2
        echo "     ‚Ä¢ System:   Run 'sudo systemctl status containerd'" >&2
        echo "     ‚Ä¢ Check logs: journalctl -u containerd -n 20" >&2
        echo "" >&2
        echo "   For setup help, run: bn container --help" >&2
        exit 1
    fi

    echo "‚úì Container infrastructure ready"

    # Get repo hash for image name lookup
    REPO_HASH=$(bn orient --type worker 2>/dev/null | jq -r '.data_root // empty' | xargs basename 2>/dev/null || echo "")
    
    # Check for worker image, fall back to default with warning
    WORKER_IMAGE="localhost/bn-${REPO_HASH}-worker:latest"
    DEFAULT_IMAGE="localhost/bn-${REPO_HASH}-default:latest"
    
    if [[ -z "$REPO_HASH" ]]; then
        echo "‚ùå Could not determine repository hash. Is binnacle initialized?"
        echo "   Run: bn session init"
        exit 1
    fi
    
    if bn container list-definitions 2>/dev/null | jq -e ".definitions[] | select(.name == \"worker\")" &>/dev/null; then
        echo "üì¶ Using image: ${WORKER_IMAGE}"
        echo "   (If image doesn't exist, it will be built automatically)"
    elif bn container list-definitions 2>/dev/null | jq -e ".definitions[] | select(.name == \"default\")" &>/dev/null; then
        echo "‚ö†Ô∏è  worker definition not found, falling back to: ${DEFAULT_IMAGE}"
    else
        echo "‚ùå No container definitions found for this repository."
        echo ""
        echo "   Container images are built per-repository. To set up:"
        echo "   1. bn container build default   # Base image with bn + copilot"
        echo "   2. bn container build worker    # Full worker image"
        echo ""
        echo "   Expected image: ${WORKER_IMAGE}"
        exit 1
    fi

    # Build the bn container run command
    CMD=(bn container run .)

    # Add container options
    [[ -n "$CPUS" ]] && CMD+=(--cpus "$CPUS")
    [[ -n "$MEMORY" ]] && CMD+=(--memory "$MEMORY")
    [[ -n "$NAME" ]] && CMD+=(--name "$NAME")
    CMD+=(--merge-target "$MERGE_TARGET")
    [[ -n "$NO_MERGE" ]] && CMD+=(--no-merge)

    # Add the prompt
    CMD+=(--prompt "$PROMPT")

    # Loop-by-default unless --once specified
    if [[ "$ONCE_MODE" == "true" ]]; then
        echo "Running once (no loop)"
        exec "${CMD[@]}"
    else
        echo "Loop mode enabled - agent will restart on exit"
        # Track consecutive Ctrl+C presses for clean exit
        SIGINT_COUNT=0
        LAST_SIGINT=0

        handle_sigint() {
            local now
            now=$(date +%s)
            # If Ctrl+C pressed twice within 2 seconds, exit
            if [[ $((now - LAST_SIGINT)) -le 2 ]]; then
                SIGINT_COUNT=$((SIGINT_COUNT + 1))
            else
                SIGINT_COUNT=1
            fi
            LAST_SIGINT=$now

            if [[ $SIGINT_COUNT -ge 2 ]]; then
                echo ""
                echo "Ctrl+C pressed twice - exiting"
                exit 0
            fi
            echo ""
            echo "(Press Ctrl+C again within 2 seconds to exit)"
        }

        trap handle_sigint INT

        while true; do
            # Reset SIGINT count at start of each iteration
            SIGINT_COUNT=0
            START_TIME=$(date +%s)
            "${CMD[@]}" || true
            END_TIME=$(date +%s)
            DURATION=$((END_TIME - START_TIME))

            # If command failed in less than 5 seconds, it's likely a setup error (missing image, etc.)
            # Don't loop - exit with error so user can fix the issue
            if [[ $DURATION -lt 5 ]]; then
                echo ""
                echo "‚ùå Agent failed immediately (in ${DURATION}s). This usually means:"
                echo "   ‚Ä¢ Missing container image: run 'bn container build worker'"
                echo "   ‚Ä¢ Container infrastructure issue: run 'bn container --help'"
                echo ""
                echo "Fix the issue and try again. Not restarting to avoid loop."
                exit 1
            fi

            echo ""
            echo "Agent exited. Restarting in 3 seconds... (Ctrl+C twice to stop)"
            sleep 3
        done
    fi
else
    # Host mode
    echo "Launching agent in HOST mode (agent type: $AGENT_TYPE)"

    # Export BN_AGENT_SESSION so child processes (including git hooks) know they're running under an agent
    export BN_AGENT_SESSION=1

    # Create a marker file in .git directory so commit hooks can detect agent activity
    GIT_DIR=$(git rev-parse --git-dir 2>/dev/null) || GIT_DIR=""
    BN_AGENT_MARKER=""
    if [[ -n "$GIT_DIR" ]]; then
        BN_AGENT_MARKER="$GIT_DIR/bn-agent-session"
        echo "$$" > "$BN_AGENT_MARKER"

        # Clean up marker file on exit
        cleanup_marker() {
            [[ -n "$BN_AGENT_MARKER" ]] && rm -f "$BN_AGENT_MARKER"
        }
        trap cleanup_marker EXIT
    fi

    # Resolve copilot binary path using bn system copilot path
    COPILOT_JSON=$(bn system copilot path 2>&1) || {
        echo "‚ùå Failed to resolve copilot binary path" >&2
        echo "   Error: $COPILOT_JSON" >&2
        exit 1
    }

    COPILOT_PATH=$(echo "$COPILOT_JSON" | jq -r '.path')
    COPILOT_EXISTS=$(echo "$COPILOT_JSON" | jq -r '.exists')
    COPILOT_VERSION=$(echo "$COPILOT_JSON" | jq -r '.version')
    COPILOT_SOURCE=$(echo "$COPILOT_JSON" | jq -r '.source')

    if [[ "$COPILOT_EXISTS" != "true" ]]; then
        echo "‚ùå Copilot $COPILOT_VERSION ($COPILOT_SOURCE) not found at: $COPILOT_PATH" >&2
        echo "   Run 'bn system copilot install' to install it" >&2
        exit 1
    fi

    # Common copilot flags for all agent types
    COPILOT_FLAGS=(
        --allow-all-urls  # Allow network requests without prompting
        --no-auto-update  # Prevent automatic updates during execution
    )

    # Always use -i with prompt injection
    # Agent files (.github/agents/) are useful for VS Code @binnacle-do etc,
    # but bn-agent uses -i for consistency across host and container modes
    echo "Using prompt injection (-i) with prompt from bn config agents"

    # Loop-by-default unless --once specified
    if [[ "$ONCE_MODE" == "true" ]]; then
        echo "Running once (no loop)"
        exec "$COPILOT_PATH" "${COPILOT_FLAGS[@]}" "${BLOCKED_TOOLS[@]}" "${TOOLS[@]}" -i "$PROMPT"
    else
        echo "Loop mode enabled - agent will restart on exit"
        # Track consecutive Ctrl+C presses for clean exit
        SIGINT_COUNT=0
        LAST_SIGINT=0

        handle_sigint() {
            local now
            now=$(date +%s)
            # If Ctrl+C pressed twice within 2 seconds, exit
            if [[ $((now - LAST_SIGINT)) -le 2 ]]; then
                SIGINT_COUNT=$((SIGINT_COUNT + 1))
            else
                SIGINT_COUNT=1
            fi
            LAST_SIGINT=$now

            if [[ $SIGINT_COUNT -ge 2 ]]; then
                echo ""
                echo "Ctrl+C pressed twice - exiting"
                exit 0
            fi
            echo ""
            echo "(Press Ctrl+C again within 2 seconds to exit)"
        }

        trap handle_sigint INT

        while true; do
            # Reset SIGINT count at start of each iteration
            SIGINT_COUNT=0
            START_TIME=$(date +%s)
            "$COPILOT_PATH" "${COPILOT_FLAGS[@]}" "${BLOCKED_TOOLS[@]}" "${TOOLS[@]}" -i "$PROMPT" || true
            END_TIME=$(date +%s)
            DURATION=$((END_TIME - START_TIME))

            # If command failed in less than 5 seconds, it's likely a setup error
            # Don't loop - exit with error so user can fix the issue
            if [[ $DURATION -lt 5 ]]; then
                echo ""
                echo "‚ùå Agent failed immediately (in ${DURATION}s). Check the error above."
                echo "Fix the issue and try again. Not restarting to avoid loop."
                exit 1
            fi

            echo ""
            echo "Agent exited. Restarting in 3 seconds... (Ctrl+C twice to stop)"
            sleep 3
        done
    fi
fi