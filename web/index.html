<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binnacle - Agent Navigation Graph</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ§­</text></svg>">
    
    <!-- Import map for bare module specifiers (required for dev mode) -->
    <script type="importmap">
    {
        "imports": {
            "marked": "/node_modules/marked/lib/marked.esm.js",
            "highlight.js": "/node_modules/highlight.js/es/index.js"
        }
    }
    </script>
    
    <!-- Base styles and theme -->
    <link rel="stylesheet" href="/css/main.css">
    <link rel="stylesheet" href="/css/themes/dark.css">
    
    <!-- Component styles -->
    <link rel="stylesheet" href="/css/components/sidebar.css">
    <link rel="stylesheet" href="/css/components/graph.css">
    <link rel="stylesheet" href="/css/components/info-panel.css">
    <link rel="stylesheet" href="/css/components/available-work-pane.css">
    <link rel="stylesheet" href="/css/components/active-task-pane.css">
    <link rel="stylesheet" href="/css/components/recently-completed-pane.css">
    <link rel="stylesheet" href="/css/components/connection-status.css">
    <link rel="stylesheet" href="/css/components/connection-picker.css">
    <link rel="stylesheet" href="/css/components/readonly-indicator.css">
    <link rel="stylesheet" href="/css/components/doc-viewer.css">
    <link rel="stylesheet" href="/css/components/edge-info-panel.css">
    <link rel="stylesheet" href="/css/components/link-builder.css">
    <link rel="stylesheet" href="/css/components/graph-overlay-panel.css">
    <link rel="stylesheet" href="/css/components/graph-controls.css">
    <link rel="stylesheet" href="/css/components/node-list.css">
    <link rel="stylesheet" href="/css/components/node-detail-modal.css">
    <link rel="stylesheet" href="/css/components/node-detail-pane.css">
    <link rel="stylesheet" href="/css/components/agent-cards.css">
    <link rel="stylesheet" href="/css/components/activity-log.css">
    <link rel="stylesheet" href="/css/components/summarize-chat.css">
    
    <style>
        /* Additional layout styles for the full app */
        .header {
            background: var(--bg-secondary);
            color: var(--text-primary);
            padding: 1rem 1.5rem;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-shrink: 0;
        }
        
        .header-left {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .header-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin: 0;
            font-size: 1.5rem;
        }
        
        .version-badge {
            font-size: 0.8rem;
            color: var(--text-secondary);
            background: var(--bg-tertiary);
            padding: 0.25rem 0.625rem;
            border-radius: 4px;
        }
        
        .follow-badge {
            font-size: 0.8rem;
            color: var(--text-primary);
            background: var(--accent-blue);
            padding: 0.25rem 0.625rem;
            border-radius: 4px;
            cursor: pointer;
            transition: opacity 0.2s ease, background 0.2s ease;
            display: none; /* Hidden by default */
        }
        
        .follow-badge.visible {
            display: inline-block;
        }
        
        .follow-badge:hover {
            background: var(--accent-blue-hover, #4a9eff);
        }
        
        .subtitle {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin: 0;
        }
        
        .nav-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .nav-btn {
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
        }
        
        .nav-btn:hover {
            background: var(--accent-blue);
        }
        
        .nav-btn.active {
            background: var(--accent-blue);
            font-weight: 600;
        }
        
        .header-right {
            display: flex;
            gap: 1rem;
            align-items: stretch;
        }
        
        .main-content {
            flex: 1;
            overflow: hidden;
            position: relative;
        }
        
        .view {
            display: none;
            width: 100%;
            height: 100%;
        }
        
        .view.active {
            display: block;
        }
        
        #graph-view {
            position: relative;
        }
        
        #graph-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }
        
        #graph-canvas:active {
            cursor: grabbing;
        }
        
        /* Nodes view (list) */
        #nodes-view {
            padding: 2rem;
            overflow-y: auto;
            flex-direction: column;
            height: 100%;
        }
        
        #nodes-view.active {
            display: flex;
        }
        
        #nodes-view h2 {
            margin: 0 0 1.5rem 0;
            flex-shrink: 0;
        }
        
        #node-list {
            flex: 1;
            overflow: hidden;
        }
        
        .node-list {
            display: grid;
            gap: 1rem;
        }
        
        .node-card {
            background: var(--bg-secondary);
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid var(--accent-blue);
        }
        
        /* Agents view */
        #agents-view {
            padding: 2rem;
            overflow-y: auto;
            flex-direction: column;
            height: 100%;
        }
        
        #agents-view.active {
            display: flex;
        }
        
        #agents-view h2 {
            margin: 0 0 1.5rem 0;
            flex-shrink: 0;
        }
        
        #agents-list {
            flex: 1;
            overflow-y: auto;
        }
        
        /* Log view */
        #log-view {
            padding: 2rem;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container" id="app-container">
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <h1 class="header-title">
                    ðŸ§­ Binnacle 
                    <span class="version-badge" id="version-badge">v0.0.0</span>
                    <span class="follow-badge" id="follow-badge" title="Click to pan to agent">Following</span>
                    <div id="connection-status-container"></div>
                </h1>
                <p class="subtitle">Agent Navigation Graph</p>
                <nav class="nav-buttons">
                    <button class="nav-btn active" data-view="graph">Graph</button>
                    <button class="nav-btn" data-view="nodes">Nodes</button>
                    <button class="nav-btn" data-view="agents">Agents</button>
                    <button class="nav-btn" data-view="log">Activity Log</button>
                </nav>
            </div>
            <div class="header-right">
                <!-- Available work and active task panes will be inserted here -->
                <div id="available-work-container"></div>
                <div id="active-task-container"></div>
                <div id="recently-completed-container"></div>
            </div>
        </header>
        
        <!-- Main content area -->
        <div class="main-content">
            <!-- Graph view -->
            <div class="view active" id="graph-view">
                <canvas id="graph-canvas"></canvas>
            </div>
            
            <!-- Nodes list view -->
            <div class="view" id="nodes-view">
                <div class="nodes-view-header">
                    <div class="search-container">
                        <input type="text" id="nodes-search" class="search-input" placeholder="Search nodes...">
                        <button id="clear-search" class="clear-search-btn" style="display: none;">âœ•</button>
                    </div>
                    <label class="toggle-container">
                        <input type="checkbox" id="nodes-hide-completed" checked>
                        <span>Hide completed</span>
                    </label>
                </div>
                <div class="node-list" id="node-list"></div>
            </div>
            
            <!-- Agents view -->
            <div class="view" id="agents-view">
                <h2>Agents</h2>
                <div id="agents-list"></div>
            </div>
            
            <!-- Activity log view -->
            <div class="view" id="log-view">
                <h2>Activity Log</h2>
                <div id="activity-log"></div>
            </div>
        </div>
    </div>
    
    <!-- Info panel and overlays will be mounted dynamically -->
    
    <script type="module">
        // Import all necessary modules
        import * as State from './js/state.js';
        const state = State; // Lowercase alias for convenience
        import * as graph from './js/graph/index.js';
        import * as eventProcessor from './js/graph/event-processor.js';
        import * as connection from './js/connection/index.js';
        import { initializeAgentCards } from './js/components/agent-cards.js';
        import { createInfoPanel, initializeInfoPanel, showInfoPanel, hideInfoPanel, updateInfoPanelContent, expandInfoPanel, collapseInfoPanel } from './js/components/info-panel.js';
        import { createLinkBuilder, initializeLinkBuilder, updateLinkBuilderContent } from './js/components/link-builder.js';
        import { mountGraphOverlayPanel, initializeGraphOverlayPanel } from './js/components/graph-overlay-panel.js';
        import { mountDocViewer, showDocViewer } from './js/components/doc-viewer.js';
        import { mountNodeDetailModal, showNodeDetailModal } from './js/components/node-detail-modal.js';
        import { mountNodeDetailPane, showNodeDetailPane } from './js/components/node-detail-pane.js';
        import { mountSummarizeChatModal, showSummarizeChatModal } from './js/components/summarize-chat.js';
        import { createAvailableWorkPane } from './js/components/available-work-pane.js';
        import { createActiveTaskPane } from './js/components/active-task-pane.js';
        import { createRecentlyCompletedPane } from './js/components/recently-completed-pane.js';
        import { mountReadonlyIndicator } from './js/components/readonly-indicator.js';
        import { mountGraphControls } from './js/components/graph-controls.js';
        import { initializeNodeList } from './js/components/node-list.js';
        import { mountConnectionStatus } from './js/components/connection-status.js';
        import { mountActivityLog } from './js/components/activity-log.js';
        import { gatherSelectionContext, formatContextAsMarkdown, formatContextAsJSON } from './js/utils/selection-context.js';
        import { findFamilyRoot, collectDescendants, computeDepths } from './js/utils/family-reveal.js';
        import { computeSpawnPositions } from './js/utils/spawn-position.js';
        import { animateProgressiveReveal, clearRevealAnimations } from './js/utils/reveal-animation.js';
        import { collapseFamilyReveal } from './js/utils/family-collapse.js';
        
        // Get container element
        const container = document.getElementById('app-container');
        const canvas = document.getElementById('graph-canvas');
        const graphView = document.getElementById('graph-view');
        
        // Mount graph controls to graph view (includes inline zoom controls)
        mountGraphControls(graphView, {
            onSearch: (query) => {
                console.log('Graph search query:', query);
                // TODO: Implement graph search filtering
            },
            onHideCompletedToggle: (hideCompleted) => {
                console.log('Hide completed:', hideCompleted);
                // TODO: Implement hide completed filtering
            },
            onAutoFollowToggle: (autoFollow) => {
                console.log('Auto-follow:', autoFollow);
                if (!autoFollow) {
                    // When turning off auto-follow, clear the following state
                    State.set('ui.followingNodeId', null);
                    State.set('ui.userPaused', false);
                }
                // When turning on, the renderer's updateAutoFollow() will handle it
            },
            onZoomIn: () => {
                graph.zoomIn();
            },
            onZoomOut: () => {
                graph.zoomOut();
            },
            updateZoomLevel: (zoomLevelElement) => {
                const zoom = graph.getZoom ? graph.getZoom() : 1.0;
                const percentage = Math.round(zoom * 100);
                zoomLevelElement.textContent = `${percentage}%`;
            }
        });
        
        // Mount graph overlay panel for hover info
        const graphOverlayPanel = mountGraphOverlayPanel(graphView);
        if (graphOverlayPanel) {
            initializeGraphOverlayPanel(graphOverlayPanel);
        }
        
        // Initialize agent cards (agents view)
        initializeAgentCards('#agents-list');
        
        // Initialize activity log (log view)
        mountActivityLog('#activity-log');
        
        // Initialize node list
        initializeNodeList('#node-list', {
            onNodeClick: (node) => {
                console.log('Node clicked in list:', node);
                // Switch to graph view and show the node
                switchView('graph');
                updateInfoPanelContent(infoPanel, node, [], [], []);
                showInfoPanel(infoPanel);
                // TODO: Pan to the node in the graph
            },
            onInfoClick: (nodeId) => {
                console.log('Info clicked for node:', nodeId);
                showNodeDetailModal(nodeId);
            },
            onDocRead: (docId) => {
                showDocViewer(docId);
            }
        });
        
        // Initialize nodes search
        const nodesSearchInput = document.getElementById('nodes-search');
        const clearSearchBtn = document.getElementById('clear-search');
        
        if (nodesSearchInput && clearSearchBtn) {
            nodesSearchInput.addEventListener('input', (e) => {
                const query = e.target.value.trim();
                state.set('ui.searchQuery', query);
                clearSearchBtn.style.display = query ? 'block' : 'none';
            });
            
            clearSearchBtn.addEventListener('click', () => {
                nodesSearchInput.value = '';
                state.set('ui.searchQuery', '');
                clearSearchBtn.style.display = 'none';
                nodesSearchInput.focus();
            });
        }
        
        // Initialize nodes hide completed toggle
        const nodesHideCompletedToggle = document.getElementById('nodes-hide-completed');
        if (nodesHideCompletedToggle) {
            // Set initial state from storage
            const hideCompleted = state.get('ui.hideCompleted');
            nodesHideCompletedToggle.checked = hideCompleted !== false; // default to true
            
            nodesHideCompletedToggle.addEventListener('change', (e) => {
                state.set('ui.hideCompleted', e.target.checked);
            });
        }
        
        // Create and mount info panel
        const infoPanel = createInfoPanel();
        container.appendChild(infoPanel);
        initializeInfoPanel(infoPanel, {
            onClose: () => console.log('Info panel closed'),
            onTabChange: (tab) => console.log('Tab changed:', tab),
            onQueueToggle: (nodeId) => {
                console.log('Queue toggle:', nodeId);
                // TODO: Implement queue toggle
            },
            onDocOpen: () => {
                const docOpenSection = document.getElementById('info-panel-doc-open-section');
                const docId = docOpenSection?.dataset?.docId;
                if (docId) {
                    showDocViewer(docId);
                }
            },
            onSummaryClick: (nodeId) => {
                // Open doc viewer when summary section is clicked (for doc nodes)
                showDocViewer(nodeId);
            },
            onViewFullLog: () => {
                // Switch to log view
                switchView('log');
            },
            onRelationshipClick: (nodeId) => {
                console.log('Relationship clicked:', nodeId);
                
                // Find the node in the graph
                const graphNodes = graph.getNodes();
                const node = graphNodes.find(n => n.id === nodeId);
                
                if (!node) {
                    console.warn(`Node ${nodeId} not found in graph`);
                    return;
                }
                
                // Check if panel is currently expanded
                const isExpanded = infoPanel.classList.contains('expanded');
                
                // Pan to the node
                graph.panToNode(node.x, node.y, {
                    canvas: document.querySelector('#graph-canvas'),
                    duration: 500,
                    onComplete: () => {
                        // Update info panel with the new node
                        updateInfoPanelContent(infoPanel, node);
                        
                        // Restore the panel state (expanded or compact)
                        if (isExpanded) {
                            expandInfoPanel(infoPanel);
                        } else {
                            collapseInfoPanel(infoPanel);
                        }
                        
                        // Ensure panel is visible
                        showInfoPanel(infoPanel);
                    }
                });
            }
        });
        
        // Create and mount link builder
        const linkBuilder = createLinkBuilder();
        container.appendChild(linkBuilder);
        initializeLinkBuilder(linkBuilder, {
            onCreate: async (linkData) => {
                console.log('Creating link:', linkData);
                
                try {
                    // Get base URL from connection
                    const baseUrl = state.get('connection.baseUrl') || '';
                    
                    // Handle both single and batch link creation
                    const links = linkData.batch ? linkData.links : [linkData];
                    
                    // Call API to create link(s)
                    const response = await fetch(`${baseUrl}/api/links/batch`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            links: links
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to create link: ${response.statusText}`);
                    }
                    
                    const result = await response.json();
                    
                    if (!result.success) {
                        throw new Error('Link creation failed');
                    }
                    
                    // Refresh graph data
                    await connection.refresh();
                    
                    console.log('Link(s) created successfully:', links.length);
                } catch (error) {
                    console.error('Link creation error:', error);
                    throw error;
                }
            },
            onCancel: () => {
                console.log('Link builder cancelled');
            }
        });
        
        // Handle batch actions from info panel
        infoPanel.addEventListener('batch-action', (e) => {
            const { action, nodeIds } = e.detail;
            console.log('Batch action:', action, nodeIds);
            
            switch (action) {
                case 'create-link':
                    // Get the selected nodes from state
                    const selectedNodes = state.get('graph.selectedNodes') || [];
                    if (selectedNodes.length >= 2) {
                        // Get full node data
                        const nodes = selectedNodes.map(nodeId => {
                            const allEntities = [
                                ...state.get('entities.tasks') || [],
                                ...state.get('entities.bugs') || [],
                                ...state.get('entities.ideas') || [],
                                ...state.get('entities.tests') || [],
                                ...state.get('entities.docs') || [],
                                ...state.get('entities.milestones') || [],
                                ...state.get('entities.queues') || [],
                                ...state.get('entities.agents') || []
                            ];
                            return allEntities.find(e => e.id === nodeId);
                        }).filter(n => n !== undefined);
                        
                        if (nodes.length >= 2) {
                            updateLinkBuilderContent(linkBuilder, nodes);
                        }
                    }
                    break;
                case 'summarize':
                    // Open summarize chat modal with selected nodes
                    const readonly = state.get('connection.readonly') || false;
                    showSummarizeChatModal(nodeIds, readonly);
                    break;
                case 'close':
                    // Batch close with reason prompt
                    batchClose(nodeIds);
                    break;
                case 'queue-add':
                    batchAddToQueue(nodeIds);
                    break;
                case 'queue-remove':
                    batchRemoveFromQueue(nodeIds);
                    break;
                case 'export':
                    // Gather selection context
                    const context = gatherSelectionContext();
                    
                    if (context.selectionCount === 0) {
                        state.addToast({
                            type: 'warning',
                            message: 'No entities selected to export'
                        });
                        break;
                    }
                    
                    // Ask user for format preference (markdown or JSON)
                    const format = confirm('Export as Markdown?\n\nOK = Markdown\nCancel = JSON') ? 'markdown' : 'json';
                    
                    // Format based on choice
                    const exportText = format === 'markdown' 
                        ? formatContextAsMarkdown(context)
                        : formatContextAsJSON(context);
                    
                    // Copy to clipboard
                    navigator.clipboard.writeText(exportText)
                        .then(() => {
                            state.addToast({
                                type: 'success',
                                message: `Exported ${context.selectionCount} entities as ${format.toUpperCase()} to clipboard`
                            });
                        })
                        .catch(err => {
                            console.error('Failed to copy to clipboard:', err);
                            state.addToast({
                                type: 'error',
                                message: 'Failed to copy to clipboard'
                            });
                        });
                    break;
                default:
                    console.warn('Unknown batch action:', action);
            }
        });
        
        // Mount doc viewer overlay
        mountDocViewer(container);
        
        // Mount node detail modal
        mountNodeDetailModal(container);
        
        // Mount summarize chat modal
        mountSummarizeChatModal(container);
        
        // Mount node detail pane (side panel for double-click)
        const mainContent = document.querySelector('.main-content');
        mountNodeDetailPane(mainContent);
        
        // Create and mount available work pane
        const availableWorkPane = createAvailableWorkPane();
        document.getElementById('available-work-container').appendChild(availableWorkPane);
        
        // Create and mount active task pane
        const activeTaskPane = createActiveTaskPane();
        document.getElementById('active-task-container').appendChild(activeTaskPane);
        
        // Create and mount recently completed pane
        const recentlyCompletedPane = createRecentlyCompletedPane();
        document.getElementById('recently-completed-container').appendChild(recentlyCompletedPane);
        
        // Initialize graph
        graph.init(canvas, {
            onNodeClick: async (node) => {
                console.log('Node clicked:', node);
                
                // Check if we're switching to a different family
                const currentFamilyReveal = State.get('ui.familyReveal') || { active: false, rootId: null };
                const currentRootId = currentFamilyReveal.rootId;
                
                // Family reveal: find root and collect descendants
                const rootId = findFamilyRoot(node.id);
                if (rootId) {
                    // If clicking a different family, collapse the old one first
                    if (currentFamilyReveal.active && rootId !== currentRootId) {
                        console.log(`[FamilyReveal] Switching from family ${currentRootId} to ${rootId}`);
                        collapseFamilyReveal();
                    }
                    
                    const descendants = collectDescendants(rootId);
                    console.log(`Family reveal: root=${rootId}, descendants=${descendants.size}`);
                    
                    // Compute depth map for wave-based positioning
                    const depthMap = computeDepths(rootId, descendants);
                    
                    // Get existing nodes and edges for position calculation
                    const existingNodesArray = graph.getNodes();
                    const existingNodes = new Map(existingNodesArray.map(n => [n.id, n]));
                    const edges = State.get('edges') || [];
                    
                    // Compute spawn positions for newly revealed nodes
                    const spawnPositions = computeSpawnPositions(depthMap, existingNodes, edges);
                    
                    // Apply positions to newly revealed nodes (nodes not in existing)
                    for (const [nodeId, position] of spawnPositions.entries()) {
                        if (!existingNodes.has(nodeId)) {
                            // This is a newly revealed node - it will get positioned when the graph rebuilds
                            // The position will be picked up by getInitialPositionForNewNode
                            // For now, we'll let the normal graph rebuild handle it
                            console.log(`Spawn position for ${nodeId}: (${position.x.toFixed(1)}, ${position.y.toFixed(1)})`);
                        }
                    }
                    
                    // Update family reveal state
                    State.set('ui.familyReveal', {
                        active: true,
                        rootId: rootId,
                        revealedNodeIds: descendants,
                        spawnPositions: spawnPositions  // Store positions for use during graph rebuild
                    });
                    
                    // Start progressive reveal animation
                    // This runs asynchronously and animates nodes fading in by depth
                    animateProgressiveReveal(rootId, descendants, depthMap, existingNodes);
                } else {
                    console.log('Family reveal: no root found, clearing state');
                    // No root found - collapse any active reveal
                    if (currentFamilyReveal.active) {
                        collapseFamilyReveal();
                    }
                    // Clear reveal state
                    State.set('ui.familyReveal', {
                        active: false,
                        rootId: null,
                        revealedNodeIds: new Set(),
                        spawnPositions: new Map()
                    });
                }
                
                // Show info panel for the clicked node in compact mode
                updateInfoPanelContent(infoPanel, node, [], [], []);
                showInfoPanel(infoPanel);
            },
            onCanvasClick: () => {
                console.log('Canvas clicked (empty space)');
                // Collapse family reveal if active
                collapseFamilyReveal();
                // Hide info panel when clicking on empty space
                hideInfoPanel(infoPanel);
            },
            onNodeHover: (node) => {
                if (node) {
                    graph.setHoveredNode(node.id);
                } else {
                    graph.setHoveredNode(null);
                }
            },
            onEdgeClick: (edge) => {
                console.log('Edge clicked:', edge);
                // TODO: Show edge info panel
            },
            onNodeDoubleClick: (node) => {
                console.log('Node double-clicked:', node);
                // Show doc viewer modal for doc nodes, info panel expanded for others
                if (node.type === 'doc') {
                    showDocViewer(node.id);
                } else {
                    updateInfoPanelContent(infoPanel, node, [], [], []);
                    expandInfoPanel(infoPanel);
                }
            },
            onEscape: () => {
                // Collapse family reveal if active
                collapseFamilyReveal();
                // Hide info panel when Escape is pressed
                hideInfoPanel(infoPanel);
            }
        });
        
        // Initialize event processor (for Follow Events linger behavior)
        eventProcessor.init();
        
        // View switching
        const navButtons = document.querySelectorAll('.nav-btn');
        const views = document.querySelectorAll('.view');
        
        function switchView(viewName) {
            // Update button states
            navButtons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === viewName);
            });
            
            // Update view visibility
            views.forEach(view => {
                view.classList.toggle('active', view.id === `${viewName}-view`);
            });
        }
        
        navButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                switchView(btn.dataset.view);
                state.set('ui.currentView', btn.dataset.view);
            });
        });
        
        // Watch for currentView changes from other parts of the app
        state.subscribe('ui.currentView', (newView) => {
            switchView(newView);
        });
        
        // Batch close handler
        async function batchClose(nodeIds) {
            if (!nodeIds || nodeIds.length === 0) {
                state.addToast({
                    type: 'warning',
                    message: 'No items selected to close'
                });
                return;
            }
            
            // Prompt for close reason
            const reason = prompt(`Close ${nodeIds.length} item(s)?\n\nEnter reason for closing:`);
            
            if (!reason) {
                // User cancelled
                return;
            }
            
            try {
                const response = await fetch('/api/batch/close', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        node_ids: nodeIds,
                        reason: reason
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Batch close failed');
                }
                
                const result = await response.json();
                
                // Show success message
                const { summary } = result;
                let message = `Closed ${summary.closed_count} item(s)`;
                if (summary.skipped_count > 0) {
                    message += `, skipped ${summary.skipped_count}`;
                }
                if (summary.failed_count > 0) {
                    message += `, failed ${summary.failed_count}`;
                }
                
                state.addToast({
                    type: summary.failed_count > 0 ? 'warning' : 'success',
                    message: message
                });
                
                // Clear selection
                state.set('graph.selectedNodes', []);
                
                // Refresh data to show updated state
                connection.refreshData();
                
            } catch (error) {
                console.error('Batch close error:', error);
                state.addToast({
                    type: 'error',
                    message: `Failed to close items: ${error.message}`
                });
            }
        }
        
        async function batchAddToQueue(nodeIds) {
            if (!nodeIds || nodeIds.length === 0) {
                state.addToast({
                    type: 'warning',
                    message: 'No items selected to add to queue'
                });
                return;
            }
            
            try {
                const response = await fetch('/api/batch/queue-add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        node_ids: nodeIds
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Batch queue add failed');
                }
                
                const result = await response.json();
                
                // Show success message
                const { summary } = result;
                let message = `Added ${summary.added_count} item(s) to queue`;
                if (summary.skipped_count > 0) {
                    message += `, skipped ${summary.skipped_count}`;
                }
                if (summary.failed_count > 0) {
                    message += `, failed ${summary.failed_count}`;
                }
                
                state.addToast({
                    type: summary.failed_count > 0 ? 'warning' : 'success',
                    message: message
                });
                
                // Refresh data to show updated state
                connection.refreshData();
                
            } catch (error) {
                console.error('Batch queue add error:', error);
                state.addToast({
                    type: 'error',
                    message: `Failed to add items to queue: ${error.message}`
                });
            }
        }
        
        async function batchRemoveFromQueue(nodeIds) {
            if (!nodeIds || nodeIds.length === 0) {
                state.addToast({
                    type: 'warning',
                    message: 'No items selected to remove from queue'
                });
                return;
            }
            
            try {
                const response = await fetch('/api/batch/queue-remove', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        node_ids: nodeIds
                    })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Batch queue remove failed');
                }
                
                const result = await response.json();
                
                // Show success message
                const { summary } = result;
                let message = `Removed ${summary.removed_count} item(s) from queue`;
                if (summary.skipped_count > 0) {
                    message += `, skipped ${summary.skipped_count}`;
                }
                if (summary.failed_count > 0) {
                    message += `, failed ${summary.failed_count}`;
                }
                
                state.addToast({
                    type: summary.failed_count > 0 ? 'warning' : 'success',
                    message: message
                });
                
                // Refresh data to show updated state
                connection.refreshData();
                
            } catch (error) {
                console.error('Batch queue remove error:', error);
                state.addToast({
                    type: 'error',
                    message: `Failed to remove items from queue: ${error.message}`
                });
            }
        }
        
        // Fetch version
        async function fetchVersion() {
            try {
                const response = await fetch('/api/version');
                if (response.ok) {
                    const data = await response.json();
                    const versionBadge = document.getElementById('version-badge');
                    if (versionBadge && data.version) {
                        versionBadge.textContent = `v${data.version}`;
                        versionBadge.title = `Version ${data.version}`;
                    }
                }
            } catch (error) {
                console.warn('Failed to fetch version:', error);
            }
        }
        
        // Update follow badge based on state
        function updateFollowBadge() {
            const followBadge = document.getElementById('follow-badge');
            if (!followBadge) return;
            
            const autoFollow = state.get('ui.autoFollow');
            const currentView = state.get('ui.currentView');
            const followingNodeId = state.get('ui.followingNodeId');
            const followTypeFilter = state.get('ui.followTypeFilter');
            const pinnedAgentId = state.get('ui.pinnedAgentId');
            
            // Show badge only when:
            // 1. Follow Agents is ON (autoFollow is true)
            // 2. Currently on Graph tab (currentView === 'graph')
            // 3. Following an agent (followingNodeId is set and followTypeFilter is 'agent')
            const shouldShow = autoFollow && 
                             currentView === 'graph' && 
                             followingNodeId && 
                             followTypeFilter === 'agent';
            
            if (shouldShow) {
                // Find the agent node to get its details
                const agents = state.get('entities.agents') || [];
                const agent = agents.find(a => a.id === followingNodeId);
                
                // Check if this agent is pinned
                const isPinned = pinnedAgentId === followingNodeId;
                const pinIndicator = isPinned ? ' ðŸ“Œ' : '';
                
                if (agent) {
                    const agentName = agent._agent?.purpose || agent._agent?.name || agent.id;
                    followBadge.textContent = `Following ${agentName}${pinIndicator}`;
                    followBadge.title = `Click to pan to ${agentName}`;
                    followBadge.classList.add('visible');
                } else {
                    // Agent not found, just show ID
                    followBadge.textContent = `Following ${followingNodeId}${pinIndicator}`;
                    followBadge.title = `Click to pan to ${followingNodeId}`;
                    followBadge.classList.add('visible');
                }
            } else {
                followBadge.classList.remove('visible');
            }
        }
        
        // Handle follow badge click - pan to the followed agent
        function initializeFollowBadge() {
            const followBadge = document.getElementById('follow-badge');
            if (!followBadge) return;
            
            followBadge.addEventListener('click', () => {
                const followingNodeId = state.get('ui.followingNodeId');
                if (!followingNodeId) return;
                
                // Find the node in the graph
                const graphNodes = graph.getNodes();
                const node = graphNodes.find(n => n.id === followingNodeId);
                
                if (!node) {
                    console.warn(`Followed agent ${followingNodeId} not found in graph`);
                    return;
                }
                
                // Pan to the agent
                graph.panToNode(node.x, node.y, {
                    canvas: document.querySelector('#graph-canvas'),
                    duration: 500
                });
            });
            
            // Subscribe to state changes
            state.subscribe('ui.autoFollow', updateFollowBadge);
            state.subscribe('ui.currentView', updateFollowBadge);
            state.subscribe('ui.followingNodeId', updateFollowBadge);
            state.subscribe('ui.followTypeFilter', updateFollowBadge);
            state.subscribe('entities.agents', updateFollowBadge);
            
            // Initial update
            updateFollowBadge();
        }
        
        // Initialize connection
        async function initializeApp() {
            // Load user preferences from storage
            state.initFromStorage();
            
            // Fetch version
            await fetchVersion();
            
            // Initialize follow badge
            initializeFollowBadge();
            
            // Mount connection status indicator
            mountConnectionStatus('#connection-status-container');
            
            // Detect connection mode
            const detection = connection.detectMode();
            
            // If no mode detected and we're served from a server (not file://),
            // auto-connect to WebSocket on the same origin
            if (detection.mode === state.ConnectionMode.NONE && 
                window.location.protocol !== 'file:') {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws`;
                
                console.log('Auto-connecting to WebSocket:', wsUrl);
                
                try {
                    await connection.connect(wsUrl, {
                        onStateChange: () => {
                            // Trigger graph update when data changes
                            console.log('State updated from server');
                            graph.rebuildGraph();
                        }
                    });
                } catch (error) {
                    // Silently handle WebSocket unavailability (e.g., in headless browsers)
                    if (!error.message || !error.message.includes('WebSocket is not supported')) {
                        throw error;
                    }
                }
            } else {
                // Apply detected mode (archive or explicit WebSocket URL)
                await connection.applyDetectedMode(detection);
                
                // If WebSocket mode, connect
                if (detection.mode === state.ConnectionMode.WEBSOCKET && detection.wsUrl) {
                    try {
                        await connection.connect(detection.wsUrl, {
                            onStateChange: () => {
                                console.log('State updated from server');
                                graph.rebuildGraph();
                            }
                        });
                    } catch (error) {
                        // Silently handle WebSocket unavailability (e.g., in headless browsers)
                        if (!error.message || !error.message.includes('WebSocket is not supported')) {
                            throw error;
                        }
                    }
                }
                // TODO: If archive mode, load archive
                // TODO: If NONE mode on file://, show connection picker
            }
            
            // Start graph animation
            graph.startAnimation();
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            graph.resizeCanvas();
        });
        
        // Start the app
        initializeApp().catch(err => {
            // Don't log expected errors like WebSocket unavailability in headless browsers
            if (!err.message || !err.message.includes('WebSocket is not supported')) {
                console.error('Failed to initialize app:', err);
            }
        });
    </script>
</body>
</html>
