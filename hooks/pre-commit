#!/usr/bin/env bash
# Binnacle pre-commit hook
# Validates code formatting and linting before allowing commit

set -e

# Get repository root directory
repo_root=$(git rev-parse --show-toplevel)

echo "Running pre-commit checks..."

# Run format check
echo "  → Checking code formatting..."
if ! cargo fmt --check --quiet 2>&1; then
    echo ""
    echo "❌ Code formatting check failed!"
    echo "   Run 'cargo fmt' to fix formatting issues."
    exit 1
fi

# Run clippy
echo "  → Running clippy..."
if ! cargo clippy --all-targets --all-features --quiet -- -D warnings 2>&1; then
    echo ""
    echo "❌ Clippy check failed!"
    echo "   Fix the issues reported above before committing."
    exit 1
fi

# Run JavaScript linting if any .js files are staged
echo "  → Checking for staged JavaScript files..."
staged_js_files=$(git diff --cached --name-only --diff-filter=ACM -- '*.js' 2>/dev/null || true)

if [ -n "$staged_js_files" ]; then
    echo "  → Running JavaScript linting..."
    
    # Check if node_modules exists (ESLint installed)
    if [ ! -d "node_modules" ]; then
        echo ""
        echo "❌ ESLint not installed!"
        echo "   Run 'npm install' to install ESLint."
        exit 1
    fi
    
    # Run ESLint on staged files only
    if ! npx eslint $staged_js_files 2>&1; then
        echo ""
        echo "❌ JavaScript linting failed!"
        echo "   Fix the issues reported above before committing."
        exit 1
    fi
else
    echo "  ✓ No JavaScript files staged, skipping lint"
fi

# Check version sync between Cargo.toml and README
echo "  → Checking version sync..."

# Check if Cargo.toml is being modified
if git diff --cached --name-only | grep -q '^Cargo.toml$'; then
    # Get the old and new version from Cargo.toml
    old_cargo_version=$(git show HEAD:Cargo.toml 2>/dev/null | grep '^version' | head -1 | sed 's/version = "\(.*\)"/\1/' || echo "")
    new_cargo_version=$(git show :Cargo.toml | grep '^version' | head -1 | sed 's/version = "\(.*\)"/\1/')
    
    # Only check if version actually changed
    if [ "$old_cargo_version" != "$new_cargo_version" ]; then
        # Check if README.md is also being modified and staged
        if ! git diff --cached --name-only | grep -q '^README.md$'; then
            echo ""
            echo "❌ Version sync check failed!"
            echo "   Cargo.toml version changed from $old_cargo_version to $new_cargo_version"
            echo "   but README.md is not staged with matching changes."
            echo ""
            echo "   Update README.md quickstart section to match Cargo.toml version and stage it."
            exit 1
        fi
        
        # Check that the old version no longer appears in staged README.md
        if [ -n "$old_cargo_version" ]; then
            old_version_count=$(git show :README.md | grep -cF "$old_cargo_version" || true)
            
            if [ "$old_version_count" -gt 0 ]; then
                echo ""
                echo "❌ Version sync check failed!"
                echo "   Cargo.toml version changed from $old_cargo_version to $new_cargo_version"
                echo "   but README.md still references the old version $old_version_count time(s)."
                echo ""
                echo "   Replace all occurrences of $old_cargo_version with $new_cargo_version in README.md."
                exit 1
            fi
        fi
        
        echo "  ✓ Old version $old_cargo_version removed from README.md"
    else
        echo "  ✓ Cargo.toml version unchanged, skipping version sync check"
    fi
else
    echo "  ✓ Cargo.toml not modified, skipping version sync check"
fi

# Check if .github/agents/ files are in sync with embedded templates
# Only runs if .github/agents/ directory exists in the repo
echo "  → Checking agent file sync..."

agents_dir="$repo_root/.github/agents"
if [ -d "$agents_dir" ]; then
    # Copilot agent files (do, prd, buddy, ask - interactive chat agents)
    agent_files="do prd buddy ask"
    agents_out_of_sync=""
    agents_missing=""

    for agent in $agent_files; do
        agent_file="$agents_dir/binnacle-$agent.agent.md"
        if [ -f "$agent_file" ]; then
            # Get expected content from cargo run (strips trailing newline for comparison)
            expected_content=$(cargo run --quiet -- config agents show "$agent" --format agent-file -H 2>/dev/null | sed 's/[[:space:]]*$//')

            if [ -z "$expected_content" ]; then
                # Skip if emit failed (build issues)
                continue
            fi

            # Get current file content (strips trailing newline for comparison)
            current_content=$(cat "$agent_file" | sed 's/[[:space:]]*$//')

            # Compare (ignoring trailing whitespace)
            if ! diff -q <(echo "$current_content") <(echo "$expected_content") >/dev/null 2>&1; then
                agents_out_of_sync="$agents_out_of_sync binnacle-$agent.agent.md"
            fi
        else
            agents_missing="$agents_missing binnacle-$agent.agent.md"
        fi
    done

    if [ -n "$agents_missing" ]; then
        echo ""
        echo "❌ Missing agent files in .github/agents/:"
        for file in $agents_missing; do
            echo "     - .github/agents/$file"
        done
        echo ""
        echo "   To fix: Run 'cargo run -- session init --write-copilot-prompts -y' to create them, then stage"
        exit 1
    fi

    if [ -n "$agents_out_of_sync" ]; then
        echo ""
        echo "❌ Agent files out of sync with embedded templates:"
        for file in $agents_out_of_sync; do
            echo "     - .github/agents/$file"
        done
        echo ""
        echo "   To fix: Run 'cargo run -- session init --write-copilot-prompts -y' to regenerate, then stage them"
        exit 1
    fi
    echo "  ✓ Agent files in sync"
else
    echo "  ✓ No .github/agents/ directory, skipping agent file sync"
fi

# Check if .vscode/mcp.json binnacle entry is in sync with embedded template
# Only runs if .vscode/mcp.json exists in the repo
# Allows additional servers - only validates the binnacle entry
echo "  → Checking VS Code MCP config sync..."

mcp_config="$repo_root/.vscode/mcp.json"
if [ -f "$mcp_config" ]; then
    if ! command -v jq &> /dev/null; then
        echo "  ⚠ jq not installed, skipping MCP config validation"
    else
        # Get expected binnacle server config from cargo run
        expected_binnacle=$(cargo run --quiet -- system emit mcp-vscode -H 2>/dev/null | jq -S '.servers.binnacle' 2>/dev/null)

        if [ -n "$expected_binnacle" ] && [ "$expected_binnacle" != "null" ]; then
            # Get current binnacle server config
            current_binnacle=$(jq -S '.servers.binnacle' "$mcp_config" 2>/dev/null)

            if [ "$current_binnacle" = "null" ] || [ -z "$current_binnacle" ]; then
                echo ""
                echo "❌ VS Code MCP config missing binnacle server entry!"
                echo "     - .vscode/mcp.json"
                echo ""
                echo "   To fix: Run 'cargo run -- session init --write-mcp-vscode -y' to add it, then stage"
                exit 1
            fi

            if ! diff -q <(echo "$current_binnacle") <(echo "$expected_binnacle") >/dev/null 2>&1; then
                echo ""
                echo "❌ VS Code MCP config binnacle entry out of sync!"
                echo "     - .vscode/mcp.json"
                echo ""
                echo "   To fix: Run 'cargo run -- session init --write-mcp-vscode -y' to update, then stage"
                exit 1
            fi
            echo "  ✓ MCP config in sync"
        fi
    fi
else
    echo "  ✓ No .vscode/mcp.json, skipping MCP config sync"
fi

# Run cargo audit for security vulnerabilities
echo "  → Running security audit..."
if ! command -v cargo-audit &> /dev/null; then
    echo ""
    echo "❌ cargo-audit not installed!"
    echo "   Install with: cargo install cargo-audit"
    exit 1
fi

if ! cargo audit 2>&1; then
    echo ""
    echo "❌ Security audit failed!"
    echo "   Fix the vulnerabilities reported above before committing."
    exit 1
fi

# Check for documentation litter (new markdown files in unexpected locations)
echo "  → Checking for documentation litter..."

# Allowed locations for markdown files:
# - docs/           (documentation directory)
# - prds/           (PRD files)
# - Root level known files: README.md, CONTRIBUTING.md, AGENTS.md, PRD.md, 
#                           LICENSE, CHANGELOG.md, IDEAS.md, PROMPT.md
ALLOWED_ROOT_MD="README.md|CONTRIBUTING.md|AGENTS.md|PRD.md|LICENSE|CHANGELOG.md|IDEAS.md|PROMPT.md"

# Get newly added or modified markdown files
new_md_files=$(git diff --cached --name-only --diff-filter=A -- '*.md' 2>/dev/null || true)

litter_found=""
for file in $new_md_files; do
    # Skip allowed directories
    if [[ "$file" == docs/* ]] || [[ "$file" == prds/* ]]; then
        continue
    fi
    
    # Skip allowed root-level files
    basename=$(basename "$file")
    if [[ "$basename" =~ ^($ALLOWED_ROOT_MD)$ ]]; then
        continue
    fi
    
    # Skip if the file is not at root level (nested in other dirs like tests/, src/)
    # Only check for litter at repo root
    if [[ "$file" != "$basename" ]]; then
        continue
    fi
    
    # This is a new markdown file at repo root that's not in the allowed list
    litter_found="$litter_found $file"
done

if [ -n "$litter_found" ]; then
    echo ""
    echo "⚠️  Documentation litter detected!"
    echo "   The following markdown files are being added to unexpected locations:"
    for file in $litter_found; do
        echo "     - $file"
    done
    echo ""
    echo "   Documentation should go in:"
    echo "     - docs/        for general documentation"
    echo "     - prds/        for PRDs and design docs"
    echo "     - Or use: bn doc create <entity> -T 'Title' -c 'content'"
    echo ""
    echo "   If this is intentional, add the filename to ALLOWED_ROOT_MD in hooks/pre-commit"
    exit 1
fi

# Check for web asset changes (web/ directory or GUI server code)
echo "  → Checking for web asset changes..."
staged_web_files=$(git diff --cached --name-only --diff-filter=ACM -- 'web/*' 'src/gui/*' 2>/dev/null || true)

if [ -n "$staged_web_files" ]; then
    echo "  → Web assets changed, running lightpanda validation..."
    
    # Check if lightpanda is installed
    if ! command -v lightpanda &> /dev/null; then
        echo ""
        echo "⚠️  lightpanda not installed!"
        echo "   Web assets (web/ or src/gui/) were modified but cannot be validated."
        echo ""
        echo "   To validate your changes:"
        echo "     1. Install lightpanda: https://github.com/lightpanda-io/browser/releases"
        echo "     2. Run: just gui-check"
        echo ""
        echo "   Skipping validation for now, but CI may fail."
        echo "   Consider installing lightpanda to validate locally before committing."
    else
        # Run validation script (using gui-check.sh which works correctly)
        if ! ./scripts/gui-check.sh 2>&1; then
            echo ""
            echo "❌ Web portal validation failed!"
            echo "   Fix JavaScript errors before committing."
            echo "   Run 'just gui-check' to validate interactively."
            exit 1
        fi
    fi
else
    echo "  ✓ No web assets changed, skipping lightpanda validation"
fi

# Check for GitHub tokens (gh_) in staged files
echo "  → Scanning for accidental token commits..."

# GitHub tokens start with gh_ followed by alphanumeric characters (usually 36-40 chars total)
# Exception: test token gh_0000000000000000000000000000000000000000 is allowed
TOKEN_PATTERN='gh_[A-Za-z0-9_]{30,}'
TEST_TOKEN='gh_0000000000000000000000000000000000000000'

# Get staged file contents and scan for tokens
# Use -p to get patch format, which shows what's being added
token_matches=$(git diff --cached -p 2>/dev/null | grep -E "^\+" | grep -v "^+++" | grep -oE "$TOKEN_PATTERN" | grep -v "^${TEST_TOKEN}$" | sort -u || true)

if [ -n "$token_matches" ]; then
    echo ""
    echo "❌ GitHub token(s) detected in staged changes!"
    echo ""
    echo "   Found tokens (first 10 chars shown):"
    for token in $token_matches; do
        echo "     - ${token:0:10}..."
    done
    echo ""
    echo "   This appears to be an accidental credential leak."
    echo "   Remove the token(s) from your staged changes before committing."
    echo ""
    echo "   If this is a test fixture, use the all-zeros test token:"
    echo "     $TEST_TOKEN"
    echo ""
    echo "   To find the files containing tokens:"
    echo "     git diff --cached | grep -n 'gh_'"
    exit 1
fi

echo "✅ All pre-commit checks passed!"
exit 0
