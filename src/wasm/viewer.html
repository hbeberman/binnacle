<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binnacle Viewer</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üß≠</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a2332;
            --bg-secondary: #243447;
            --bg-tertiary: #2d4059;
            --text-primary: #e8edf3;
            --text-secondary: #b8c5d6;
            --accent-blue: #4a90e2;
            --accent-light: #6aa8f0;
            --border-color: #3a4d66;
            --success: #5cb85c;
            --warning: #f0ad4e;
            --danger: #d9534f;
            --info: #5bc0de;
            /* Edge type colors */
            --edge-blocking: #e85d5d;
            --edge-informational: #7a8fa3;
            --edge-fixes: #5cb85c;
            --edge-hierarchy: #9b6ed8;
            --edge-default: #3a4d66;
            /* Node type colors - bugs (reddish) */
            --bug-pending: #e07878;
            --bug-in-progress: #d95050;
            --bug-blocked: #b33a3a;
            --bug-done: #8fbc8f;
            /* Node type colors - ideas (deeper purple) */
            --idea-pending: #8b5fc9;
            --idea-in-progress: #7a4db8;
            --idea-blocked: #5c3a8a;
            --idea-done: #8fbc8f;
            /* Node type colors - queue (teal/cyan) */
            --queue-color: #20b2aa;
            --queue-color-light: #40d0c8;
            /* Node type colors - agents (bright cyan/electric blue) */
            --agent-active: #00d4ff;
            --agent-idle: #6bb3c9;
            --agent-stale: #4a6670;
            /* Edge type colors - queued */
            --edge-queued: #20b2aa;
            /* Edge type colors - agent working_on */
            --edge-agent: #f0c040;
            --edge-agent-past: #6b7a8a;
            /* Node type colors - docs (by doc_type) */
            --doc-prd: #4a90e2;
            --doc-note: #e8b84a;
            --doc-handoff: #e87d4a;
            /* Edge type colors */
            --edge-pinned: #5cb85c;
            --edge-documents: #4a90e2;
            --edge-impacts: #e85d5d;
            /* Overlay backgrounds */
            --overlay-bg: rgba(0, 0, 0, 0.85);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Snapshot Banner */
        .snapshot-banner {
            background: linear-gradient(90deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%);
            padding: 0.75rem 1.5rem;
            border-bottom: 2px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .snapshot-banner-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .snapshot-badge {
            background: var(--warning);
            color: #1a2332;
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .snapshot-title {
            font-size: 1.1rem;
            font-weight: 600;
        }

        .snapshot-meta {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .snapshot-banner-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .snapshot-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .snapshot-stat {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .snapshot-stat-value {
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Main content area */
        .main-content {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        /* Graph canvas */
        #graph-canvas {
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        #graph-canvas.dragging {
            cursor: grabbing;
        }

        #graph-canvas.hovering:not(.dragging) {
            cursor: pointer;
        }

        /* Loading overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--overlay-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 4px solid var(--border-color);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 1rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* Error state */
        .error-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--overlay-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .error-overlay.hidden {
            display: none;
        }

        .error-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .error-message {
            color: var(--danger);
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .error-details {
            color: var(--text-secondary);
            font-size: 0.9rem;
            max-width: 400px;
            text-align: center;
        }

        /* File picker prompt */
        .file-picker-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--overlay-bg);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .file-picker-overlay.hidden {
            display: none;
        }

        .file-picker-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            max-width: 500px;
        }

        .file-picker-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .file-picker-subtitle {
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
        }

        .file-picker-dropzone {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            padding: 2rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .file-picker-dropzone:hover,
        .file-picker-dropzone.dragover {
            border-color: var(--accent-blue);
            background: rgba(74, 144, 226, 0.1);
        }

        .file-picker-icon {
            font-size: 3rem;
            margin-bottom: 0.5rem;
        }

        .file-picker-text {
            color: var(--text-secondary);
        }

        .file-picker-input {
            display: none;
        }

        .file-picker-or {
            color: var(--text-secondary);
            margin: 1rem 0;
        }

        .file-picker-url-form {
            display: flex;
            gap: 0.5rem;
        }

        .file-picker-url-input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .file-picker-url-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .file-picker-btn {
            padding: 0.75rem 1.5rem;
            background: var(--accent-blue);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .file-picker-btn:hover {
            background: var(--accent-light);
        }

        .file-picker-btn:disabled {
            background: var(--border-color);
            cursor: not-allowed;
        }

        /* Node tooltip */
        .node-tooltip {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
            z-index: 50;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .node-tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .tooltip-id {
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--accent-light);
            margin-bottom: 0.25rem;
        }

        .tooltip-meta {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Edge tooltip */
        .edge-tooltip {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.15s ease;
            z-index: 50;
            font-size: 0.8rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .edge-tooltip.visible {
            opacity: 1;
        }

        .edge-tooltip-type {
            font-weight: 600;
            color: var(--text-primary);
        }

        .edge-tooltip-ids {
            color: var(--text-secondary);
            font-family: monospace;
            font-size: 0.75rem;
        }

        /* Controls overlay */
        .controls-overlay {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 20;
        }

        .control-btn {
            width: 36px;
            height: 36px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            transition: all 0.2s ease;
        }

        .control-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-blue);
        }

        .zoom-display {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-align: center;
            min-width: 36px;
        }

        /* Info panel (bottom-left) */
        .info-panel {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-size: 0.8rem;
            z-index: 20;
        }

        .info-panel-title {
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .info-panel-content {
            color: var(--text-secondary);
        }

        /* Sidebar for node list */
        .sidebar {
            width: 280px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .sidebar.collapsed {
            width: 0;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-title {
            font-weight: 600;
        }

        .sidebar-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.2rem;
        }

        .sidebar-search {
            width: 100%;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 0.85rem;
            margin: 0.5rem 0;
        }

        .sidebar-search:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .sidebar-filters {
            padding: 0 0.5rem 0.5rem 0.5rem;
            display: flex;
            gap: 0.5rem;
        }

        .filter-select {
            flex: 1;
            padding: 0.4rem 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 0.75rem;
            cursor: pointer;
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .node-list-item {
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.15s ease;
            margin-bottom: 0.25rem;
        }

        .node-list-item:hover {
            background: var(--bg-tertiary);
        }

        .node-list-item.selected {
            background: rgba(74, 144, 226, 0.2);
            border-left: 3px solid var(--accent-blue);
        }

        .node-list-id {
            font-family: monospace;
            font-size: 0.75rem;
            color: var(--accent-light);
        }

        .node-list-title {
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .node-list-meta {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        /* Status badges */
        .status-badge {
            display: inline-block;
            padding: 0.1rem 0.4rem;
            border-radius: 3px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-pending { background: rgba(91, 192, 222, 0.2); color: #5bc0de; }
        .status-in_progress { background: rgba(240, 173, 78, 0.2); color: #f0ad4e; }
        .status-blocked { background: rgba(217, 83, 79, 0.2); color: #d9534f; }
        .status-done { background: rgba(92, 184, 92, 0.2); color: #5cb85c; }
        .status-cancelled { background: rgba(108, 117, 125, 0.2); color: #6c757d; }
        .status-seed { background: rgba(139, 95, 201, 0.2); color: #8b5fc9; }
        .status-germinating { background: rgba(122, 77, 184, 0.2); color: #7a4db8; }
        .status-promoted { background: rgba(92, 184, 92, 0.2); color: #5cb85c; }
        .status-wilted { background: rgba(108, 117, 125, 0.2); color: #6c757d; }

        /* Details Panel (slides in from right when node selected) */
        .details-panel {
            position: absolute;
            top: 0;
            right: 280px; /* Account for sidebar */
            width: 320px;
            height: 100%;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            transform: translateX(100%);
            transition: transform 0.2s ease-out;
            z-index: 30;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .details-panel.visible {
            transform: translateX(0);
        }

        .sidebar.collapsed ~ .main-content .details-panel {
            right: 0;
        }

        .details-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-tertiary);
        }

        .details-panel-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .details-panel-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0.25rem;
            line-height: 1;
        }

        .details-panel-close:hover {
            color: var(--text-primary);
        }

        .details-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .details-panel-id {
            font-family: monospace;
            font-size: 0.75rem;
            color: var(--accent-light);
            margin-bottom: 0.5rem;
        }

        .details-panel-node-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            word-wrap: break-word;
        }

        .details-panel-short-name {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .details-panel-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .details-panel-badge {
            display: inline-block;
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .badge-priority-0 { background: rgba(217, 83, 79, 0.3); color: #ff6b6b; }
        .badge-priority-1 { background: rgba(240, 173, 78, 0.3); color: #f0ad4e; }
        .badge-priority-2 { background: rgba(91, 192, 222, 0.3); color: #5bc0de; }
        .badge-priority-3 { background: rgba(108, 117, 125, 0.3); color: #adb5bd; }
        .badge-priority-4 { background: rgba(108, 117, 125, 0.2); color: #868e96; }

        .badge-status {
            text-transform: uppercase;
        }

        .badge-tag {
            background: rgba(74, 144, 226, 0.2);
            color: var(--accent-light);
        }

        .details-panel-section {
            margin-bottom: 1rem;
        }

        .details-panel-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            letter-spacing: 0.5px;
        }

        .details-panel-description {
            font-size: 0.85rem;
            line-height: 1.5;
            color: var(--text-primary);
            white-space: pre-wrap;
        }

        .details-panel-description.empty {
            color: var(--text-secondary);
            font-style: italic;
        }

        .details-panel-relationships {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .details-panel-relationships li {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 0.8rem;
        }

        .details-panel-relationships li:last-child {
            border-bottom: none;
        }

        .details-panel-edge-type {
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            background: var(--bg-tertiary);
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            white-space: nowrap;
        }

        .details-panel-node-link {
            color: var(--accent-light);
            cursor: pointer;
            font-family: monospace;
            font-size: 0.75rem;
        }

        .details-panel-node-link:hover {
            text-decoration: underline;
        }

        .details-panel-relation-title {
            color: var(--text-secondary);
            font-size: 0.75rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        /* Activity Log Panel */
        .activity-log-panel {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 280px; /* Account for sidebar */
            max-height: 40vh;
            background: var(--bg-secondary);
            border-top: 2px solid var(--border-color);
            display: none;
            flex-direction: column;
            z-index: 40;
        }

        .activity-log-panel.visible {
            display: flex;
        }

        .sidebar.collapsed ~ .main-content .activity-log-panel {
            right: 0;
        }

        .activity-log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-tertiary);
        }

        .activity-log-title {
            font-weight: 600;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .activity-log-count {
            font-size: 0.75rem;
            color: var(--text-secondary);
            background: var(--bg-primary);
            padding: 0.15rem 0.5rem;
            border-radius: 10px;
        }

        .activity-log-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
            padding: 0.25rem;
        }

        .activity-log-close:hover {
            color: var(--text-primary);
        }

        .activity-log-content {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .activity-log-entry {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            margin-bottom: 0.25rem;
            font-size: 0.85rem;
        }

        .activity-log-entry:hover {
            background: var(--bg-tertiary);
        }

        .activity-log-entry.error {
            background: rgba(217, 83, 79, 0.1);
            border-left: 3px solid var(--danger);
        }

        .activity-log-time {
            font-family: monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .activity-log-status {
            font-size: 0.8rem;
        }

        .activity-log-command {
            font-family: monospace;
            font-weight: 500;
            color: var(--accent-light);
        }

        .activity-log-user {
            color: var(--text-secondary);
            font-size: 0.75rem;
        }

        .activity-log-duration {
            color: var(--text-secondary);
            font-size: 0.75rem;
            font-family: monospace;
        }

        .activity-log-error {
            color: var(--danger);
            font-size: 0.8rem;
            flex: 1;
        }

        .activity-log-empty {
            color: var(--text-secondary);
            text-align: center;
            padding: 2rem;
            font-size: 0.9rem;
        }

        /* Activity Log Toggle Button */
        .activity-log-toggle {
            position: fixed;
            bottom: 1rem;
            left: 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            z-index: 30;
            transition: background 0.2s;
        }

        .activity-log-toggle:hover {
            background: var(--bg-tertiary);
        }

        .activity-log-toggle.hidden {
            display: none;
        }

        .activity-log-toggle-badge {
            background: var(--accent-blue);
            color: white;
            font-size: 0.7rem;
            padding: 0.1rem 0.4rem;
            border-radius: 8px;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Snapshot Banner (read-only indicator) -->
        <div class="snapshot-banner">
            <div class="snapshot-banner-left">
                <span class="snapshot-badge">üì∏ Snapshot</span>
                <span class="snapshot-title" id="snapshot-title">Binnacle Graph</span>
                <span class="snapshot-meta" id="snapshot-meta"></span>
            </div>
            <div class="snapshot-banner-right">
                <div class="snapshot-stats" id="snapshot-stats">
                    <span class="snapshot-stat">
                        <span class="snapshot-stat-value" id="stat-nodes">0</span> nodes
                    </span>
                    <span class="snapshot-stat">
                        <span class="snapshot-stat-value" id="stat-edges">0</span> edges
                    </span>
                </div>
            </div>
        </div>

        <!-- Main content area -->
        <div class="main-content">
            <!-- Graph canvas -->
            <canvas id="graph-canvas"></canvas>

            <!-- Node tooltip -->
            <div class="node-tooltip" id="node-tooltip">
                <div class="tooltip-title" id="tooltip-title"></div>
                <div class="tooltip-id" id="tooltip-id"></div>
                <div class="tooltip-meta" id="tooltip-meta"></div>
            </div>

            <!-- Edge tooltip -->
            <div class="edge-tooltip" id="edge-tooltip">
                <div class="edge-tooltip-type" id="edge-tooltip-type"></div>
                <div class="edge-tooltip-ids" id="edge-tooltip-ids"></div>
            </div>

            <!-- Controls overlay -->
            <div class="controls-overlay">
                <button class="control-btn" id="zoom-in-btn" title="Zoom in">+</button>
                <div class="zoom-display" id="zoom-display">100%</div>
                <button class="control-btn" id="zoom-out-btn" title="Zoom out">‚àí</button>
                <button class="control-btn" id="reset-view-btn" title="Reset view">‚ü≤</button>
            </div>

            <!-- Activity Log Toggle Button -->
            <button class="activity-log-toggle hidden" id="activity-log-toggle">
                üìú Activity Log
                <span class="activity-log-toggle-badge" id="activity-log-badge">0</span>
            </button>

            <!-- Activity Log Panel -->
            <div class="activity-log-panel" id="activity-log-panel">
                <div class="activity-log-header">
                    <span class="activity-log-title">
                        üìú Activity Log
                        <span class="activity-log-count" id="activity-log-count">0 entries</span>
                    </span>
                    <button class="activity-log-close" id="activity-log-close" title="Close">&times;</button>
                </div>
                <div class="activity-log-content" id="activity-log-content">
                    <!-- Activity entries will be populated here -->
                </div>
            </div>

            <!-- Info panel -->
            <div class="info-panel" id="info-panel">
                <div class="info-panel-title">üß≠ Binnacle Viewer</div>
                <div class="info-panel-content">
                    <div>Drag to pan ‚Ä¢ Scroll to zoom</div>
                    <div id="viewer-version"></div>
                </div>
            </div>

            <!-- Details Panel (node details when selected) -->
            <div class="details-panel" id="details-panel">
                <div class="details-panel-header">
                    <span class="details-panel-title" id="details-panel-type-title">Entity Details</span>
                    <button class="details-panel-close" id="details-panel-close" title="Close">&times;</button>
                </div>
                <div class="details-panel-content">
                    <div class="details-panel-id" id="details-panel-id"></div>
                    <div class="details-panel-node-title" id="details-panel-title"></div>
                    <div class="details-panel-short-name" id="details-panel-short-name" style="display: none;"></div>
                    <div class="details-panel-meta" id="details-panel-meta"></div>
                    
                    <div class="details-panel-section" id="details-panel-description-section">
                        <div class="details-panel-section-title">Description</div>
                        <div class="details-panel-description" id="details-panel-description"></div>
                    </div>
                    
                    <div class="details-panel-section" id="details-panel-relationships-section" style="display: none;">
                        <div class="details-panel-section-title">Relationships</div>
                        <ul class="details-panel-relationships" id="details-panel-relationships"></ul>
                    </div>
                </div>
            </div>

            <!-- Loading overlay -->
            <div class="loading-overlay" id="loading-overlay">
                <div class="loading-spinner"></div>
                <div class="loading-text" id="loading-text">Initializing viewer...</div>
            </div>

            <!-- Error overlay -->
            <div class="error-overlay hidden" id="error-overlay">
                <div class="error-icon">‚ö†Ô∏è</div>
                <div class="error-message" id="error-message">Error loading graph</div>
                <div class="error-details" id="error-details"></div>
            </div>

            <!-- File picker overlay -->
            <div class="file-picker-overlay hidden" id="file-picker-overlay">
                <div class="file-picker-card">
                    <div class="file-picker-title">Open Binnacle Graph</div>
                    <div class="file-picker-subtitle">Load a .bng archive to view the project graph</div>
                    
                    <div class="file-picker-dropzone" id="file-dropzone">
                        <div class="file-picker-icon">üìÅ</div>
                        <div class="file-picker-text">Drop a .bng file here or click to browse</div>
                    </div>
                    <input type="file" class="file-picker-input" id="file-input" accept=".bng,.tar.gz">
                    
                    <div class="file-picker-or">‚Äî or ‚Äî</div>
                    
                    <form class="file-picker-url-form" id="url-form">
                        <input type="url" class="file-picker-url-input" id="url-input" placeholder="https://example.com/project.bng">
                        <button type="submit" class="file-picker-btn" id="url-load-btn">Load</button>
                    </form>
                </div>
            </div>

            <!-- Sidebar -->
            <div class="sidebar" id="sidebar">
                <div class="sidebar-header">
                    <span class="sidebar-title">Nodes</span>
                    <button class="sidebar-toggle" id="sidebar-toggle">√ó</button>
                </div>
                <div style="padding: 0 0.5rem;">
                    <input type="text" class="sidebar-search" id="sidebar-search" placeholder="Search...">
                </div>
                <div class="sidebar-filters">
                    <select class="filter-select" id="type-filter">
                        <option value="">All Types</option>
                        <option value="task">üìã Task</option>
                        <option value="bug">üêõ Bug</option>
                        <option value="idea">üí° Idea</option>
                        <option value="doc">üìÑ Doc</option>
                        <option value="queue">üì• Queue</option>
                        <option value="agent">ü§ñ Agent</option>
                        <option value="milestone">üèÅ Milestone</option>
                    </select>
                    <select class="filter-select" id="status-filter">
                        <option value="">All Status</option>
                        <option value="pending">‚è≥ Pending</option>
                        <option value="in_progress">üîÑ In Progress</option>
                        <option value="blocked">üö´ Blocked</option>
                        <option value="done">‚úÖ Done</option>
                        <option value="cancelled">‚ùå Cancelled</option>
                        <option value="reopened">üîÅ Reopened</option>
                    </select>
                </div>
                <div class="sidebar-content" id="sidebar-content">
                    <!-- Node list will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- WASM Module Placeholder -->
    <!-- __WASM_BINARY_PLACEHOLDER__ -->
    
    <script type="module">
        // ===========================================
        // Binnacle WASM Viewer
        // ===========================================
        
        // Viewer state
        const state = {
            viewer: null,           // BinnacleViewer instance
            nodes: [],              // Parsed node data
            edges: [],              // Parsed edge data
            actionLogs: [],         // Parsed action log entries
            zoom: 1.0,
            panX: 0,
            panY: 0,
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            hoveredNode: null,
            selectedNode: null,
            animationFrame: null,
            animationTime: 0,       // For animated effects (ms)
            layoutRunning: false,
            archiveSource: null,    // URL or filename of loaded archive
            queuedNodes: new Set(), // Track which nodes are in the queue
            filters: {
                text: '',
                type: '',
                status: ''
            }
        };
        
        // DOM elements
        const canvas = document.getElementById('graph-canvas');
        const ctx = canvas.getContext('2d');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingText = document.getElementById('loading-text');
        const errorOverlay = document.getElementById('error-overlay');
        const errorMessage = document.getElementById('error-message');
        const errorDetails = document.getElementById('error-details');
        const filePickerOverlay = document.getElementById('file-picker-overlay');
        const nodeTooltip = document.getElementById('node-tooltip');
        const edgeTooltip = document.getElementById('edge-tooltip');
        
        // ===========================================
        // WASM Initialization
        // ===========================================
        
        // This will be replaced by the build process with actual WASM loading
        // For now, provide a stub that loads from external module
        async function initWasm() {
            setLoadingText('Loading WASM module...');
            
            // __WASM_INIT_PLACEHOLDER__
            // The build process will replace this with embedded WASM loading
            // For development, try to load from external file
            try {
                const wasmModule = await import('./pkg/binnacle.js');
                await wasmModule.default();
                return wasmModule;
            } catch (e) {
                console.warn('Could not load external WASM module:', e);
                throw new Error('WASM module not available. This viewer needs to be built with embedded WASM.');
            }
        }
        
        // ===========================================
        // URL Parameter Handling
        // ===========================================
        
        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                src: params.get('src') || params.get('file'),  // Archive URL (supports both ?src= and ?file=)
                focus: window.location.hash.slice(1) || null   // Fragment anchor (node ID)
            };
        }
        
        // ===========================================
        // Archive Loading
        // ===========================================
        
        async function loadArchiveFromUrl(url) {
            setLoadingText(`Fetching archive from ${url}...`);
            showLoading();
            
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                const bytes = new Uint8Array(arrayBuffer);
                
                setLoadingText('Parsing archive...');
                state.viewer.loadFromBytes(bytes);
                state.archiveSource = url;
                
                await runLayoutAndRender();
            } catch (e) {
                showError('Failed to load archive', e.message);
            }
        }
        
        async function loadArchiveFromFile(file) {
            setLoadingText(`Loading ${file.name}...`);
            showLoading();
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                const bytes = new Uint8Array(arrayBuffer);
                
                setLoadingText('Parsing archive...');
                state.viewer.loadFromBytes(bytes);
                state.archiveSource = file.name;
                
                await runLayoutAndRender();
            } catch (e) {
                showError('Failed to load archive', e.message);
            }
        }
        
        async function runLayoutAndRender() {
            setLoadingText('Computing layout...');
            
            // Run layout in batches to keep UI responsive
            const maxIterations = 500;
            const batchSize = 50;
            let iterations = 0;
            
            while (iterations < maxIterations && !state.viewer.isStable()) {
                state.viewer.runLayout(batchSize);
                iterations += batchSize;
                
                // Update loading progress
                const progress = Math.min(100, Math.round((iterations / maxIterations) * 100));
                setLoadingText(`Computing layout... ${progress}%`);
                
                // Yield to UI thread
                await new Promise(resolve => setTimeout(resolve, 0));
            }
            
            // Parse nodes and edges from viewer
            state.nodes = JSON.parse(state.viewer.getNodesJson());
            state.edges = JSON.parse(state.viewer.getEdgesJson());
            
            // Parse action logs if available
            try {
                state.actionLogs = JSON.parse(state.viewer.getActionLogsJson());
            } catch (e) {
                state.actionLogs = [];
            }
            
            // Compute which nodes are queued
            computeQueuedNodes();
            
            // Update stats
            updateStats();
            updateSnapshotBanner();
            populateSidebar();
            updateActivityLog();
            
            // Hide loading, start rendering
            hideLoading();
            startRenderLoop();
            
            // Focus on node if specified in URL
            const params = getUrlParams();
            if (params.focus) {
                focusNode(params.focus);
            } else {
                // Fit all nodes in view
                fitToView();
            }
        }
        
        // ===========================================
        // UI State Management
        // ===========================================
        
        function showLoading() {
            loadingOverlay.classList.remove('hidden');
            errorOverlay.classList.add('hidden');
            filePickerOverlay.classList.add('hidden');
        }
        
        function hideLoading() {
            loadingOverlay.classList.add('hidden');
        }
        
        function setLoadingText(text) {
            loadingText.textContent = text;
        }
        
        function showError(message, details) {
            errorMessage.textContent = message;
            errorDetails.textContent = details || '';
            errorOverlay.classList.remove('hidden');
            loadingOverlay.classList.add('hidden');
        }
        
        function showFilePicker() {
            filePickerOverlay.classList.remove('hidden');
            loadingOverlay.classList.add('hidden');
            errorOverlay.classList.add('hidden');
        }
        
        function hideFilePicker() {
            filePickerOverlay.classList.add('hidden');
        }
        
        function updateStats() {
            document.getElementById('stat-nodes').textContent = state.nodes.length;
            document.getElementById('stat-edges').textContent = state.edges.length;
        }
        
        function updateSnapshotBanner() {
            if (state.archiveSource) {
                const filename = state.archiveSource.split('/').pop();
                document.getElementById('snapshot-title').textContent = filename;
                
                // Get manifest data for timestamp
                let metaText = `Loaded from ${state.archiveSource.startsWith('http') ? 'URL' : 'file'}`;
                try {
                    const manifest = JSON.parse(state.viewer.getManifestJson());
                    if (manifest.exported_at) {
                        const date = new Date(manifest.exported_at);
                        const formatted = date.toLocaleString();
                        metaText = `Exported ${formatted}`;
                    }
                } catch (e) {
                    // Fallback to source info if manifest parsing fails
                }
                document.getElementById('snapshot-meta').textContent = metaText;
            }
        }
        
        // ===========================================
        // Sidebar
        // ===========================================
        
        function populateSidebar() {
            const content = document.getElementById('sidebar-content');
            content.innerHTML = '';
            
            // Sort nodes by type, then by ID
            const sorted = [...state.nodes].sort((a, b) => {
                if (a.type !== b.type) return a.type.localeCompare(b.type);
                return a.id.localeCompare(b.id);
            });
            
            for (const node of sorted) {
                const item = document.createElement('div');
                item.className = 'node-list-item';
                item.dataset.nodeId = node.id;
                item.innerHTML = `
                    <div class="node-list-id">${escapeHtml(node.id)}</div>
                    <div class="node-list-title">${escapeHtml(node.short_name || node.title)}</div>
                    <div class="node-list-meta">
                        <span class="status-badge status-${node.status}">${node.status}</span>
                        ${node.type}
                    </div>
                `;
                item.addEventListener('click', () => {
                    focusNode(node.id);
                    selectNode(node);
                });
                content.appendChild(item);
            }
        }
        
        function nodePassesFilters(node) {
            const { text, type, status } = state.filters;
            
            // Text filter (search in id and title/short_name)
            if (text) {
                const q = text.toLowerCase();
                const id = node.id.toLowerCase();
                const title = (node.short_name || node.title || '').toLowerCase();
                if (!id.includes(q) && !title.includes(q)) {
                    return false;
                }
            }
            
            // Type filter
            if (type && node.type !== type) {
                return false;
            }
            
            // Status filter
            if (status && node.status !== status) {
                return false;
            }
            
            return true;
        }
        
        function applyFilters() {
            // Update sidebar visibility
            const items = document.querySelectorAll('.node-list-item');
            for (const item of items) {
                const nodeId = item.dataset.nodeId;
                const node = state.nodes.find(n => n.id === nodeId);
                if (node) {
                    item.style.display = nodePassesFilters(node) ? '' : 'none';
                }
            }
        }
        
        // ===========================================
        // Activity Log
        // ===========================================
        
        function updateActivityLog() {
            const toggle = document.getElementById('activity-log-toggle');
            const badge = document.getElementById('activity-log-badge');
            const countEl = document.getElementById('activity-log-count');
            const content = document.getElementById('activity-log-content');
            
            const count = state.actionLogs.length;
            
            // Update toggle button visibility and badge
            if (count > 0) {
                toggle.classList.remove('hidden');
                badge.textContent = count;
                countEl.textContent = `${count} ${count === 1 ? 'entry' : 'entries'}`;
            } else {
                toggle.classList.add('hidden');
            }
            
            // Populate content
            if (count === 0) {
                content.innerHTML = '<div class="activity-log-empty">No activity log entries in this archive</div>';
                return;
            }
            
            // Render entries (most recent first - they're already sorted by timestamp desc)
            content.innerHTML = state.actionLogs.map(log => {
                const time = formatLogTime(log.timestamp);
                const statusIcon = log.success ? '‚úì' : '‚úó';
                const errorClass = log.success ? '' : 'error';
                const duration = log.duration_ms ? `${log.duration_ms}ms` : '';
                const errorHtml = log.error ? `<span class="activity-log-error">${escapeHtml(log.error)}</span>` : '';
                
                return `
                    <div class="activity-log-entry ${errorClass}">
                        <span class="activity-log-time">${time}</span>
                        <span class="activity-log-status">${statusIcon}</span>
                        <span class="activity-log-command">${escapeHtml(log.command)}</span>
                        <span class="activity-log-user">@${escapeHtml(log.user)}</span>
                        ${duration ? `<span class="activity-log-duration">${duration}</span>` : ''}
                        ${errorHtml}
                    </div>
                `;
            }).join('');
        }
        
        function formatLogTime(timestamp) {
            try {
                const date = new Date(timestamp);
                // Format as "Jan 25, 12:30:45"
                const month = date.toLocaleDateString('en-US', { month: 'short' });
                const day = date.getDate();
                const time = date.toLocaleTimeString('en-US', { hour12: false });
                return `${month} ${day}, ${time}`;
            } catch (e) {
                return timestamp;
            }
        }
        
        function toggleActivityLog() {
            const panel = document.getElementById('activity-log-panel');
            panel.classList.toggle('visible');
        }
        
        function closeActivityLog() {
            const panel = document.getElementById('activity-log-panel');
            panel.classList.remove('visible');
        }
        
        // ==========================================
        // Canvas Rendering
        // ===========================================
        
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            canvas.width = rect.width - (document.getElementById('sidebar').classList.contains('collapsed') ? 0 : 280);
            canvas.height = rect.height;
        }
        
        function startRenderLoop() {
            if (state.animationFrame) return;
            
            function render(timestamp) {
                state.animationTime = timestamp || 0;
                renderGraph();
                state.animationFrame = requestAnimationFrame(render);
            }
            render(0);
        }
        
        function computeQueuedNodes() {
            // Build set of nodes that are queued (have 'queued' edge to a queue node)
            state.queuedNodes.clear();
            for (const edge of state.edges) {
                if (edge.edge_type === 'queued') {
                    // Source is queued to target (queue)
                    state.queuedNodes.add(edge.source);
                }
            }
        }
        
        function isNodeQueued(nodeId) {
            return state.queuedNodes.has(nodeId);
        }
        
        function renderGraph() {
            // Clear canvas
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-primary');
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get visible nodes based on filters
            const visibleNodes = state.nodes.filter(nodePassesFilters);
            const visibleNodeIds = new Set(visibleNodes.map(n => n.id));
            
            // Draw edges (only if both nodes are visible)
            for (const edge of state.edges) {
                if (visibleNodeIds.has(edge.source) && visibleNodeIds.has(edge.target)) {
                    drawEdge(edge);
                }
            }
            
            // Draw visible nodes
            for (const node of visibleNodes) {
                drawNode(node);
            }
        }
        
        function worldToScreen(worldX, worldY) {
            return {
                x: (worldX + state.panX) * state.zoom + canvas.width / 2,
                y: (worldY + state.panY) * state.zoom + canvas.height / 2
            };
        }
        
        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX - canvas.width / 2) / state.zoom - state.panX,
                y: (screenY - canvas.height / 2) / state.zoom - state.panY
            };
        }
        
        // Helper to draw a node shape path based on type
        function drawNodeShapePath(ctx, type, x, y, radius) {
            ctx.beginPath();
            if (type === 'queue') {
                drawHexagonPath(ctx, x, y, radius);
            } else if (type === 'bug') {
                drawSquarePath(ctx, x, y, radius);
            } else if (type === 'idea') {
                drawCloudPath(ctx, x, y, radius);
            } else if (type === 'agent') {
                drawPersonPath(ctx, x, y, radius);
            } else if (type === 'doc') {
                drawDocPath(ctx, x, y, radius);
            } else {
                ctx.arc(x, y, radius, 0, Math.PI * 2);
            }
        }
        
        function drawNode(node) {
            const pos = worldToScreen(node.x, node.y);
            const zoom = state.zoom;
            const radius = 25 * zoom;
            
            const isHovered = state.hoveredNode === node;
            const isSelected = state.selectedNode === node;
            
            // Check if node matches search filter (for dimming)
            const searchQuery = state.filters.text.toLowerCase();
            const matchesSearch = !searchQuery || 
                node.id.toLowerCase().includes(searchQuery) ||
                (node.title && node.title.toLowerCase().includes(searchQuery)) ||
                (node.short_name && node.short_name.toLowerCase().includes(searchQuery));
            const isDimmed = searchQuery && !matchesSearch;
            
            // Apply dimming opacity
            ctx.globalAlpha = isDimmed ? 0.3 : 1.0;
            
            // Node color based on status and type
            const color = getNodeColor(node);
            
            // Draw selection highlight (persistent)
            if (isSelected) {
                drawNodeShapePath(ctx, node.type, pos.x, pos.y, radius + 10 * zoom);
                ctx.strokeStyle = '#f0ad4e';
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.fillStyle = 'rgba(240, 173, 78, 0.15)';
                ctx.fill();
            }
            
            // Draw hover highlight
            if (isHovered && !isSelected) {
                drawNodeShapePath(ctx, node.type, pos.x, pos.y, radius + 8 * zoom);
                ctx.fillStyle = 'rgba(74, 144, 226, 0.2)';
                ctx.fill();
                ctx.strokeStyle = '#6aa8f0';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            // Draw queued indicator (teal glow for tasks in the queue)
            const isQueued = node.type !== 'queue' && node.type !== 'agent' && node.type !== 'doc' && isNodeQueued(node.id);
            if (isQueued) {
                drawNodeShapePath(ctx, node.type, pos.x, pos.y, radius + 6 * zoom);
                ctx.strokeStyle = '#20b2aa';  // Queue color (teal)
                ctx.lineWidth = 3;
                ctx.stroke();
                // Add subtle glow effect
                drawNodeShapePath(ctx, node.type, pos.x, pos.y, radius + 4 * zoom);
                ctx.fillStyle = 'rgba(32, 178, 170, 0.15)';
                ctx.fill();
            }
            
            // Draw dotted yellow border for task nodes (visual distinction)
            if (node.type === 'task' && node.status !== 'in_progress') {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius + 4 * zoom, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.7)';  // Gold/yellow color
                ctx.lineWidth = 2 * zoom;
                ctx.setLineDash([4 * zoom, 4 * zoom]);  // Dotted pattern
                ctx.stroke();
                ctx.setLineDash([]);  // Reset line dash
            }
            
            // Draw animated spiral for active agent nodes
            if (node.type === 'agent' && node.status === 'active') {
                const animTime = state.animationTime;
                const rotationSpeed = 0.002;
                const spiralRadius = radius * 0.6;
                
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(animTime * rotationSpeed);
                
                const armCount = 3;
                const armWidth = 3 * zoom;
                
                for (let arm = 0; arm < armCount; arm++) {
                    const baseAngle = (arm * Math.PI * 2) / armCount;
                    
                    const gradient = ctx.createLinearGradient(
                        Math.cos(baseAngle) * spiralRadius * 0.3,
                        Math.sin(baseAngle) * spiralRadius * 0.3,
                        Math.cos(baseAngle) * spiralRadius,
                        Math.sin(baseAngle) * spiralRadius
                    );
                    gradient.addColorStop(0, '#1e3a5f');
                    gradient.addColorStop(1, '#d0d0d0');
                    
                    ctx.beginPath();
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = armWidth;
                    ctx.lineCap = 'round';
                    
                    const startR = spiralRadius * 0.2;
                    const endR = spiralRadius;
                    const curveAngle = Math.PI * 0.5;
                    
                    ctx.moveTo(
                        Math.cos(baseAngle) * startR,
                        Math.sin(baseAngle) * startR
                    );
                    ctx.quadraticCurveTo(
                        Math.cos(baseAngle + curveAngle * 0.5) * spiralRadius * 0.7,
                        Math.sin(baseAngle + curveAngle * 0.5) * spiralRadius * 0.7,
                        Math.cos(baseAngle + curveAngle) * endR,
                        Math.sin(baseAngle + curveAngle) * endR
                    );
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            // Draw in-progress animated rings (counter-rotating hatched rings)
            if (node.status === 'in_progress' && node.type !== 'queue' && node.type !== 'agent' && node.type !== 'doc') {
                const animTime = state.animationTime;
                const rotationSpeed = 0.001;
                const outerRingRadius = radius + 14 * zoom;
                const innerRingRadius = radius + 8 * zoom;
                const ringWidth = 2.5 * zoom;
                const hatchCount = 12;
                const hatchLength = Math.PI / 18;
                
                // Outer ring - rotates clockwise
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(animTime * rotationSpeed);
                ctx.strokeStyle = 'rgba(240, 173, 78, 0.8)';
                ctx.lineWidth = ringWidth;
                ctx.lineCap = 'round';
                for (let i = 0; i < hatchCount; i++) {
                    const startAngle = (i * Math.PI * 2) / hatchCount;
                    ctx.beginPath();
                    ctx.arc(0, 0, outerRingRadius, startAngle, startAngle + hatchLength);
                    ctx.stroke();
                }
                ctx.restore();
                
                // Inner ring - rotates counter-clockwise
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(-animTime * rotationSpeed * 1.5);
                ctx.strokeStyle = 'rgba(255, 200, 100, 0.6)';
                ctx.lineWidth = ringWidth * 0.8;
                ctx.lineCap = 'round';
                for (let i = 0; i < hatchCount; i++) {
                    const startAngle = (i * Math.PI * 2) / hatchCount + Math.PI / hatchCount;
                    ctx.beginPath();
                    ctx.arc(0, 0, innerRingRadius, startAngle, startAngle + hatchLength * 0.8);
                    ctx.stroke();
                }
                ctx.restore();
            }
            
            // Draw node shape
            drawNodeShapePath(ctx, node.type, pos.x, pos.y, radius);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = (isHovered) ? '#ffffff' : '#e8edf3';
            ctx.lineWidth = (isHovered) ? 3 : 2;
            ctx.stroke();
            
            // Draw label - show short_name if set, with ID below
            if (node.type !== 'agent' && zoom > 0.4) {
                ctx.fillStyle = '#1a2332';
                const baseFontSize = 12 * Math.max(0.8, Math.min(1.5, zoom));
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (node.short_name) {
                    // Show short_name inside node
                    ctx.font = `${baseFontSize}px -apple-system, sans-serif`;
                    const label = node.short_name.length > 10 
                        ? node.short_name.substring(0, 9) + '‚Ä¶' 
                        : node.short_name;
                    ctx.fillText(label, pos.x, pos.y);
                    
                    // Show ID below node in smaller font
                    ctx.font = `${baseFontSize * 0.75}px -apple-system, sans-serif`;
                    ctx.fillStyle = '#8899aa';
                    ctx.textBaseline = 'top';
                    ctx.fillText(node.id, pos.x, pos.y + radius + 4 * zoom);
                } else {
                    // Just show ID inside
                    ctx.font = `${baseFontSize}px -apple-system, sans-serif`;
                    ctx.fillText(node.id, pos.x, pos.y);
                }
            }
            
            // Reset global alpha
            ctx.globalAlpha = 1.0;
        }
        
        function drawEdge(edge) {
            const sourceNode = state.nodes.find(n => n.id === edge.source);
            const targetNode = state.nodes.find(n => n.id === edge.target);
            if (!sourceNode || !targetNode) return;
            
            const source = worldToScreen(sourceNode.x, sourceNode.y);
            const target = worldToScreen(targetNode.x, targetNode.y);
            
            // Get edge styling
            const color = getEdgeColor(edge.edge_type);
            const style = getEdgeStyle(edge.edge_type);
            
            ctx.beginPath();
            ctx.moveTo(source.x, source.y);
            ctx.lineTo(target.x, target.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = style.lineWidth * state.zoom;
            
            // Apply dashed line if needed
            if (style.dashed) {
                const dashLen = 6 * state.zoom;
                ctx.setLineDash([dashLen, dashLen]);
                // Animated marching ants for working_on edges
                if (style.animated) {
                    ctx.lineDashOffset = -state.animationTime * 0.02;
                }
            } else {
                ctx.setLineDash([]);
            }
            
            ctx.stroke();
            ctx.setLineDash([]); // Reset dash
            
            // Draw arrow for directed edges
            if (style.hasArrow) {
                drawArrow(ctx, source, target, color, style.arrowSize);
            }
        }
        
        function drawArrow(ctx, from, to, color, arrowSize = 10) {
            const headLen = arrowSize * state.zoom;
            const angle = Math.atan2(to.y - from.y, to.x - from.x);
            
            // Arrow position (near target)
            const arrowX = to.x - Math.cos(angle) * 25 * state.zoom;
            const arrowY = to.y - Math.sin(angle) * 25 * state.zoom;
            
            ctx.beginPath();
            ctx.moveTo(arrowX, arrowY);
            ctx.lineTo(
                arrowX - headLen * Math.cos(angle - Math.PI / 6),
                arrowY - headLen * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                arrowX - headLen * Math.cos(angle + Math.PI / 6),
                arrowY - headLen * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        // Get edge style based on type (matches GUI render.rs edge_style_for_type)
        function getEdgeStyle(edgeType) {
            const styles = {
                // Blocking/dependency edges - solid, directed
                depends_on: { lineWidth: 2.0, arrowSize: 10, dashed: false, animated: false, hasArrow: true },
                blocks: { lineWidth: 2.0, arrowSize: 10, dashed: false, animated: false, hasArrow: true },
                
                // Informational edges - dashed, smaller arrows
                related_to: { lineWidth: 1.5, arrowSize: 8, dashed: true, animated: false, hasArrow: true },
                caused_by: { lineWidth: 1.5, arrowSize: 8, dashed: true, animated: false, hasArrow: true },
                duplicates: { lineWidth: 1.5, arrowSize: 8, dashed: true, animated: false, hasArrow: true },
                supersedes: { lineWidth: 1.5, arrowSize: 8, dashed: true, animated: false, hasArrow: true },
                
                // Fix/test edges - solid, directed
                fixes: { lineWidth: 2.0, arrowSize: 10, dashed: false, animated: false, hasArrow: true },
                tests: { lineWidth: 2.0, arrowSize: 10, dashed: false, animated: false, hasArrow: true },
                
                // Hierarchy edges - solid, directed
                parent_of: { lineWidth: 2.0, arrowSize: 10, dashed: false, animated: false, hasArrow: true },
                child_of: { lineWidth: 2.0, arrowSize: 10, dashed: false, animated: false, hasArrow: true },
                
                // Queue edges - dashed, directed
                queued: { lineWidth: 2.0, arrowSize: 10, dashed: true, animated: false, hasArrow: true },
                
                // Agent edges
                working_on: { lineWidth: 3.0, arrowSize: 12, dashed: true, animated: true, hasArrow: true },
                worked_on: { lineWidth: 2.0, arrowSize: 10, dashed: false, animated: false, hasArrow: true },
                
                // Pinned edges - thick, solid
                pinned: { lineWidth: 3.0, arrowSize: 12, dashed: false, animated: false, hasArrow: true },
                
                // Document edges - dashed
                documents: { lineWidth: 2.0, arrowSize: 10, dashed: true, animated: false, hasArrow: true },
                attached_to: { lineWidth: 2.0, arrowSize: 10, dashed: true, animated: false, hasArrow: true },
                
                // Impact edges - dashed
                impacts: { lineWidth: 2.0, arrowSize: 10, dashed: true, animated: false, hasArrow: true }
            };
            
            return styles[edgeType] || { lineWidth: 1.5, arrowSize: 8, dashed: false, animated: false, hasArrow: false };
        }
        
        // Shape drawing helpers
        function drawHexagonPath(ctx, x, y, r) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = (i * Math.PI) / 3 - Math.PI / 6;
                const px = x + r * Math.cos(angle);
                const py = y + r * Math.sin(angle);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
        }
        
        function drawSquarePath(ctx, x, y, r) {
            const size = r * 1.4;
            ctx.beginPath();
            ctx.rect(x - size / 2, y - size / 2, size, size);
        }
        
        function drawCloudPath(ctx, x, y, r) {
            // Simplified cloud shape using circles
            ctx.beginPath();
            ctx.arc(x, y, r * 0.7, 0, Math.PI * 2);
            ctx.arc(x - r * 0.5, y, r * 0.5, 0, Math.PI * 2);
            ctx.arc(x + r * 0.5, y, r * 0.5, 0, Math.PI * 2);
        }
        
        function drawPersonPath(ctx, x, y, r) {
            // Head
            ctx.beginPath();
            ctx.arc(x, y - r * 0.3, r * 0.4, 0, Math.PI * 2);
            // Body
            ctx.moveTo(x - r * 0.5, y + r * 0.6);
            ctx.lineTo(x + r * 0.5, y + r * 0.6);
            ctx.lineTo(x + r * 0.3, y);
            ctx.lineTo(x - r * 0.3, y);
            ctx.closePath();
        }
        
        function drawDocPath(ctx, x, y, r) {
            const w = r * 1.2;
            const h = r * 1.5;
            const corner = r * 0.3;
            ctx.beginPath();
            ctx.moveTo(x - w / 2, y - h / 2);
            ctx.lineTo(x + w / 2 - corner, y - h / 2);
            ctx.lineTo(x + w / 2, y - h / 2 + corner);
            ctx.lineTo(x + w / 2, y + h / 2);
            ctx.lineTo(x - w / 2, y + h / 2);
            ctx.closePath();
        }
        
        function getNodeColor(node) {
            const colors = {
                task: {
                    pending: '#5bc0de',
                    in_progress: '#f0ad4e',
                    blocked: '#d9534f',
                    done: '#5cb85c'
                },
                bug: {
                    pending: '#e07878',
                    in_progress: '#d95050',
                    blocked: '#b33a3a',
                    done: '#8fbc8f'
                },
                idea: {
                    pending: '#8b5fc9',
                    in_progress: '#7a4db8',
                    blocked: '#5c3a8a',
                    done: '#8fbc8f'
                },
                agent: {
                    active: '#00d4ff',
                    idle: '#6bb3c9',
                    stale: '#4a6670'
                },
                queue: '#20b2aa',
                doc: {
                    prd: '#4a90e2',
                    note: '#e8b84a',
                    handoff: '#e87d4a'
                },
                milestone: '#9b6ed8'
            };
            
            if (node.type === 'queue') return colors.queue;
            if (node.type === 'milestone') return colors.milestone;
            
            const palette = colors[node.type] || colors.task;
            if (typeof palette === 'string') return palette;
            
            if (node.type === 'doc') {
                return palette[node.doc_type] || palette.note;
            }
            
            return palette[node.status] || '#4a90e2';
        }
        
        // Get edge color based on type (matches GUI theme.rs edge_color)
        function getEdgeColor(edgeType) {
            const colors = {
                // Blocking/dependency edges (red)
                depends_on: '#e85d5d',
                blocks: '#e85d5d',
                
                // Informational edges (gray)
                related_to: '#7a8fa3',
                caused_by: '#7a8fa3',
                duplicates: '#7a8fa3',
                supersedes: '#7a8fa3',
                
                // Fix/test edges (green)
                fixes: '#5cb85c',
                tests: '#5cb85c',
                
                // Hierarchy edges (purple)
                child_of: '#9b6ed8',
                parent_of: '#9b6ed8',
                
                // Queue edges (teal)
                queued: '#20b2aa',
                
                // Agent edges (yellow/gray)
                working_on: '#f0c040',
                worked_on: '#6b7a8a',
                
                // Pinned edges (green)
                pinned: '#5cb85c',
                
                // Document edges (blue)
                documents: '#4a90e2',
                attached_to: '#4a90e2',
                
                // Impact edges (red)
                impacts: '#e85d5d'
            };
            return colors[edgeType] || '#3a4d66';
        }
        
        // ===========================================
        // Interaction Handlers
        // ===========================================
        
        function setupEventListeners() {
            // Canvas mouse events
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel, { passive: false });
            canvas.addEventListener('mouseleave', onMouseLeave);
            
            // Zoom controls
            document.getElementById('zoom-in-btn').addEventListener('click', () => {
                setZoom(state.zoom * 1.2);
            });
            document.getElementById('zoom-out-btn').addEventListener('click', () => {
                setZoom(state.zoom / 1.2);
            });
            document.getElementById('reset-view-btn').addEventListener('click', fitToView);
            
            // Sidebar
            document.getElementById('sidebar-toggle').addEventListener('click', toggleSidebar);
            document.getElementById('sidebar-search').addEventListener('input', (e) => {
                state.filters.text = e.target.value;
                applyFilters();
            });
            document.getElementById('type-filter').addEventListener('change', (e) => {
                state.filters.type = e.target.value;
                applyFilters();
            });
            document.getElementById('status-filter').addEventListener('change', (e) => {
                state.filters.status = e.target.value;
                applyFilters();
            });
            
            // File picker
            const dropzone = document.getElementById('file-dropzone');
            const fileInput = document.getElementById('file-input');
            const urlForm = document.getElementById('url-form');
            
            dropzone.addEventListener('click', () => fileInput.click());
            dropzone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropzone.classList.add('dragover');
            });
            dropzone.addEventListener('dragleave', () => {
                dropzone.classList.remove('dragover');
            });
            dropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropzone.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file) {
                    hideFilePicker();
                    loadArchiveFromFile(file);
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    hideFilePicker();
                    loadArchiveFromFile(file);
                }
            });
            
            urlForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const url = document.getElementById('url-input').value.trim();
                if (url) {
                    hideFilePicker();
                    loadArchiveFromUrl(url);
                }
            });
            
            // Window resize
            window.addEventListener('resize', () => {
                resizeCanvas();
            });
            
            // Details panel close button
            document.getElementById('details-panel-close').addEventListener('click', () => {
                state.selectedNode = null;
                updateDetailsPanel(null);
                // Also deselect in sidebar
                document.querySelectorAll('.node-list-item').forEach(item => {
                    item.classList.remove('selected');
                });
            });
            
            // Details panel node link clicks (navigate to related nodes)
            document.getElementById('details-panel').addEventListener('click', (e) => {
                const link = e.target.closest('.details-panel-node-link');
                if (link) {
                    const nodeId = link.dataset.nodeId;
                    if (nodeId) {
                        const node = state.nodes.find(n => n.id === nodeId);
                        if (node) {
                            focusNode(nodeId);
                            selectNode(node);
                        }
                    }
                }
            });
            
            // Activity log toggle and close
            document.getElementById('activity-log-toggle').addEventListener('click', toggleActivityLog);
            document.getElementById('activity-log-close').addEventListener('click', closeActivityLog);
        }
        
        function onMouseDown(e) {
            state.isDragging = true;
            state.dragStart = { x: e.clientX, y: e.clientY };
            canvas.classList.add('dragging');
        }
        
        function onMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (state.isDragging) {
                // Pan
                const dx = e.clientX - state.dragStart.x;
                const dy = e.clientY - state.dragStart.y;
                state.panX += dx / state.zoom;
                state.panY += dy / state.zoom;
                state.dragStart = { x: e.clientX, y: e.clientY };
            } else {
                // Hover detection (only consider visible nodes)
                const world = screenToWorld(x, y);
                const hitRadius = 30 / state.zoom;
                
                let hoveredNode = null;
                for (const node of state.nodes) {
                    if (!nodePassesFilters(node)) continue;
                    const dx = node.x - world.x;
                    const dy = node.y - world.y;
                    if (dx * dx + dy * dy <= hitRadius * hitRadius) {
                        hoveredNode = node;
                        break;
                    }
                }
                
                state.hoveredNode = hoveredNode;
                canvas.classList.toggle('hovering', !!hoveredNode);
                
                // Update tooltip
                if (hoveredNode) {
                    showNodeTooltip(hoveredNode, e.clientX, e.clientY);
                } else {
                    hideTooltips();
                }
            }
        }
        
        function onMouseUp(e) {
            if (state.isDragging) {
                const dx = e.clientX - state.dragStart.x;
                const dy = e.clientY - state.dragStart.y;
                
                // If it was a click (not a drag), select/deselect node
                if (Math.abs(dx) < 5 && Math.abs(dy) < 5 && state.hoveredNode) {
                    selectNode(state.hoveredNode);
                }
            }
            
            state.isDragging = false;
            canvas.classList.remove('dragging');
        }
        
        function onMouseLeave() {
            state.hoveredNode = null;
            canvas.classList.remove('hovering');
            hideTooltips();
        }
        
        function onWheel(e) {
            e.preventDefault();
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            
            // Zoom toward mouse position
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const worldBefore = screenToWorld(x, y);
            setZoom(state.zoom * factor);
            const worldAfter = screenToWorld(x, y);
            
            state.panX += worldAfter.x - worldBefore.x;
            state.panY += worldAfter.y - worldBefore.y;
        }
        
        function setZoom(z) {
            state.zoom = Math.max(0.1, Math.min(5, z));
            document.getElementById('zoom-display').textContent = Math.round(state.zoom * 100) + '%';
        }
        
        function focusNode(nodeId) {
            const node = state.nodes.find(n => n.id === nodeId);
            if (!node) return;
            
            state.panX = -node.x;
            state.panY = -node.y;
            setZoom(1.5);
            
            // Update URL hash
            history.replaceState(null, '', `#${nodeId}`);
        }
        
        // Edge type display names
        const EDGE_TYPE_NAMES = {
            depends_on: 'Depends On',
            blocks: 'Blocks',
            child_of: 'Child Of',
            parent_of: 'Parent Of',
            fixes: 'Fixes',
            caused_by: 'Caused By',
            documents: 'Documents',
            tests: 'Tests',
            supersedes: 'Supersedes',
            impacts: 'Impacts',
            queued: 'Queued',
            pinned: 'Pinned'
        };
        
        // Inverse relationship names (when this node is the target)
        const INVERSE_EDGE_NAMES = {
            depends_on: 'Blocks',
            blocks: 'Depends On',
            child_of: 'Parent Of',
            parent_of: 'Child Of',
            fixes: 'Fixed By',
            caused_by: 'Causes',
            documents: 'Documented By',
            tests: 'Tested By',
            supersedes: 'Superseded By',
            impacts: 'Impacted By',
            queued: 'In Queue',
            pinned: 'Pinned To'
        };
        
        function updateDetailsPanel(node) {
            const panel = document.getElementById('details-panel');
            const typeTitle = document.getElementById('details-panel-type-title');
            const idEl = document.getElementById('details-panel-id');
            const titleEl = document.getElementById('details-panel-title');
            const shortNameEl = document.getElementById('details-panel-short-name');
            const metaEl = document.getElementById('details-panel-meta');
            const descEl = document.getElementById('details-panel-description');
            const descSection = document.getElementById('details-panel-description-section');
            const relSection = document.getElementById('details-panel-relationships-section');
            const relList = document.getElementById('details-panel-relationships');
            
            if (!node) {
                panel.classList.remove('visible');
                return;
            }
            
            // Type labels for header
            const typeLabels = {
                task: 'Task Details',
                bug: 'Bug Details',
                idea: 'Idea Details',
                milestone: 'Milestone Details',
                queue: 'Queue Details',
                agent: 'Agent Details',
                doc: 'Doc Details',
                test: 'Test Details'
            };
            typeTitle.textContent = typeLabels[node.type] || 'Entity Details';
            
            // ID and title
            idEl.textContent = node.id;
            titleEl.textContent = node.title;
            
            // Short name (if different from title)
            if (node.short_name && node.short_name !== node.title) {
                shortNameEl.textContent = `Display: ${node.short_name}`;
                shortNameEl.style.display = 'block';
            } else {
                shortNameEl.style.display = 'none';
            }
            
            // Build metadata badges
            const priority = node.priority ?? 2;
            let metaHtml = `
                <span class="details-panel-badge badge-priority-${priority}">P${priority}</span>
                <span class="details-panel-badge badge-status status-${node.status}">${node.status.replace('_', ' ')}</span>
            `;
            if (node.tags && node.tags.length > 0) {
                metaHtml += node.tags.map(tag => 
                    `<span class="details-panel-badge badge-tag">${escapeHtml(tag)}</span>`
                ).join('');
            }
            if (node.doc_type) {
                metaHtml += `<span class="details-panel-badge badge-tag">${escapeHtml(node.doc_type)}</span>`;
            }
            metaEl.innerHTML = metaHtml;
            
            // Description - we don't have description in the current data model
            // so show a placeholder message
            descEl.textContent = 'Description not available in snapshot';
            descEl.classList.add('empty');
            descSection.style.display = 'block';
            
            // Relationships - find all edges connected to this node
            const nodeEdges = state.edges.filter(edge => 
                edge.source === node.id || edge.target === node.id
            );
            
            if (nodeEdges.length > 0) {
                relList.innerHTML = nodeEdges.map(edge => {
                    const isOutbound = edge.source === node.id;
                    const relatedId = isOutbound ? edge.target : edge.source;
                    const relatedNode = state.nodes.find(n => n.id === relatedId);
                    const relatedTitle = relatedNode?.short_name || relatedNode?.title || '';
                    
                    // Use inverse name for inbound edges
                    const edgeTypeName = isOutbound 
                        ? (EDGE_TYPE_NAMES[edge.edge_type] || edge.edge_type)
                        : (INVERSE_EDGE_NAMES[edge.edge_type] || EDGE_TYPE_NAMES[edge.edge_type] || edge.edge_type);
                    
                    return `<li>
                        <span class="details-panel-edge-type">${escapeHtml(edgeTypeName)}</span>
                        <span class="details-panel-node-link" data-node-id="${escapeHtml(relatedId)}">${escapeHtml(relatedId)}</span>
                        ${relatedTitle ? `<span class="details-panel-relation-title" title="${escapeHtml(relatedTitle)}">${escapeHtml(relatedTitle)}</span>` : ''}
                    </li>`;
                }).join('');
                relSection.style.display = 'block';
            } else {
                relSection.style.display = 'none';
            }
            
            panel.classList.add('visible');
        }
        
        function selectNode(node) {
            state.selectedNode = state.selectedNode === node ? null : node;
            
            // Highlight in sidebar
            const items = document.querySelectorAll('.node-list-item');
            for (const item of items) {
                item.classList.toggle('selected', item.dataset.nodeId === node?.id);
            }
            
            // Update details panel
            updateDetailsPanel(state.selectedNode);
        }
        
        function fitToView() {
            if (state.nodes.length === 0) return;
            
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            
            for (const node of state.nodes) {
                minX = Math.min(minX, node.x);
                maxX = Math.max(maxX, node.x);
                minY = Math.min(minY, node.y);
                maxY = Math.max(maxY, node.y);
            }
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            const width = maxX - minX + 100;
            const height = maxY - minY + 100;
            
            state.panX = -centerX;
            state.panY = -centerY;
            
            const scaleX = canvas.width / width;
            const scaleY = canvas.height / height;
            setZoom(Math.min(scaleX, scaleY, 2) * 0.9);
        }
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
            resizeCanvas();
        }
        
        // ===========================================
        // Tooltips
        // ===========================================
        
        function showNodeTooltip(node, x, y) {
            document.getElementById('tooltip-title').textContent = node.short_name || node.title;
            document.getElementById('tooltip-id').textContent = node.id;
            document.getElementById('tooltip-meta').textContent = `${node.type} ‚Ä¢ ${node.status}`;
            
            nodeTooltip.style.left = (x + 15) + 'px';
            nodeTooltip.style.top = (y + 15) + 'px';
            nodeTooltip.classList.add('visible');
        }
        
        function hideTooltips() {
            nodeTooltip.classList.remove('visible');
            edgeTooltip.classList.remove('visible');
        }
        
        // ===========================================
        // Utility Functions
        // ===========================================
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }
        
        // ===========================================
        // Main Initialization
        // ===========================================
        
        async function main() {
            resizeCanvas();
            setupEventListeners();
            
            try {
                // Initialize WASM
                const wasm = await initWasm();
                state.viewer = new wasm.BinnacleViewer();
                
                // Display version
                document.getElementById('viewer-version').textContent = `v${wasm.version()}`;
                
                // Check URL parameters
                const params = getUrlParams();
                
                if (params.src) {
                    // Load archive from URL
                    await loadArchiveFromUrl(params.src);
                } else {
                    // Show file picker
                    hideLoading();
                    showFilePicker();
                }
            } catch (e) {
                console.error('Initialization failed:', e);
                showError('Failed to initialize viewer', e.message);
            }
        }
        
        // Start the viewer
        main();
    </script>
</body>
</html>
