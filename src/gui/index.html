<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binnacle - Project State Tracker</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ§­</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a2332;
            --bg-secondary: #243447;
            --bg-tertiary: #2d4059;
            --text-primary: #e8edf3;
            --text-secondary: #b8c5d6;
            --accent-blue: #4a90e2;
            --accent-light: #6aa8f0;
            --border-color: #3a4d66;
            --success: #5cb85c;
            --warning: #f0ad4e;
            --danger: #d9534f;
            --info: #5bc0de;
            /* Edge type colors */
            --edge-blocking: #e85d5d;
            --edge-informational: #7a8fa3;
            --edge-fixes: #5cb85c;
            --edge-hierarchy: #9b6ed8;
            --edge-default: #3a4d66;
            /* Node type colors - bugs (reddish) */
            --bug-pending: #e07878;
            --bug-in-progress: #d95050;
            --bug-blocked: #b33a3a;
            --bug-done: #8fbc8f;
            /* Node type colors - ideas (deeper purple) */
            --idea-pending: #8b5fc9;
            --idea-in-progress: #7a4db8;
            --idea-blocked: #5c3a8a;
            --idea-done: #8fbc8f;
            /* Node type colors - queue (teal/cyan) */
            --queue-color: #20b2aa;
            --queue-color-light: #40d0c8;
            /* Node type colors - agents (bright cyan/electric blue) */
            --agent-active: #00d4ff;
            --agent-idle: #6bb3c9;
            --agent-stale: #4a6670;
            /* Edge type colors - queued */
            --edge-queued: #20b2aa;
            /* Edge type colors - agent working_on */
            --edge-agent: #00d4ff;
            /* Edge type colors - agent worked_on (grey, like a dead/historical link) */
            --edge-agent-past: #6b7a8a;
            /* Node type colors - docs (by doc_type) */
            --doc-prd: #4a90e2;          /* Blue for PRDs */
            --doc-note: #e8b84a;         /* Gold for Notes */
            --doc-handoff: #e87d4a;      /* Orange for Handoffs */
            /* Edge type colors - pinned (solid green, important connections) */
            --edge-pinned: #5cb85c;
            /* Overlay backgrounds */
            --overlay-bg: rgba(0, 0, 0, 0.85);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            border-bottom: 2px solid var(--border-color);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .header-left {
            flex: 1;
        }

        .active-task-pane {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            min-width: 280px;
            max-width: 400px;
            margin-left: 1rem;
            transition: all 0.3s ease;
        }

        .active-task-pane.empty {
            opacity: 0.5;
        }

        .active-task-pane-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .active-task-pane-header .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--warning);
            animation: pulse 2s ease-in-out infinite;
        }

        .active-task-pane.empty .indicator {
            background: var(--text-secondary);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .active-task-id {
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--accent-light);
            margin-bottom: 0.25rem;
        }

        .active-task-title {
            font-size: 0.95rem;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .active-task-meta {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .active-task-meta .badge {
            font-size: 0.75rem;
            padding: 0.15rem 0.5rem;
        }

        /* Available work counter */
        .available-work-pane {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin-left: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 120px;
        }

        .available-work-pane-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.25rem;
        }

        .available-work-count {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-light);
            line-height: 1;
        }

        .available-work-pane.has-work .available-work-count {
            color: var(--success);
        }

        .available-work-pane.no-work .available-work-count {
            color: var(--text-secondary);
            opacity: 0.5;
        }

        .available-work-breakdown {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Emoji count badges for type breakdowns */
        .emoji-count-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            font-size: 0.75rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .emoji-count-badge .emoji {
            font-size: 0.85rem;
        }

        .emoji-count-badge .count {
            color: var(--text-primary);
            font-weight: 600;
        }

        .emoji-count-badge.type-task {
            border-color: var(--info);
        }

        .emoji-count-badge.type-bug {
            border-color: var(--danger);
        }

        .emoji-count-badge.type-idea {
            border-color: var(--idea-pending);
        }

        /* Recently completed pane */
        .recently-completed-pane {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            min-width: 280px;
            max-width: 400px;
            margin-left: 1rem;
            transition: all 0.3s ease;
        }

        .recently-completed-pane.empty {
            opacity: 0.5;
        }

        .recently-completed-pane-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .recently-completed-pane-header .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
        }

        .recently-completed-pane.empty .indicator {
            background: var(--text-secondary);
        }

        .recently-completed-list {
            max-height: 120px;
            overflow-y: auto;
        }

        .recently-completed-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--border-color);
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .recently-completed-item:last-child {
            border-bottom: none;
        }

        .recently-completed-item.fading {
            opacity: 0.5;
        }

        .recently-completed-id {
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--accent-light);
            flex-shrink: 0;
        }

        .recently-completed-title {
            font-size: 0.85rem;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .recently-completed-ago {
            font-size: 0.7rem;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .recently-completed-empty {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--accent-light);
        }

        .subtitle {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        nav {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
        }

        .nav-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-light);
        }

        main {
            flex: 1;
            overflow: auto;
            padding: 2rem;
        }

        .view {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .view.active {
            display: block;
        }

        #graph-view {
            position: relative;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #graph-canvas {
            width: 100%;
            height: calc(100vh - 200px);
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .task-list, .test-list, .log-list, .agents-list {
            display: grid;
            gap: 1rem;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            border-color: var(--accent-blue);
        }

        .card-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
            overflow-wrap: break-word;
            word-break: break-word;
        }

        .card-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.75rem;
        }

        .card-description {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            line-height: 1.4;
            overflow-wrap: break-word;
            word-break: break-word;
        }

        /* Card header with queue toggle */
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 0.75rem;
        }

        .card-header .card-title {
            flex: 1;
            min-width: 0;
        }

        /* Compact queue toggle for task cards */
        .card-queue-toggle {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
            flex-shrink: 0;
        }

        .card-queue-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--text-secondary);
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .card-queue-toggle.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .card-queue-toggle.active::after {
            transform: translateX(14px);
            background: white;
        }

        .card-queue-toggle:hover {
            border-color: #22c55e;
        }

        .card-queue-toggle:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Card actions container for buttons */
        .card-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-shrink: 0;
        }

        /* Jump to node button */
        .card-jump-btn {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .card-jump-btn:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        /* Blocked card styling */
        .card-blocked {
            border-color: var(--danger);
            opacity: 0.8;
        }

        .blocked-banner {
            background: var(--danger);
            color: white;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 4px 4px 0 0;
            margin: -0.75rem -0.75rem 0.5rem -0.75rem;
            text-align: center;
        }

        .blocked-reason {
            font-size: 0.7rem;
            font-weight: 400;
            font-style: italic;
            opacity: 0.9;
            margin-top: 0.15rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .card-closed {
            border-color: var(--success);
            opacity: 0.7;
        }

        .closed-banner {
            background: var(--success);
            color: white;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 4px 4px 0 0;
            margin: -0.75rem -0.75rem 0.5rem -0.75rem;
            text-align: center;
        }

        /* Left sidebar (hover to expand) */
        .agents-sidebar {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 44px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            z-index: 100;
            transition: width 0.2s ease;
            overflow: hidden;
        }

        .agents-sidebar:hover,
        .agents-sidebar.expanded {
            width: 240px;
        }

        .agents-sidebar-header {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            min-height: 44px;
        }

        .agents-sidebar-icon {
            font-size: 1.4rem;
            flex-shrink: 0;
            width: 20px;
            text-align: center;
        }

        .agents-sidebar-title {
            font-weight: 600;
            font-size: 0.9rem;
            margin-left: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .agents-sidebar:hover .agents-sidebar-title,
        .agents-sidebar.expanded .agents-sidebar-title {
            opacity: 1;
        }

        .agents-sidebar-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .agents-sidebar:hover .agents-sidebar-content,
        .agents-sidebar.expanded .agents-sidebar-content {
            opacity: 1;
        }

        .agents-sidebar-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        /* Sidebar sections */
        .sidebar-section {
            margin-bottom: 1rem;
        }

        .sidebar-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            padding: 0 0.25rem;
        }

        /* Collapsible section styles */
        .sidebar-section.collapsible .sidebar-section-title {
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none;
            transition: color 0.2s ease;
        }

        .sidebar-section.collapsible .sidebar-section-title:hover {
            color: var(--text-primary);
        }

        .sidebar-section-toggle {
            font-size: 0.6rem;
            transition: transform 0.2s ease;
            opacity: 0.7;
        }

        .sidebar-section.collapsed .sidebar-section-toggle {
            transform: rotate(-90deg);
        }

        .sidebar-section-content {
            overflow: hidden;
            transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
            max-height: 500px;
            opacity: 1;
        }

        .sidebar-section.collapsed .sidebar-section-content {
            max-height: 0;
            opacity: 0;
        }

        /* Sidebar filter buttons */
        .sidebar-filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        /* Sidebar search input */
        .sidebar-search-container {
            padding: 0.5rem 0;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .sidebar-search {
            width: 100%;
            height: 28px;
            padding: 0 0.5rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 0.8rem;
        }

        .sidebar-search::placeholder {
            color: var(--text-secondary);
        }

        .sidebar-search:focus {
            outline: none;
            border-color: var(--accent-light);
            box-shadow: 0 0 0 2px rgba(106, 168, 240, 0.2);
        }

        /* Hidden items when filtered */
        .sidebar-section.filtered-empty {
            display: none;
        }

        .agents-sidebar-item.filtered-hidden,
        .node-filter-row.filtered-hidden,
        .edge-filter-row.filtered-hidden {
            display: none;
        }

        .agents-sidebar-item {
            padding: 0.5rem;
            border-radius: 6px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .agents-sidebar-item:hover {
            border-color: var(--agent-active);
            background: var(--bg-tertiary);
        }

        .agents-sidebar-item.active {
            border-color: var(--agent-active);
        }

        .agents-sidebar-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .agents-sidebar-item-name {
            font-weight: 600;
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .agents-sidebar-item-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .agents-sidebar-item-status.active { background: var(--agent-active); }
        .agents-sidebar-item-status.idle { background: var(--agent-idle); }
        .agents-sidebar-item-status.stale { background: var(--agent-stale); }

        .agents-sidebar-item-task {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .agents-sidebar-empty {
            padding: 1rem;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .badge {
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .badge-priority-0 { background: var(--danger); color: white; }
        .badge-priority-1 { background: var(--warning); color: white; }
        .badge-priority-2 { background: var(--info); color: white; }
        .badge-priority-3 { background: var(--success); color: white; }

        .badge-status-pending { background: var(--info); color: white; }
        .badge-status-in_progress { background: var(--warning); color: white; }
        .badge-status-blocked { background: var(--danger); color: white; }
        .badge-status-done { background: var(--success); color: white; }

        /* Agent status badges */
        .badge-agent-Active { 
            background: var(--success); 
            color: white;
            animation: agent-pulse 2s ease-in-out infinite;
        }
        .badge-agent-Idle { background: var(--warning); color: white; }
        .badge-agent-Stale { 
            background: var(--danger); 
            color: white;
            opacity: 0.7;
        }

        @keyframes agent-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(92, 184, 92, 0.5); }
            50% { box-shadow: 0 0 8px 4px rgba(92, 184, 92, 0.3); }
        }

        .badge-tag {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        /* Agent card styles */
        .agent-card {
            position: relative;
        }

        .agent-card .agent-pid {
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .agent-card .agent-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-light);
        }

        .agent-card .agent-purpose {
            font-size: 0.9rem;
            color: var(--text-primary);
            margin-top: 0.25rem;
            font-style: italic;
        }

        .agent-card .agent-purpose.agent-type-label {
            color: var(--text-secondary);
            font-style: normal;
            font-size: 0.85rem;
            text-transform: capitalize;
        }

        .agent-card .agent-tasks {
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .agent-card .agent-tasks .no-tasks {
            color: var(--text-muted);
            font-style: italic;
        }

        .agent-card .agent-tasks .task-id {
            font-family: monospace;
            color: var(--accent-blue);
            cursor: pointer;
        }

        .agent-card .agent-tasks .task-id:hover {
            text-decoration: underline;
        }

        .agent-card .agent-stats {
            display: flex;
            gap: 1rem;
            margin-top: 0.75rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .agent-card .agent-stats span {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .log-entry {
            padding: 1rem;
            border-left: 3px solid var(--accent-blue);
            position: relative;
        }
        
        .log-entry.log-error {
            border-left-color: var(--status-bug);
            background: rgba(236, 72, 72, 0.08);
            border-left-width: 4px;
        }
        
        .log-entry.log-success {
            border-left-color: var(--status-done);
        }
        
        .log-status-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
            margin-right: 0.5rem;
        }
        
        .log-status-badge.badge-success {
            background: rgba(76, 175, 80, 0.2);
            color: var(--status-done);
        }
        
        .log-status-badge.badge-failure {
            background: rgba(236, 72, 72, 0.2);
            color: var(--status-bug);
            font-weight: 600;
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .log-time {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .log-user {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .log-details {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
            font-style: italic;
        }
        
        .log-error-msg {
            font-size: 0.85rem;
            color: var(--status-bug);
            margin-top: 0.5rem;
        }
        
        /* Log entry expansion styles */
        .log-entry {
            cursor: pointer;
            transition: background-color 0.15s;
        }
        
        .log-entry:hover {
            background: var(--bg-tertiary);
        }
        
        .log-entry.expanded {
            background: var(--bg-secondary);
            border-left-width: 4px;
        }
        
        .log-entry.keyboard-focused {
            outline: 2px solid var(--accent-primary);
            outline-offset: -2px;
            background: var(--bg-tertiary);
        }
        
        .log-entry.keyboard-focused.expanded {
            background: var(--bg-secondary);
        }
        
        .log-expand-indicator {
            font-size: 0.75rem;
            color: var(--text-secondary);
            transition: transform 0.2s;
            margin-left: auto;
        }
        
        .log-entry.expanded .log-expand-indicator {
            transform: rotate(180deg);
        }
        
        .log-expanded-content {
            display: none;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-color);
            font-size: 0.85rem;
        }
        
        .log-entry.expanded .log-expanded-content {
            display: block;
        }
        
        .log-expanded-section {
            margin-bottom: 0.5rem;
        }
        
        .log-expanded-section:last-child {
            margin-bottom: 0;
        }
        
        .log-expanded-label {
            font-weight: 500;
            color: var(--text-secondary);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 0.25rem;
        }
        
        .log-expanded-args {
            background: var(--bg-tertiary);
            padding: 0.5rem;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.8rem;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        .log-expanded-duration {
            color: var(--accent-light);
        }
        
        .log-expanded-error {
            background: rgba(236, 72, 72, 0.1);
            border: 1px solid var(--status-bug);
            padding: 0.5rem;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--status-bug);
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        .log-expanded-meta {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            color: var(--text-secondary);
        }
        
        .log-expanded-meta-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        /* CLI Command section styles */
        .log-cli-command {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            background: var(--bg-tertiary);
            padding: 0.5rem 0.75rem;
            border-radius: 4px;
            font-family: monospace;
        }
        
        .log-cli-code {
            flex: 1;
            overflow-x: auto;
            white-space: nowrap;
            color: var(--text-primary);
            font-size: 0.85rem;
        }
        
        .log-copy-btn {
            flex-shrink: 0;
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
            padding: 0.35rem 0.65rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .log-copy-btn:hover {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }
        
        .log-copy-btn:active {
            transform: scale(0.95);
        }
        
        /* Session grouping styles */
        .session-group {
            margin-bottom: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .session-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            cursor: pointer;
            user-select: none;
            transition: background 0.15s;
        }
        
        .session-header:hover {
            background: var(--bg-secondary);
        }
        
        .session-toggle {
            font-size: 0.8rem;
            color: var(--text-secondary);
            transition: transform 0.2s;
        }
        
        .session-group.collapsed .session-toggle {
            transform: rotate(-90deg);
        }
        
        .session-info {
            flex: 1;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        
        .session-time {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .session-agent {
            font-size: 0.85rem;
            color: var(--accent-light);
            font-weight: 500;
        }
        
        .session-summary {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-left: auto;
        }
        
        .session-summary .count {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        .session-summary .duration {
            color: var(--text-secondary);
            margin-left: 0.5rem;
        }
        
        .session-entries {
            background: var(--bg-primary);
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .session-group.collapsed .session-entries {
            max-height: 0;
        }
        
        .session-entries .log-entry {
            border-radius: 0;
            border-bottom: 1px solid var(--border-color);
        }
        
        .session-entries .log-entry:last-child {
            border-bottom: none;
        }
        
        /* View toggle for grouped vs flat */
        .view-toggle-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .view-toggle-btn {
            padding: 0.35rem 0.65rem;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .view-toggle-btn:first-child {
            border-radius: 4px 0 0 4px;
        }
        
        .view-toggle-btn:last-child {
            border-radius: 0 4px 4px 0;
            border-left: none;
        }
        
        .view-toggle-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        
        .view-toggle-btn:hover:not(.active) {
            background: var(--bg-secondary);
        }
        
        /* Entity ID links in log entries */
        .entity-link {
            color: var(--accent-blue);
            cursor: pointer;
            text-decoration: none;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.85em;
            padding: 0.1em 0.3em;
            background: var(--bg-tertiary);
            border-radius: 3px;
            transition: background 0.15s, color 0.15s;
        }
        
        .entity-link:hover {
            background: var(--accent-blue);
            color: white;
        }
        
        /* Load More Button for infinite scroll */
        .log-load-more {
            display: flex;
            justify-content: center;
            padding: 1rem;
            border-top: 1px solid var(--border-color);
            margin-top: 0.5rem;
        }
        
        .log-load-more-btn {
            padding: 0.6rem 1.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.15s;
        }
        
        .log-load-more-btn:hover:not(:disabled) {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        
        .log-load-more-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        /* Highlight animation for targeted nodes */
        @keyframes node-highlight-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(52, 152, 219, 0); }
            50% { box-shadow: 0 0 0 15px rgba(52, 152, 219, 0.4); }
        }

        /* Activity Log Filter Styles */
        .log-filters {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .log-filters-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
        }

        .log-filter-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .log-search-group {
            flex: 1;
            min-width: 200px;
        }

        .filter-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 500;
            white-space: nowrap;
        }

        .filter-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
        }

        .filter-chip {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 0.25rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .filter-chip:hover {
            background: var(--accent-blue);
            color: var(--text-primary);
            border-color: var(--accent-blue);
        }

        .filter-chip.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-light);
        }

        .filter-select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.35rem 0.75rem;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            min-width: 120px;
        }

        .filter-select:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .status-toggle {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            overflow: hidden;
        }

        .status-toggle-btn {
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-secondary);
            padding: 0.35rem 0.6rem;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border-right: 1px solid var(--border-color);
        }

        .status-toggle-btn:last-child {
            border-right: none;
        }

        .status-toggle-btn:hover {
            background: var(--accent-blue);
            color: var(--text-primary);
        }

        .status-toggle-btn.active {
            background: var(--accent-blue);
            color: white;
        }

        .filter-input {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.35rem 0.75rem;
            border-radius: 6px;
            font-size: 0.8rem;
            flex: 1;
            min-width: 150px;
        }

        .filter-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .filter-input::placeholder {
            color: var(--text-secondary);
        }

        .date-presets {
            display: flex;
            gap: 0.25rem;
        }

        .date-preset-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .date-preset-btn:hover {
            background: var(--accent-blue);
            color: var(--text-primary);
            border-color: var(--accent-blue);
        }

        .date-preset-btn.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-light);
        }

        /* Custom date range inputs */
        .custom-date-range {
            display: none;
            gap: 0.5rem;
            align-items: center;
            margin-top: 0.5rem;
        }

        .custom-date-range.visible {
            display: flex;
        }

        .custom-date-range input[type="date"] {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
        }

        .custom-date-range input[type="date"]:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .custom-date-range label {
            font-size: 0.7rem;
            color: var(--text-secondary);
        }

        .date-preset-btn[data-range="custom"].active {
            background: var(--accent-purple, #9333ea);
            border-color: var(--accent-purple, #9333ea);
        }

        .log-filter-summary {
            font-size: 0.75rem;
            color: var(--text-secondary);
            padding-top: 0.5rem;
            border-top: 1px solid var(--border-color);
        }

        .log-filter-summary:empty {
            display: none;
        }

        /* Activity Timeline Heatmap */
        .activity-timeline {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .activity-timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .activity-timeline-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .activity-timeline-range {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .activity-timeline-svg {
            width: 100%;
            height: 40px;
            display: block;
            cursor: pointer;
        }

        .activity-timeline-segment {
            fill: var(--accent-blue);
            opacity: 0.2;
            transition: opacity 0.15s ease, fill 0.15s ease;
        }

        .activity-timeline-segment:hover {
            opacity: 1;
            fill: var(--accent-light);
        }

        .activity-timeline-segment.selected {
            stroke: var(--accent-light);
            stroke-width: 2;
            opacity: 1;
        }

        .activity-timeline-segment.has-failures {
            fill: var(--danger);
        }

        .activity-timeline-labels {
            display: flex;
            justify-content: space-between;
            font-size: 0.65rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        .activity-timeline-empty {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.8rem;
            padding: 0.5rem 0;
        }

        .activity-timeline-legend {
            display: flex;
            gap: 1rem;
            margin-top: 0.5rem;
            font-size: 0.7rem;
            color: var(--text-muted);
            justify-content: center;
        }

        .activity-timeline-legend-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .legend-swatch {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .legend-swatch.low {
            background: var(--accent-blue);
            opacity: 0.3;
        }

        .legend-swatch.high {
            background: var(--accent-blue);
            opacity: 1;
        }

        .legend-swatch.failures {
            background: var(--danger);
            opacity: 0.8;
        }

        /* Command Frequency Chart */
        .command-frequency-chart {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin: 1rem 0;
            overflow: hidden;
        }

        .command-frequency-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            cursor: pointer;
            user-select: none;
        }

        .command-frequency-header:hover {
            background: rgba(74, 144, 226, 0.1);
        }

        .command-frequency-title {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        .command-frequency-toggle {
            color: var(--text-secondary);
            transition: transform 0.2s ease;
        }

        .command-frequency-chart.collapsed .command-frequency-toggle {
            transform: rotate(-90deg);
        }

        .command-frequency-content {
            padding: 1rem;
            display: flex;
            gap: 2rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .command-frequency-chart.collapsed .command-frequency-content {
            display: none;
        }

        .frequency-bars {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .frequency-bar-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            transition: background 0.15s ease;
        }

        .frequency-bar-row:hover {
            background: rgba(74, 144, 226, 0.1);
        }

        .frequency-bar-row.selected {
            background: rgba(74, 144, 226, 0.2);
            outline: 1px solid var(--accent-blue);
        }

        .frequency-bar-label {
            width: 120px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .frequency-bar-container {
            flex: 1;
            height: 20px;
            background: var(--bg-primary);
            border-radius: 4px;
            overflow: hidden;
        }

        .frequency-bar {
            height: 100%;
            background: var(--accent-blue);
            border-radius: 4px;
            transition: width 0.3s ease;
            min-width: 2px;
        }

        .frequency-bar-row:hover .frequency-bar {
            background: var(--accent-light);
        }

        .frequency-bar-count {
            width: 50px;
            text-align: right;
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-variant-numeric: tabular-nums;
        }

        .frequency-pie {
            width: 150px;
            height: 150px;
            position: relative;
            flex-shrink: 0;
        }

        .frequency-pie svg {
            width: 100%;
            height: 100%;
        }

        .frequency-pie-segment {
            cursor: pointer;
            transition: opacity 0.15s ease;
        }

        .frequency-pie-segment:hover {
            opacity: 0.8;
        }

        .frequency-pie-segment.selected {
            stroke: var(--text-primary);
            stroke-width: 2;
        }

        .frequency-empty {
            color: var(--text-muted);
            font-style: italic;
            text-align: center;
            padding: 2rem;
        }

        .frequency-chart-colors {
            --freq-color-0: #4a90e2;
            --freq-color-1: #5cb85c;
            --freq-color-2: #f0ad4e;
            --freq-color-3: #d9534f;
            --freq-color-4: #9b6ed8;
            --freq-color-5: #5bc0de;
            --freq-color-6: #e85d75;
            --freq-color-7: #20b2aa;
            --freq-color-8: #e8b84a;
            --freq-color-9: #7a8fa3;
        }

        /* Search highlight */
        .log-highlight {
            background: rgba(250, 204, 21, 0.3);
            color: var(--text-primary);
            padding: 0 2px;
            border-radius: 2px;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .modal-content h3 {
            margin: 0 0 1rem 0;
            color: var(--danger);
        }

        .modal-body {
            margin-bottom: 1.5rem;
        }

        .modal-body p {
            margin: 0 0 1rem 0;
            color: var(--text-secondary);
        }

        .modal-agent-info {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 1rem;
        }

        .modal-agent-info .agent-name {
            font-weight: 600;
            color: var(--accent-light);
        }

        .modal-agent-info .agent-detail {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        .modal-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.2s ease;
        }

        .modal-btn-cancel {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .modal-btn-cancel:hover {
            background: var(--bg-primary);
        }

        .modal-btn-danger {
            background: var(--danger);
            color: white;
        }

        .modal-btn-danger:hover {
            background: #c9302c;
        }

        .modal-btn-primary {
            background: var(--accent);
            color: white;
        }

        .modal-btn-primary:hover {
            background: var(--accent-light);
        }

        /* Agent Detail Modal */
        .agent-detail-modal .modal-content {
            max-width: 500px;
        }

        .agent-detail-modal .modal-content h3 {
            color: var(--accent);
            margin-bottom: 1.25rem;
        }

        .agent-detail-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .agent-detail-icon {
            width: 48px;
            height: 48px;
            background: var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .agent-detail-title {
            flex: 1;
        }

        .agent-detail-title .agent-name {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .agent-detail-title .agent-pid {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .agent-detail-section {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .agent-detail-section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-tertiary);
            margin-bottom: 0.5rem;
        }

        .agent-detail-purpose {
            color: var(--text-primary);
            line-height: 1.5;
        }

        .agent-detail-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .agent-detail-stat {
            text-align: center;
        }

        .agent-detail-stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--accent);
        }

        .agent-detail-stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .agent-detail-tasks {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .agent-detail-task-id {
            background: var(--bg-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
            color: var(--accent-light);
            font-family: monospace;
        }

        .agent-detail-timestamp {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        /* Terminate button in agent card */
        .agent-card .terminate-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: transparent;
            border: 1px solid var(--danger);
            color: var(--danger);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.7;
        }

        .agent-card .terminate-btn:hover {
            background: var(--danger);
            color: white;
            opacity: 1;
        }

        /* Agent card clickable task links */
        .agent-card .task-link {
            font-family: monospace;
            color: var(--accent-light);
            cursor: pointer;
            text-decoration: none;
            transition: color 0.15s ease;
        }

        .agent-card .task-link:hover {
            color: var(--accent);
            text-decoration: underline;
        }

        /* Focus on Graph button */
        .agent-card .focus-btn {
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s ease;
            margin-top: 0.5rem;
        }

        .agent-card .focus-btn:hover {
            background: var(--accent);
            color: white;
        }

        /* Agent Summary Panel Styles */
        .agent-summary {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--border-color);
        }

        .agent-summary-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem 1rem;
            font-size: 0.85rem;
        }

        .agent-summary-stat {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .agent-summary-stat .stat-icon {
            font-size: 0.9rem;
        }

        .agent-summary-stat .stat-label {
            color: var(--text-secondary);
        }

        .agent-summary-stat .stat-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .agent-summary-stat .stat-value.success {
            color: var(--status-done);
        }

        .agent-summary-stat .stat-value.warning {
            color: var(--status-in-progress);
        }

        .agent-summary-stat .stat-value.error {
            color: var(--status-bug);
        }

        .agent-top-actions {
            margin-top: 0.75rem;
        }

        .agent-top-actions-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .agent-top-actions-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.25rem;
        }

        .agent-action-chip {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.15rem 0.5rem;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .agent-action-chip .action-count {
            color: var(--accent-light);
            margin-left: 0.25rem;
        }

        /* Expandable Agent Timeline */
        .agent-timeline-toggle {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.5rem;
            margin-top: 0.75rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            color: var(--text-secondary);
            font-size: 0.85rem;
            transition: background 0.15s ease;
        }

        .agent-timeline-toggle:hover {
            background: var(--bg-secondary);
        }

        .agent-timeline-toggle .toggle-icon {
            transition: transform 0.2s ease;
        }

        .agent-timeline-toggle.expanded .toggle-icon {
            transform: rotate(180deg);
        }

        .agent-timeline-content {
            display: none;
            margin-top: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-secondary);
        }

        .agent-timeline-content.expanded {
            display: block;
        }

        .agent-timeline-entry {
            padding: 0.4rem 0.6rem;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.8rem;
            display: flex;
            gap: 0.5rem;
            align-items: flex-start;
        }

        .agent-timeline-entry:last-child {
            border-bottom: none;
        }

        .agent-timeline-entry .timeline-time {
            color: var(--text-muted);
            white-space: nowrap;
            min-width: 65px;
        }

        .agent-timeline-entry .timeline-action {
            color: var(--text-primary);
            flex: 1;
        }

        .agent-timeline-entry .timeline-status {
            font-size: 0.9rem;
        }

        .agent-timeline-entry.timeline-error {
            background: rgba(236, 72, 72, 0.08);
        }

        .agent-timeline-entry.timeline-error .timeline-action {
            color: var(--status-bug);
        }

        /* Agent Activity Section */
        .agents-activity-section {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }

        .agents-activity-section h3 {
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .agents-activity-log {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .activity-entry {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.75rem 1rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .activity-entry.activity-error {
            border-color: var(--status-bug);
        }

        .activity-entry .activity-time {
            font-size: 0.8rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }
        
        .activity-entry .activity-status {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .activity-entry .activity-agent {
            font-size: 0.85rem;
            color: var(--accent-light);
            font-weight: 500;
        }

        .activity-entry .activity-action {
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        
        .activity-entry .activity-details {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-style: italic;
            flex-basis: 100%;
            padding-left: 3.5rem;
        }

        .connection-status {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-connected { background: var(--success); }
        .status-disconnected { background: var(--danger); animation: none; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .node-tooltip {
            position: fixed;
            background: var(--overlay-bg);
            color: var(--text-primary);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .node-tooltip.visible {
            display: block;
        }

        .graph-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 0.5rem;
            z-index: 100;
            align-items: center;
            justify-content: flex-end;
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            max-width: calc(100vw - 250px);
        }

        .zoom-buttons {
            display: flex;
            flex-direction: row;
            gap: 0.5rem;
            align-items: center;
            flex-shrink: 0;
        }

        .graph-search {
            height: 32px;
            width: 180px;
            padding: 0 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .graph-search::placeholder {
            color: var(--text-secondary);
        }

        .graph-search:focus {
            outline: none;
            border-color: var(--accent-light);
            box-shadow: 0 0 0 2px rgba(106, 168, 240, 0.2);
        }

        /* View search bar (for Tasks, Bugs, Ideas views) */
        .view-search-container {
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
        }

        .view-search {
            height: 36px;
            width: 100%;
            max-width: 400px;
            padding: 0 0.75rem 0 2.25rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .view-search::placeholder {
            color: var(--text-secondary);
        }

        .view-search:focus {
            outline: none;
            border-color: var(--accent-light);
            box-shadow: 0 0 0 2px rgba(106, 168, 240, 0.2);
        }

        .view-search-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 400px;
        }

        .view-search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
            font-size: 0.9rem;
            pointer-events: none;
        }

        /* Include closed toggle (for Tasks, Bugs, Ideas views) */
        .include-closed-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-left: 0.75rem;
        }

        .include-closed-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .include-closed-switch {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .include-closed-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            transition: transform 0.2s ease;
        }

        .include-closed-switch.active {
            background: var(--accent-blue);
            border-color: var(--accent-light);
        }

        .include-closed-switch.active::after {
            transform: translateX(14px);
        }

        /* Doc type filter */
        .doc-type-filter,
        .node-type-filter {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-left: 0.75rem;
        }

        .filter-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .type-filter-select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
        }

        .type-filter-select:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        /* Auto-follow toggle */
        .auto-follow-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-right: 0.25rem;
            padding-right: 0.5rem;
            border-right: 1px solid var(--border-color);
        }

        .auto-follow-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .auto-follow-switch {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .auto-follow-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            transition: transform 0.2s ease;
        }

        .auto-follow-switch.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .auto-follow-switch.active::after {
            transform: translateX(14px);
        }

        /* Agent selector dropdown */
        .agent-selector {
            font-size: 0.7rem;
            padding: 0.15rem 0.25rem;
            border-radius: 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            max-width: 100px;
            text-overflow: ellipsis;
        }

        .agent-selector:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .agent-selector option {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        /* Auto-follow config button */
        .auto-follow-config-btn {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            background: transparent;
            border: 1px solid transparent;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: var(--text-secondary);
            transition: all 0.2s ease;
            padding: 0;
        }

        .auto-follow-config-btn:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-color);
            color: var(--text-primary);
        }

        .auto-follow-config-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        /* Auto-follow config popover */
        .auto-follow-config-popover {
            position: absolute;
            top: calc(100% + 8px);
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            min-width: 260px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            display: none;
        }

        .auto-follow-config-popover.visible {
            display: block;
            animation: fadeIn 0.15s ease;
        }

        .config-popover-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .config-section {
            margin-bottom: 1rem;
        }

        .config-section:last-child {
            margin-bottom: 0;
        }

        .config-section-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            display: block;
        }

        .config-node-types {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .config-node-type-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.25rem 0;
        }

        .config-node-type-label {
            font-size: 0.8rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .config-node-type-icon {
            font-size: 0.9rem;
        }

        .config-toggle {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .config-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--text-secondary);
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .config-toggle.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .config-toggle.active::after {
            background: white;
            transform: translateX(14px);
        }

        .config-duration-input {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .config-duration-input input {
            width: 60px;
            padding: 0.3rem 0.5rem;
            border-radius: 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            font-size: 0.8rem;
            text-align: center;
        }

        .config-duration-input input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .config-duration-unit {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Hide completed toggle */
        .hide-completed-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-right: 0.25rem;
            padding-right: 0.5rem;
            border-right: 1px solid var(--border-color);
        }

        .hide-completed-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .hide-completed-switch {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .hide-completed-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            transition: transform 0.2s ease;
        }

        .hide-completed-switch.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .hide-completed-switch.active::after {
            transform: translateX(14px);
        }

        /* Chain length filter */
        .chain-length-filter {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-right: 0.25rem;
            padding-right: 0.5rem;
            border-right: 1px solid var(--border-color);
        }

        .chain-length-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .chain-length-slider {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-tertiary);
            border-radius: 2px;
            cursor: pointer;
        }

        .chain-length-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .chain-length-slider::-webkit-slider-thumb:hover {
            background: var(--accent-light);
        }

        .chain-length-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            border: none;
            transition: background 0.2s ease;
        }

        .chain-length-slider::-moz-range-thumb:hover {
            background: var(--accent-light);
        }

        .chain-length-value {
            font-size: 0.75rem;
            font-family: monospace;
            color: var(--text-primary);
            min-width: 1.5rem;
            text-align: center;
        }

        .chain-length-filter.active .chain-length-label {
            color: var(--accent-light);
        }

        /* Node filter buttons (in sidebar) */
        .node-filter-btn {
            padding: 0.35rem 0.5rem;
            font-size: 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            width: 100%;
            text-align: left;
        }

        .node-filter-btn:hover {
            border-color: var(--accent-blue);
        }

        .node-filter-btn.active {
            background: #3a7bc8;
            border-color: var(--accent-light);
            color: white;
        }

        .node-filter-btn .count {
            font-weight: 600;
        }

        .node-filter-row {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            width: 100%;
        }

        .node-filter-row .node-filter-btn {
            flex: 1;
        }

        .node-visibility-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 0.85rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
        }

        .node-visibility-btn:hover {
            border-color: var(--accent-blue);
            opacity: 0.8;
        }

        .node-visibility-btn.active {
            background: var(--info);
            border-color: var(--info);
            color: white;
            opacity: 1;
        }

        .node-filter-all {
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0.25rem;
            padding-bottom: 0.5rem;
        }

        /* Edge filter buttons (in sidebar) */
        .edge-filter-btn {
            padding: 0.35rem 0.5rem;
            font-size: 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            width: 100%;
        }

        .edge-filter-btn:hover {
            border-color: var(--accent-blue);
        }

        .edge-filter-btn.active {
            background: #3a7bc8;  /* Darker blue than --accent-blue for better contrast */
            border-color: var(--accent-light);
            color: white;
        }

        .edge-filter-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .edge-filter-all {
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0.25rem;
            padding-bottom: 0.5rem;
        }

        .edge-filter-row {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            width: 100%;
        }

        .edge-filter-row .edge-filter-btn {
            flex: 1;
        }

        .edge-spring-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 0.85rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
        }

        .edge-spring-btn:hover {
            border-color: var(--accent-blue);
            opacity: 0.8;
        }

        .edge-spring-btn.active {
            background: var(--success);
            border-color: var(--success);
            color: white;
            opacity: 1;
        }

        .edge-spring-btn[disabled] {
            opacity: 0.2;
            cursor: not-allowed;
        }

        .edge-visibility-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 0.85rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
        }

        .edge-visibility-btn:hover {
            border-color: var(--accent-blue);
            opacity: 0.8;
        }

        .edge-visibility-btn.active {
            background: var(--info);
            border-color: var(--info);
            color: white;
            opacity: 1;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: var(--accent-blue);
        }

        .zoom-level {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.35rem 0.5rem;
            font-size: 0.8rem;
            text-align: center;
            color: var(--text-secondary);
            min-width: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Fullscreen/maximize mode for graph */
        #graph-view.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9999;
            background: var(--bg-primary);
        }

        #graph-view.fullscreen #graph-canvas {
            height: 100vh;
            border-radius: 0;
            border: none;
        }

        #graph-view.fullscreen .agents-sidebar {
            top: 0;
            height: 100vh;
        }

        #graph-view.fullscreen .graph-controls {
            top: 1rem;
        }

        .maximize-btn {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 0.5rem;
        }

        .maximize-btn:hover {
            background: var(--accent-blue);
        }

        .tooltip-title {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: var(--accent-light);
        }

        .tooltip-id {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-family: monospace;
            margin-bottom: 0.5rem;
        }

        .tooltip-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        /* Edge tooltip styles */
        .edge-tooltip {
            position: fixed;
            background: var(--overlay-bg);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            pointer-events: none;
            z-index: 1000;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
            font-size: 0.9rem;
        }

        .edge-tooltip.visible {
            display: block;
        }

        .edge-tooltip-type {
            font-weight: 600;
            margin-bottom: 0.4rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .edge-tooltip-type .edge-color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .edge-tooltip-ids {
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.4rem;
        }

        .edge-tooltip-reason {
            font-style: italic;
            color: var(--text-secondary);
            margin-top: 0.4rem;
            padding-top: 0.4rem;
            border-top: 1px solid var(--border-color);
        }

        .edge-tooltip-date {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 0.3rem;
        }

        #graph-canvas {
            cursor: default;
        }

        #graph-canvas.hovering:not(.dragging) {
            cursor: grab;
        }

        #graph-canvas.dragging {
            cursor: grabbing;
        }

        .info-panel {
            position: absolute;
            top: 4rem;  /* Below graph-controls */
            right: 1rem;
            width: 320px;
            max-height: calc(100% - 5rem);
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 99;  /* Below graph-controls */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .info-panel.visible {
            opacity: 1;
            visibility: visible;
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .info-panel-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .info-panel-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: color 0.2s ease;
        }

        .info-panel-close:hover {
            color: var(--text-primary);
        }

        .info-panel-id {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--accent-light);
            margin-bottom: 0.5rem;
        }

        .info-panel-task-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }

        .info-panel-short-name-row {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .info-panel-label {
            font-weight: 500;
            margin-right: 0.5rem;
        }

        .info-panel-short-name {
            color: var(--accent-light);
        }

        .info-panel-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .info-panel-section {
            margin-bottom: 1rem;
        }

        .info-panel-section-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .info-panel-description {
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .info-panel-description.empty {
            color: var(--text-secondary);
            font-style: italic;
        }

        .info-panel-deps {
            list-style: none;
        }

        .info-panel-deps li {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--accent-light);
            padding: 0.25rem 0;
        }

        .info-panel-deps li:before {
            content: "â†’ ";
            color: var(--text-secondary);
        }

        .info-panel-closed-reason {
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.6;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border-left: 3px solid var(--success);
        }

        /* Clickable node links in info panel */
        .info-panel-node-link {
            font-family: monospace;
            color: var(--accent-light);
            cursor: pointer;
            text-decoration: none;
            transition: color 0.15s ease;
        }

        .info-panel-node-link:hover {
            color: var(--accent);
            text-decoration: underline;
        }

        /* Relationships list */
        .info-panel-relationships {
            list-style: none;
        }

        .info-panel-relationships li {
            font-size: 0.9rem;
            color: var(--text-primary);
            padding: 0.35rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-panel-edge-type {
            font-size: 0.75rem;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .info-panel-edge-direction {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Timestamps */
        .info-panel-timestamps {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .info-panel-timestamps dt {
            display: inline;
            font-weight: 500;
        }

        .info-panel-timestamps dd {
            display: inline;
            margin-left: 0.25rem;
            margin-right: 1rem;
        }

        /* Queue toggle in info panel */
        .info-panel-queue-section {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-panel-queue-label {
            font-size: 0.9rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-panel-queue-label::before {
            content: 'ðŸ“‹';
        }

        .queue-toggle-switch {
            width: 40px;
            height: 22px;
            border-radius: 11px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .queue-toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--text-secondary);
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .queue-toggle-switch.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .queue-toggle-switch.active::after {
            transform: translateX(18px);
            background: white;
        }

        .queue-toggle-switch:hover {
            border-color: var(--accent-light);
        }

        .queue-toggle-switch:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Info Panel Tabs */
        .info-panel-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .info-panel-tab {
            padding: 0.5rem 1rem;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: color 0.2s ease, border-color 0.2s ease;
            margin-bottom: -1px;
        }

        .info-panel-tab:hover {
            color: var(--text-primary);
        }

        .info-panel-tab.active {
            color: var(--accent-light);
            border-bottom-color: var(--accent-light);
        }

        .info-panel-tab-content {
            display: none;
        }

        .info-panel-tab-content.active {
            display: block;
        }

        /* Info Panel Activity Log */
        .info-panel-activity-log {
            max-height: 300px;
            overflow-y: auto;
        }

        .info-panel-activity-entry {
            padding: 0.5rem;
            border-radius: 4px;
            background: var(--card-bg);
            margin-bottom: 0.5rem;
            font-size: 0.8rem;
        }

        .info-panel-activity-entry:last-child {
            margin-bottom: 0;
        }

        .info-panel-activity-entry.error {
            background: rgba(239, 68, 68, 0.1);
            border-left: 3px solid var(--error-color);
        }

        .info-panel-activity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .info-panel-activity-command {
            font-family: monospace;
            font-weight: 500;
            color: var(--text-primary);
        }

        .info-panel-activity-time {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .info-panel-activity-args {
            font-size: 0.75rem;
            color: var(--text-secondary);
            word-break: break-word;
        }

        .info-panel-activity-empty {
            color: var(--text-secondary);
            text-align: center;
            padding: 2rem 1rem;
            font-size: 0.85rem;
        }

        .info-panel-activity-loading {
            color: var(--text-secondary);
            text-align: center;
            padding: 1rem;
            font-size: 0.85rem;
        }

        .info-panel-view-full-log {
            display: block;
            text-align: center;
            padding: 0.75rem;
            margin-top: 0.75rem;
            color: var(--accent-light);
            font-size: 0.8rem;
            text-decoration: none;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
        }

        .info-panel-view-full-log:hover {
            background: var(--card-bg);
            border-color: var(--accent-light);
        }

        /* Edge Info Panel */
        .edge-info-panel {
            position: absolute;
            top: 4rem;
            right: 1rem;
            width: 320px;
            max-height: calc(100% - 5rem);
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 99;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .edge-info-panel.visible {
            opacity: 1;
            visibility: visible;
        }

        .edge-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .edge-info-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .edge-info-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: color 0.2s ease;
        }

        .edge-info-close:hover {
            color: var(--text-primary);
        }

        .edge-info-type {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
        }

        .edge-info-type .edge-color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .edge-info-connection {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--accent-light);
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
        }

        .edge-info-node {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .edge-info-node-id {
            color: var(--accent-light);
            font-weight: 500;
        }

        .edge-info-node-title {
            font-family: inherit;
            font-size: 0.85rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .edge-info-arrow {
            text-align: center;
            color: var(--text-muted);
            font-size: 1.2rem;
            margin: 0.5rem 0;
        }

        .edge-info-section {
            margin-top: 1rem;
        }

        .edge-info-section-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .edge-info-reason {
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.6;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-style: italic;
        }

        .edge-info-date {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 0.75rem;
        }

        /* Toast Notification System */
        .toast-container {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            pointer-events: none;
        }

        .toast {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            padding-right: 2.5rem;
            min-width: 280px;
            max-width: 450px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            pointer-events: auto;
            animation: toastSlideIn 0.3s ease;
            position: relative;
        }

        .toast.toast-exit {
            animation: toastSlideOut 0.3s ease forwards;
        }

        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes toastSlideOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        .toast-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
            font-size: 0.9rem;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .toast-close {
            position: absolute;
            top: 50%;
            right: 0.5rem;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            line-height: 1;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .toast-close:hover {
            opacity: 1;
        }

        /* Toast type-specific styles with colored tints */
        .toast-success {
            border-left: 4px solid var(--success);
            background: linear-gradient(90deg, rgba(92, 184, 92, 0.15), var(--bg-secondary) 30%);
        }

        .toast-success .toast-icon {
            color: var(--success);
        }

        .toast-error {
            border-left: 4px solid var(--danger);
            background: linear-gradient(90deg, rgba(217, 83, 79, 0.15), var(--bg-secondary) 30%);
        }

        .toast-error .toast-icon {
            color: var(--danger);
        }

        .toast-warning {
            border-left: 4px solid var(--warning);
            background: linear-gradient(90deg, rgba(240, 173, 78, 0.15), var(--bg-secondary) 30%);
        }

        .toast-warning .toast-icon {
            color: var(--warning);
        }

        .toast-info {
            border-left: 4px solid var(--info);
            background: linear-gradient(90deg, rgba(91, 192, 222, 0.15), var(--bg-secondary) 30%);
        }

        .toast-info .toast-icon {
            color: var(--info);
        }

        /* Responsive layout for graph overlays */
        @media (max-width: 1200px) {
            .graph-controls {
                max-width: calc(100vw - 300px);
            }
        }

        @media (max-width: 900px) {
            .graph-controls {
                max-width: calc(100vw - 200px);
            }
            .graph-search {
                width: 140px;
            }
        }

        @media (max-width: 700px) {
            .graph-controls {
                max-width: calc(100vw - 2rem);
                flex-direction: column;
                align-items: stretch;
            }
            .graph-search {
                width: 100%;
            }
            .hide-completed-toggle,
            .auto-follow-toggle,
            .chain-length-filter {
                border-right: none;
                padding-right: 0;
                margin-right: 0;
                justify-content: space-between;
            }
            .chain-length-slider {
                flex: 1;
                min-width: 80px;
            }
            .zoom-buttons {
                justify-content: center;
            }
            .info-panel {
                top: auto;
                bottom: 1rem;
                left: 1rem;
                right: 1rem;
                width: auto;
                max-height: 50vh;
            }
            .agents-sidebar {
                width: 40px;
            }
            .agents-sidebar:hover,
            .agents-sidebar.expanded {
                width: 200px;
            }
        }

        /* Doc Viewer Modal Styles */
        .doc-viewer-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--overlay-bg);
            display: none;
            z-index: 1000;
            overflow: auto;
        }

        .doc-viewer-modal.visible {
            display: flex;
            justify-content: center;
            padding: 2rem;
        }

        .doc-viewer-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            max-width: 900px;
            width: 100%;
            max-height: calc(100vh - 4rem);
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        .doc-viewer-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
        }

        .doc-viewer-header-content {
            flex: 1;
        }

        .doc-viewer-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .doc-viewer-title .summary-dirty-indicator {
            color: var(--warning);
            font-size: 1.2rem;
            cursor: help;
        }

        .doc-viewer-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .doc-viewer-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            line-height: 1;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .doc-viewer-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Summary Section - Prominent */
        .doc-viewer-summary {
            background: var(--bg-tertiary);
            padding: 1.25rem 1.5rem;
            border-bottom: 2px solid var(--accent-blue);
        }

        .doc-viewer-summary-header {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent-light);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .doc-viewer-summary-content {
            color: var(--text-primary);
            line-height: 1.7;
        }

        .doc-viewer-summary-content p {
            margin: 0;
        }

        .doc-viewer-summary.dirty {
            border-color: var(--warning);
        }

        .doc-viewer-summary.dirty .doc-viewer-summary-header {
            color: var(--warning);
        }

        /* Doc Viewer Layout with Sidebar */
        .doc-viewer-body-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .doc-viewer-main {
            flex: 1;
            overflow: auto;
            display: flex;
            flex-direction: column;
        }

        /* Version History Sidebar */
        .doc-viewer-history-sidebar {
            width: 220px;
            min-width: 220px;
            background: var(--bg-tertiary);
            border-left: 1px solid var(--border-color);
            overflow: auto;
            display: none;
        }

        .doc-viewer-history-sidebar.visible {
            display: block;
        }

        .doc-viewer-history-header {
            padding: 0.75rem 1rem;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .doc-viewer-history-list {
            padding: 0.5rem;
        }

        .doc-viewer-history-item {
            padding: 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 0.25rem;
            transition: background 0.2s ease;
        }

        .doc-viewer-history-item:hover {
            background: var(--bg-secondary);
        }

        .doc-viewer-history-item.current {
            background: var(--accent-blue);
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(59, 130, 246, 0.05));
            border: 1px solid var(--accent-blue);
        }

        .doc-viewer-history-item-version {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .doc-viewer-history-item.current .doc-viewer-history-item-version::after {
            content: 'current';
            font-size: 0.65rem;
            font-weight: 500;
            color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.2);
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
        }

        .doc-viewer-history-item-date {
            font-size: 0.7rem;
            color: var(--text-tertiary);
            margin-top: 0.25rem;
        }

        .doc-viewer-history-item-editor {
            font-size: 0.7rem;
            color: var(--text-tertiary);
            margin-top: 0.125rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .doc-viewer-history-empty {
            padding: 1rem;
            color: var(--text-tertiary);
            font-size: 0.85rem;
            text-align: center;
        }

        /* Main Content */
        .doc-viewer-content {
            padding: 1.5rem;
            flex: 1;
            overflow: auto;
        }

        /* Markdown Rendering Styles */
        .doc-viewer-content h1,
        .doc-viewer-content h2,
        .doc-viewer-content h3,
        .doc-viewer-content h4,
        .doc-viewer-content h5,
        .doc-viewer-content h6 {
            color: var(--text-primary);
            margin-top: 1.5em;
            margin-bottom: 0.75em;
            font-weight: 600;
        }

        .doc-viewer-content h1 { font-size: 1.75rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.3em; }
        .doc-viewer-content h2 { font-size: 1.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.3em; }
        .doc-viewer-content h3 { font-size: 1.25rem; }
        .doc-viewer-content h4 { font-size: 1.1rem; }
        .doc-viewer-content h5 { font-size: 1rem; }
        .doc-viewer-content h6 { font-size: 0.9rem; color: var(--text-secondary); }

        .doc-viewer-content p {
            margin-bottom: 1em;
            line-height: 1.7;
        }

        .doc-viewer-content ul,
        .doc-viewer-content ol {
            margin-bottom: 1em;
            padding-left: 2em;
        }

        .doc-viewer-content li {
            margin-bottom: 0.25em;
        }

        .doc-viewer-content blockquote {
            border-left: 4px solid var(--accent-blue);
            padding-left: 1em;
            margin: 1em 0;
            color: var(--text-secondary);
            font-style: italic;
        }

        .doc-viewer-content a {
            color: var(--accent-light);
            text-decoration: none;
        }

        .doc-viewer-content a:hover {
            text-decoration: underline;
        }

        .doc-viewer-content hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 2em 0;
        }

        /* Inline code */
        .doc-viewer-content code {
            background: var(--bg-tertiary);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 0.9em;
        }

        /* Code blocks with syntax highlighting */
        .doc-viewer-content pre {
            background: #1e2a3a;
            border-radius: 8px;
            padding: 1rem;
            overflow-x: auto;
            margin: 1em 0;
            border: 1px solid var(--border-color);
        }

        .doc-viewer-content pre code {
            background: transparent;
            padding: 0;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        /* Syntax highlighting colors */
        .doc-viewer-content pre .keyword { color: #c792ea; }
        .doc-viewer-content pre .string { color: #c3e88d; }
        .doc-viewer-content pre .number { color: #f78c6c; }
        .doc-viewer-content pre .comment { color: #546e7a; font-style: italic; }
        .doc-viewer-content pre .function { color: #82aaff; }
        .doc-viewer-content pre .type { color: #ffcb6b; }
        .doc-viewer-content pre .operator { color: #89ddff; }
        .doc-viewer-content pre .punctuation { color: #89ddff; }

        /* Language label for code blocks */
        .doc-viewer-content pre[data-lang]::before {
            content: attr(data-lang);
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        /* Tables */
        .doc-viewer-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1em 0;
        }

        .doc-viewer-content th,
        .doc-viewer-content td {
            border: 1px solid var(--border-color);
            padding: 0.5em 0.75em;
            text-align: left;
        }

        .doc-viewer-content th {
            background: var(--bg-tertiary);
            font-weight: 600;
        }

        .doc-viewer-content tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }

        /* Task checkboxes */
        .doc-viewer-content .task-list-item {
            list-style: none;
            margin-left: -1.5em;
        }

        .doc-viewer-content .task-list-item input[type="checkbox"] {
            margin-right: 0.5em;
        }

        /* Clickable doc cards in nodes list */
        .card[data-doc-id] {
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .card[data-doc-id]:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        /* Loading state */
        .doc-viewer-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: var(--text-secondary);
        }

        .doc-viewer-loading::before {
            content: '';
            width: 24px;
            height: 24px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 0.75rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

    </style>
</head>
<body>
    <!-- Toast notification container -->
    <div class="toast-container" id="toast-container"></div>

    <div class="container">
        <header>
            <div class="header-left">
                <h1>ðŸ§­ Binnacle</h1>
                <p class="subtitle">Project State Tracker</p>
                <nav>
                    <button class="nav-btn active" data-view="graph">Graph</button>
                    <button class="nav-btn" data-view="nodes">Nodes</button>
                    <button class="nav-btn" data-view="agents">Agents</button>
                    <button class="nav-btn" data-view="log">Activity Log</button>
                </nav>
            </div>
            <div class="available-work-pane no-work" id="available-work-pane">
                <div class="available-work-pane-header">
                    <span>Available Work</span>
                </div>
                <div class="available-work-count" id="available-work-count">0</div>
                <div class="available-work-breakdown" id="available-work-breakdown"></div>
            </div>
            <div class="active-task-pane empty" id="active-task-pane">
                <div class="active-task-pane-header">
                    <span class="indicator"></span>
                    <span>Active Task</span>
                </div>
                <div class="active-task-id" id="active-task-id">No active task</div>
                <div class="active-task-title" id="active-task-title"></div>
                <div class="active-task-meta" id="active-task-meta"></div>
            </div>
            <div class="recently-completed-pane empty" id="recently-completed-pane">
                <div class="recently-completed-pane-header">
                    <span class="indicator"></span>
                    <span>Recently Completed</span>
                </div>
                <div class="recently-completed-list" id="recently-completed-list">
                    <div class="recently-completed-empty">No recent completions</div>
                </div>
            </div>
        </header>

        <main>
            <div id="graph-view" class="view active">
                <div class="agents-sidebar" id="agents-sidebar">
                    <div class="agents-sidebar-header">
                        <span class="agents-sidebar-icon">ðŸ¤–</span>
                        <span class="agents-sidebar-title">Sidebar</span>
                    </div>
                    <div class="agents-sidebar-content" id="agents-sidebar-content">
                        <!-- Sidebar search input -->
                        <div class="sidebar-search-container">
                            <input class="sidebar-search" id="sidebar-search" type="text" placeholder="Filterâ€¦" autocomplete="off" spellcheck="false" />
                        </div>
                        <!-- Agents section -->
                        <div class="sidebar-section collapsible" id="agents-section" data-section="agents">
                            <div class="sidebar-section-title">Agents <span class="sidebar-section-toggle">â–¼</span></div>
                            <div class="sidebar-section-content">
                                <div class="agents-sidebar-list" id="agents-sidebar-list"></div>
                            </div>
                        </div>
                        <!-- Node filters section -->
                        <div class="sidebar-section collapsible" data-section="nodes">
                            <div class="sidebar-section-title">Nodes <span class="sidebar-section-toggle">â–¼</span></div>
                            <div class="sidebar-section-content">
                                <div class="sidebar-filter-group" id="sidebar-node-filters">
                                    <!-- Node type filter buttons will be populated dynamically -->
                                </div>
                            </div>
                        </div>
                        <!-- Edge filters section -->
                        <div class="sidebar-section collapsible" data-section="edges">
                            <div class="sidebar-section-title">Edges <span class="sidebar-section-toggle">â–¼</span></div>
                            <div class="sidebar-section-content">
                                <div class="sidebar-filter-group" id="sidebar-edge-filters">
                                    <!-- Edge type filter buttons will be populated dynamically -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <canvas id="graph-canvas"></canvas>
                <div class="node-tooltip" id="node-tooltip">
                    <div class="tooltip-title" id="tooltip-title"></div>
                    <div class="tooltip-id" id="tooltip-id"></div>
                    <div class="tooltip-meta" id="tooltip-meta"></div>
                </div>
                <div class="edge-tooltip" id="edge-tooltip">
                    <div class="edge-tooltip-type" id="edge-tooltip-type"></div>
                    <div class="edge-tooltip-ids" id="edge-tooltip-ids"></div>
                    <div class="edge-tooltip-reason" id="edge-tooltip-reason"></div>
                    <div class="edge-tooltip-date" id="edge-tooltip-date"></div>
                </div>
                <div class="graph-controls">
                    <input class="graph-search" id="graph-search" type="text" placeholder="Search nodesâ€¦" autocomplete="off" spellcheck="false" />
                    <div class="chain-length-filter" id="chain-length-filter">
                        <span class="chain-length-label">Chain â‰¥</span>
                        <input type="range" class="chain-length-slider" id="chain-length-slider" min="1" max="5" value="1" title="Filter nodes by minimum chain length" />
                        <span class="chain-length-value" id="chain-length-value">1</span>
                    </div>
                    <div class="hide-completed-toggle">
                        <span class="hide-completed-label">Hide completed</span>
                        <button class="hide-completed-switch" id="hide-completed-switch" title="Hide completed nodes (except in active chains)"></button>
                    </div>
                    <div class="auto-follow-toggle" style="position: relative;">
                        <span class="auto-follow-label">Follow</span>
                        <select class="agent-selector" id="agent-selector" title="Select target to follow">
                            <option value="">None</option>
                        </select>
                        <button class="auto-follow-switch" id="auto-follow-switch" title="Auto-focus on selected target"></button>
                        <button class="auto-follow-config-btn" id="auto-follow-config-btn" title="Configure auto-follow settings">âš™</button>
                        <div class="auto-follow-config-popover" id="auto-follow-config-popover">
                            <div class="config-popover-title">Auto-Follow Settings</div>
                            <div class="config-section">
                                <span class="config-section-label">Trigger auto-follow for new:</span>
                                <div class="config-node-types">
                                    <div class="config-node-type-row">
                                        <span class="config-node-type-label"><span class="config-node-type-icon">ðŸ“‹</span> Tasks</span>
                                        <button class="config-toggle active" id="config-follow-tasks" data-type="task"></button>
                                    </div>
                                    <div class="config-node-type-row">
                                        <span class="config-node-type-label"><span class="config-node-type-icon">ðŸ›</span> Bugs</span>
                                        <button class="config-toggle active" id="config-follow-bugs" data-type="bug"></button>
                                    </div>
                                    <div class="config-node-type-row">
                                        <span class="config-node-type-label"><span class="config-node-type-icon">ðŸ’¡</span> Ideas</span>
                                        <button class="config-toggle" id="config-follow-ideas" data-type="idea"></button>
                                    </div>
                                    <div class="config-node-type-row">
                                        <span class="config-node-type-label"><span class="config-node-type-icon">ðŸ§ª</span> Tests</span>
                                        <button class="config-toggle" id="config-follow-tests" data-type="test"></button>
                                    </div>
                                    <div class="config-node-type-row">
                                        <span class="config-node-type-label"><span class="config-node-type-icon">ðŸ“„</span> Docs</span>
                                        <button class="config-toggle" id="config-follow-docs" data-type="doc"></button>
                                    </div>
                                </div>
                            </div>
                            <div class="config-section">
                                <span class="config-section-label">Focus switch delay:</span>
                                <div class="config-duration-input">
                                    <input type="number" id="config-focus-delay" min="1" max="60" value="10" />
                                    <span class="config-duration-unit">seconds</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="zoom-buttons">
                        <button class="zoom-btn" id="zoom-in" title="Zoom In">+</button>
                        <div class="zoom-level" id="zoom-level">100%</div>
                        <button class="zoom-btn" id="zoom-out" title="Zoom Out">âˆ’</button>
                        <button class="zoom-btn" id="zoom-reset" title="Reset Zoom">âŸ²</button>
                        <button class="maximize-btn" id="maximize-btn" title="Fullscreen (Esc to exit)">â›¶</button>
                    </div>
                </div>
                <div class="info-panel" id="info-panel">
                    <div class="info-panel-header">
                        <span class="info-panel-title" id="info-panel-type-title">Task Details</span>
                        <button class="info-panel-close" id="info-panel-close" title="Close">&times;</button>
                    </div>
                    <div id="info-panel-id" class="info-panel-id"></div>
                    <div id="info-panel-task-title" class="info-panel-task-title"></div>
                    <div id="info-panel-short-name-row" class="info-panel-short-name-row" style="display: none;">
                        <span class="info-panel-label">Display Name:</span>
                        <span id="info-panel-short-name" class="info-panel-short-name"></span>
                    </div>
                    <div id="info-panel-meta" class="info-panel-meta"></div>
                    <div class="info-panel-tabs">
                        <button class="info-panel-tab active" data-tab="details">Details</button>
                        <button class="info-panel-tab" data-tab="activity">Activity</button>
                    </div>
                    <div id="info-panel-details-tab" class="info-panel-tab-content active">
                        <div id="info-panel-queue-section" class="info-panel-queue-section" style="display: none;">
                            <span class="info-panel-queue-label">In Queue</span>
                            <button id="queue-toggle-btn" class="queue-toggle-switch" title="Toggle queue membership"></button>
                        </div>
                        <div id="info-panel-description-section" class="info-panel-section">
                            <div class="info-panel-section-title">Description</div>
                            <div id="info-panel-description" class="info-panel-description"></div>
                        </div>
                        <div id="info-panel-deps-section" class="info-panel-section" style="display: none;">
                            <div class="info-panel-section-title">Depends On</div>
                            <ul id="info-panel-deps" class="info-panel-deps"></ul>
                        </div>
                        <div id="info-panel-relationships-section" class="info-panel-section" style="display: none;">
                            <div class="info-panel-section-title">Relationships</div>
                            <ul id="info-panel-relationships" class="info-panel-relationships"></ul>
                        </div>
                        <div id="info-panel-closed-section" class="info-panel-section" style="display: none;">
                            <div class="info-panel-section-title">Closed Reason</div>
                            <div id="info-panel-closed-reason" class="info-panel-closed-reason"></div>
                        </div>
                        <div id="info-panel-timestamps-section" class="info-panel-section" style="display: none;">
                            <div class="info-panel-section-title">Timestamps</div>
                            <dl id="info-panel-timestamps" class="info-panel-timestamps"></dl>
                        </div>
                    </div>
                    <div id="info-panel-activity-tab" class="info-panel-tab-content">
                        <div id="info-panel-activity-content" class="info-panel-activity-log">
                            <div class="info-panel-activity-loading">Loading activity...</div>
                        </div>
                        <a id="info-panel-view-full-log" class="info-panel-view-full-log">View in full activity log â†’</a>
                    </div>
                </div>
                <div class="edge-info-panel" id="edge-info-panel">
                    <div class="edge-info-header">
                        <span class="edge-info-title">Edge Details</span>
                        <button class="edge-info-close" id="edge-info-close" title="Close">&times;</button>
                    </div>
                    <div class="edge-info-type" id="edge-info-type">
                        <span class="edge-color-indicator" id="edge-info-color"></span>
                        <span id="edge-info-type-name"></span>
                    </div>
                    <div class="edge-info-connection">
                        <div class="edge-info-node">
                            <span class="edge-info-node-id" id="edge-info-source-id"></span>
                            <span class="edge-info-node-title" id="edge-info-source-title"></span>
                        </div>
                        <div class="edge-info-arrow">â†“</div>
                        <div class="edge-info-node">
                            <span class="edge-info-node-id" id="edge-info-target-id"></span>
                            <span class="edge-info-node-title" id="edge-info-target-title"></span>
                        </div>
                    </div>
                    <div id="edge-info-reason-section" class="edge-info-section" style="display: none;">
                        <div class="edge-info-section-title">Reason</div>
                        <div id="edge-info-reason" class="edge-info-reason"></div>
                    </div>
                    <div class="edge-info-date" id="edge-info-date"></div>
                </div>
            </div>

            <div id="nodes-view" class="view">
                <div class="view-search-container">
                    <div class="view-search-wrapper">
                        <span class="view-search-icon">ðŸ”</span>
                        <input class="view-search" id="nodes-search" type="text" placeholder="Search nodesâ€¦" autocomplete="off" spellcheck="false" />
                    </div>
                    <div class="node-type-filter">
                        <label class="filter-label">Type:</label>
                        <select id="nodes-type-filter" class="type-filter-select">
                            <option value="">All</option>
                            <option value="task">Tasks</option>
                            <option value="bug">Bugs</option>
                            <option value="idea">Ideas</option>
                            <option value="test">Tests</option>
                            <option value="doc">Docs</option>
                        </select>
                    </div>
                    <div class="node-type-filter">
                        <label class="filter-label">Tag:</label>
                        <select id="nodes-tag-filter" class="type-filter-select">
                            <option value="">All</option>
                        </select>
                    </div>
                    <div class="include-closed-toggle">
                        <span class="include-closed-label">Include closed</span>
                        <button class="include-closed-switch" id="nodes-include-closed" title="Include closed/done nodes"></button>
                    </div>
                </div>
                <div class="task-list" id="nodes-list"></div>
            </div>

            <div id="agents-view" class="view">
                <div class="agents-list" id="agents-list"></div>
                <div class="agents-activity-section">
                    <h3>Recent Agent Activity</h3>
                    <div class="agents-activity-log" id="agents-activity-log"></div>
                </div>
            </div>

            <div id="log-view" class="view">
                <!-- Activity Log Filter Toolbar -->
                <div class="log-filters">
                    <div class="log-filters-row">
                        <!-- Command Type Filter Chips -->
                        <div class="log-filter-group">
                            <label class="filter-label">Commands:</label>
                            <div class="filter-chips" id="command-filter-chips">
                                <button class="filter-chip active" data-category="all">All</button>
                                <button class="filter-chip" data-category="tasks">Tasks</button>
                                <button class="filter-chip" data-category="tests">Tests</button>
                                <button class="filter-chip" data-category="links">Links</button>
                                <button class="filter-chip" data-category="bugs">Bugs</button>
                                <button class="filter-chip" data-category="ideas">Ideas</button>
                                <button class="filter-chip" data-category="docs">Docs</button>
                                <button class="filter-chip" data-category="system">System</button>
                                <button class="filter-chip" data-category="queue">Queue</button>
                            </div>
                        </div>
                        
                        <!-- View Mode Toggle (Flat vs Grouped) -->
                        <div class="log-filter-group view-toggle-group">
                            <label class="filter-label">View:</label>
                            <button class="view-toggle-btn active" data-view="flat">Flat</button>
                            <button class="view-toggle-btn" data-view="grouped">Sessions</button>
                        </div>
                    </div>
                    <div class="log-filters-row">
                        <!-- User/Agent Filter -->
                        <div class="log-filter-group">
                            <label class="filter-label" for="user-filter">User:</label>
                            <select id="user-filter" class="filter-select">
                                <option value="all">All Users</option>
                                <option value="humans">Humans Only</option>
                                <option value="agents">Agents Only</option>
                            </select>
                        </div>
                        
                        <!-- Success/Failure Toggle -->
                        <div class="log-filter-group">
                            <label class="filter-label">Status:</label>
                            <div class="status-toggle" id="status-filter-toggle">
                                <button class="status-toggle-btn active" data-status="all">All</button>
                                <button class="status-toggle-btn" data-status="success">âœ“ Success</button>
                                <button class="status-toggle-btn" data-status="failure">âœ— Failures</button>
                            </div>
                        </div>
                        
                        <!-- Text Search -->
                        <div class="log-filter-group log-search-group">
                            <label class="filter-label" for="log-search">Search:</label>
                            <input type="text" id="log-search" class="filter-input" placeholder="Search commands, IDs, errors...">
                        </div>
                        
                        <!-- Date Range Picker -->
                        <div class="log-filter-group">
                            <label class="filter-label">Time:</label>
                            <div class="date-presets" id="date-filter-presets">
                                <button class="date-preset-btn" data-range="hour">1h</button>
                                <button class="date-preset-btn" data-range="day">24h</button>
                                <button class="date-preset-btn" data-range="week">7d</button>
                                <button class="date-preset-btn" data-range="month">30d</button>
                                <button class="date-preset-btn active" data-range="all">All</button>
                                <button class="date-preset-btn" data-range="custom">Custom</button>
                            </div>
                            <div class="custom-date-range" id="custom-date-range">
                                <label>From:</label>
                                <input type="date" id="date-from" />
                                <label>To:</label>
                                <input type="date" id="date-to" />
                            </div>
                        </div>
                    </div>
                    
                    <!-- Filter Summary -->
                    <div class="log-filter-summary" id="log-filter-summary"></div>
                </div>
                
                <!-- Activity Timeline Heatmap -->
                <div class="activity-timeline" id="activity-timeline">
                    <div class="activity-timeline-header">
                        <span class="activity-timeline-title">Activity Timeline</span>
                        <span class="activity-timeline-range" id="timeline-range"></span>
                    </div>
                    <svg class="activity-timeline-svg" id="timeline-svg" preserveAspectRatio="none"></svg>
                    <div class="activity-timeline-labels" id="timeline-labels"></div>
                    <div class="activity-timeline-legend">
                        <div class="activity-timeline-legend-item">
                            <div class="legend-swatch low"></div>
                            <span>Few</span>
                        </div>
                        <div class="activity-timeline-legend-item">
                            <div class="legend-swatch high"></div>
                            <span>Many</span>
                        </div>
                        <div class="activity-timeline-legend-item">
                            <div class="legend-swatch failures"></div>
                            <span>Failures</span>
                        </div>
                    </div>
                </div>
                
                <!-- Command Frequency Chart -->
                <div class="command-frequency-chart frequency-chart-colors" id="command-frequency-chart">
                    <div class="command-frequency-header" onclick="toggleFrequencyChart()">
                        <div class="command-frequency-title">
                            <span>ðŸ“Š</span>
                            <span>Command Frequency</span>
                        </div>
                        <span class="command-frequency-toggle">â–¼</span>
                    </div>
                    <div class="command-frequency-content">
                        <div class="frequency-bars" id="frequency-bars"></div>
                        <div class="frequency-pie" id="frequency-pie"></div>
                    </div>
                </div>
                
                <div class="log-list" id="log-list"></div>
            </div>
        </main>

        <div class="connection-status">
            <div class="status-dot status-disconnected" id="status-dot"></div>
            <span id="status-text">Connecting...</span>
        </div>

        <!-- Agent Termination Confirmation Modal -->
        <div id="terminate-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <h3>Terminate Agent?</h3>
                <div class="modal-body">
                    <p>Are you sure you want to terminate this agent?</p>
                    <div class="modal-agent-info" id="modal-agent-info"></div>
                </div>
                <div class="modal-actions">
                    <button class="modal-btn modal-btn-cancel" onclick="closeTerminateModal()">Cancel</button>
                    <button class="modal-btn modal-btn-danger" id="confirm-terminate-btn">Terminate</button>
                </div>
            </div>
        </div>

        <!-- Agent Detail Modal (shown on graph node double-click) -->
        <div id="agent-detail-modal" class="modal-overlay agent-detail-modal" style="display: none;">
            <div class="modal-content">
                <h3>ðŸ¤– Agent Details</h3>
                <div class="modal-body">
                    <div class="agent-detail-header">
                        <div class="agent-detail-icon">ðŸ¤–</div>
                        <div class="agent-detail-title">
                            <div class="agent-name" id="agent-modal-name"></div>
                            <div class="agent-pid" id="agent-modal-pid"></div>
                        </div>
                        <span class="badge" id="agent-modal-status-badge"></span>
                    </div>

                    <div class="agent-detail-section" id="agent-modal-purpose-section">
                        <div class="agent-detail-section-title">Purpose</div>
                        <div class="agent-detail-purpose" id="agent-modal-purpose"></div>
                    </div>

                    <div class="agent-detail-section">
                        <div class="agent-detail-section-title">Statistics</div>
                        <div class="agent-detail-grid">
                            <div class="agent-detail-stat">
                                <div class="agent-detail-stat-value" id="agent-modal-command-count">0</div>
                                <div class="agent-detail-stat-label">Commands</div>
                            </div>
                            <div class="agent-detail-stat">
                                <div class="agent-detail-stat-value" id="agent-modal-task-count">0</div>
                                <div class="agent-detail-stat-label">Tasks</div>
                            </div>
                        </div>
                    </div>

                    <div class="agent-detail-section" id="agent-modal-tasks-section" style="display: none;">
                        <div class="agent-detail-section-title">Working On</div>
                        <div class="agent-detail-tasks" id="agent-modal-tasks"></div>
                    </div>

                    <div class="agent-detail-section">
                        <div class="agent-detail-section-title">Timeline</div>
                        <div class="agent-detail-timestamp" id="agent-modal-started"></div>
                        <div class="agent-detail-timestamp" id="agent-modal-last-activity"></div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="modal-btn modal-btn-cancel" onclick="closeAgentDetailModal()">Close</button>
                    <button class="modal-btn modal-btn-danger" id="agent-modal-terminate-btn">Terminate</button>
                </div>
            </div>
        </div>

        <!-- Doc Viewer Modal -->
        <div id="doc-viewer-modal" class="doc-viewer-modal">
            <div class="doc-viewer-container">
                <div class="doc-viewer-header">
                    <div class="doc-viewer-header-content">
                        <div class="doc-viewer-title">
                            <span id="doc-viewer-title-text"></span>
                            <span id="doc-viewer-dirty-indicator" class="summary-dirty-indicator" title="Summary needs update" style="display: none;">âš ï¸</span>
                        </div>
                        <div class="doc-viewer-meta" id="doc-viewer-meta"></div>
                    </div>
                    <button class="doc-viewer-close" onclick="closeDocViewer()" title="Close">&times;</button>
                </div>
                <div class="doc-viewer-body-wrapper">
                    <div class="doc-viewer-main">
                        <div class="doc-viewer-summary" id="doc-viewer-summary">
                            <div class="doc-viewer-summary-header">
                                <span>ðŸ“‹</span> Summary
                            </div>
                            <div class="doc-viewer-summary-content" id="doc-viewer-summary-content"></div>
                        </div>
                        <div class="doc-viewer-content" id="doc-viewer-content"></div>
                    </div>
                    <div class="doc-viewer-history-sidebar" id="doc-viewer-history-sidebar">
                        <div class="doc-viewer-history-header">
                            <span>ðŸ“œ</span> Versions
                        </div>
                        <div class="doc-viewer-history-list" id="doc-viewer-history-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Toast Notification System
        const TOAST_ICONS = {
            success: 'âœ“',
            error: 'âœ•',
            warning: 'âš ',
            info: 'â„¹'
        };

        // Track recent toasts to prevent duplicates
        const recentToasts = new Map();  // message -> timestamp
        const TOAST_DEDUP_MS = 2000;  // Ignore duplicate messages within 2 seconds

        /**
         * Show a toast notification
         * @param {string} message - The message to display
         * @param {string} type - Toast type: 'success', 'error', 'warning', 'info' (default: 'info')
         * @param {number} duration - Auto-dismiss duration in ms (default: 5000, use 0 for no auto-dismiss)
         * @returns {HTMLElement|null} The toast element (can be used to dismiss manually), or null if deduplicated
         */
        function showToast(message, type = 'info', duration = 5000) {
            // Deduplicate: skip if same message shown recently
            const now = Date.now();
            const lastShown = recentToasts.get(message);
            if (lastShown && (now - lastShown) < TOAST_DEDUP_MS) {
                return null;  // Skip duplicate
            }
            recentToasts.set(message, now);
            
            // Clean up old entries periodically (keep map from growing)
            if (recentToasts.size > 50) {
                for (const [msg, timestamp] of recentToasts) {
                    if (now - timestamp > TOAST_DEDUP_MS * 2) {
                        recentToasts.delete(msg);
                    }
                }
            }

            const container = document.getElementById('toast-container');
            
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            
            const icon = document.createElement('span');
            icon.className = 'toast-icon';
            icon.textContent = TOAST_ICONS[type] || TOAST_ICONS.info;
            
            const msg = document.createElement('span');
            msg.className = 'toast-message';
            msg.textContent = message;
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'toast-close';
            closeBtn.innerHTML = '&times;';
            closeBtn.title = 'Dismiss';
            closeBtn.onclick = () => dismissToast(toast);
            
            toast.appendChild(icon);
            toast.appendChild(msg);
            toast.appendChild(closeBtn);
            
            container.appendChild(toast);
            
            // Auto-dismiss if duration > 0
            if (duration > 0) {
                toast._timeout = setTimeout(() => dismissToast(toast), duration);
            }
            
            return toast;
        }

        /**
         * Dismiss a toast notification
         * @param {HTMLElement} toast - The toast element to dismiss
         */
        function dismissToast(toast) {
            if (!toast || !toast.parentNode) return;
            
            // Clear any pending auto-dismiss
            if (toast._timeout) {
                clearTimeout(toast._timeout);
            }
            
            // Add exit animation
            toast.classList.add('toast-exit');
            
            // Remove after animation completes
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }

        // Edge type definitions with display names and default visibility
        const EDGE_TYPES = {
            depends_on: { name: 'Depends', category: 'blocking', defaultVisible: true },
            blocks: { name: 'Blocks', category: 'blocking', defaultVisible: true },
            related_to: { name: 'Related', category: 'informational', defaultVisible: false },
            duplicates: { name: 'Duplicates', category: 'informational', defaultVisible: false },
            fixes: { name: 'Fixes', category: 'fixes', defaultVisible: false },
            caused_by: { name: 'Caused By', category: 'fixes', defaultVisible: false },
            supersedes: { name: 'Supersedes', category: 'informational', defaultVisible: false },
            pinned: { name: 'Pinned', category: 'pinned', defaultVisible: true },
            parent_of: { name: 'Parent', category: 'hierarchy', defaultVisible: false },
            child_of: { name: 'Child', category: 'hierarchy', defaultVisible: false },
            tests: { name: 'Tests', category: 'fixes', defaultVisible: false },
            queued: { name: 'Queued', category: 'queued', defaultVisible: true },
            working_on: { name: 'Working On', category: 'agent', defaultVisible: true },
            worked_on: { name: 'Worked On', category: 'agent', defaultVisible: false }
        };

        // Node types for visibility filtering
        const NODE_TYPES = {
            task: { name: 'Tasks', emoji: 'ðŸ“‹', defaultVisible: true },
            bug: { name: 'Bugs', emoji: 'ðŸ›', defaultVisible: true },
            idea: { name: 'Ideas', emoji: 'ðŸ’­', defaultVisible: true },
            milestone: { name: 'Milestones', emoji: 'ðŸ', defaultVisible: true },
            queue: { name: 'Queue', emoji: 'â¬¡', defaultVisible: true },
            agent: { name: 'Agents', emoji: 'ðŸ¤–', defaultVisible: true },
            doc: { name: 'Docs', emoji: 'ðŸ“„', defaultVisible: true }
        };

        // Load node type filter state from localStorage
        function loadNodeTypeFilters() {
            const saved = localStorage.getItem('binnacle_node_type_filters');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    // Fall back to defaults
                }
            }
            // Default: all node types visible
            const defaults = {};
            for (const [type, info] of Object.entries(NODE_TYPES)) {
                defaults[type] = info.defaultVisible;
            }
            return defaults;
        }

        // Save node type filter state to localStorage
        function saveNodeTypeFilters(filters) {
            localStorage.setItem('binnacle_node_type_filters', JSON.stringify(filters));
        }

        // Load edge filter state from localStorage
        function loadEdgeFilters() {
            const saved = localStorage.getItem('binnacle_edge_filters');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    // Fall back to defaults
                }
            }
            // Default: only blocking edges visible
            const defaults = {};
            for (const [type, info] of Object.entries(EDGE_TYPES)) {
                defaults[type] = info.defaultVisible;
            }
            return defaults;
        }

        // Save edge filter state to localStorage
        function saveEdgeFilters(filters) {
            localStorage.setItem('binnacle_edge_filters', JSON.stringify(filters));
        }

        // Load edge spring (physics) state from localStorage
        function loadEdgeSpringFilters() {
            const saved = localStorage.getItem('binnacle_edge_spring_filters');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    // Fall back to defaults
                }
            }
            // Default: all edge types have springiness enabled
            const defaults = {};
            for (const type of Object.keys(EDGE_TYPES)) {
                defaults[type] = true;
            }
            return defaults;
        }

        // Save edge spring (physics) state to localStorage
        function saveEdgeSpringFilters(filters) {
            localStorage.setItem('binnacle_edge_spring_filters', JSON.stringify(filters));
        }

        // State management
        const state = {
            currentView: 'graph',
            tasks: [],
            ready: [],
            ideas: [],
            tests: [],
            docs: [],
            log: [],
            logPagination: {
                total: 0,          // Total number of log entries on server
                offset: 0,         // Current offset (how many entries we've loaded)
                limit: 100,        // Entries per page
                loading: false,    // Whether we're currently loading more
                hasMore: true      // Whether there are more entries to load
            },
            logFilters: {
                commandCategories: [],   // empty = all, or array of: tasks, tests, links, bugs, ideas, docs, system, queue
                userFilter: 'all',       // all, humans, agents, or specific user
                statusFilter: 'all',     // all, success, failure
                searchText: '',          // text search
                dateRange: 'all',        // hour, day, week, month, all, custom
                customDateFrom: '',      // ISO date string for custom range start
                customDateTo: '',        // ISO date string for custom range end
                viewMode: 'flat'         // flat or grouped (session grouping)
            },
            logKeyboard: {
                focusedIndex: -1,        // -1 means no entry is focused
                enabled: false           // Becomes true when user navigates with keyboard
            },
            agents: [],
            edges: [], // Raw edges from API
            edgeFilters: loadEdgeFilters(), // Which edge types are visible
            edgeSpringFilters: loadEdgeSpringFilters(), // Which edge types have spring physics
            nodeTypeFilters: loadNodeTypeFilters(), // Which node types are visible
            ws: null,
            graph: {
                nodes: [],
                edges: [],
                hoveredNode: null,
                hoveredEdge: null,
                mouseX: 0,
                mouseY: 0,
                physics: {
                    damping: 0.92,
                    gravityStrength: 0.05,
                    gravityCenter: { x: 0, y: 0 },
                    repulsionStrength: 2500,
                    springStrength: 0.08,
                    springRestingLength: 200,
                    edgeAttractionEnabled: true,
                    maxVelocity: 3
                },
                // Viewport transformation
                viewport: {
                    panX: 0,
                    panY: 0,
                    zoom: 1.0,
                    minZoom: 0.1,
                    maxZoom: 3.0
                },
                // Drag state
                draggedNode: null,
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                dragNodeStartX: 0,
                dragNodeStartY: 0,
                dragStartTime: 0,
                dragLastX: 0,
                dragLastY: 0,
                // Canvas pan state
                isPanning: false,
                panStartX: 0,
                panStartY: 0,
                panStartOffsetX: 0,
                panStartOffsetY: 0,
                // Selection state
                selectedNode: null,
                selectedEdge: null,
                // Temporary highlight state (for entity link navigation)
                tempHighlightNode: null,
                tempHighlightStart: null,
                tempHighlightDuration: 1500,
                // Camera pan animation state
                followAnimation: null,  // { startPanX, startPanY, targetPanX, targetPanY, startZoom, targetZoom, startTime, duration }
                // Auto-follow state
                autoFollow: true,  // Whether auto-follow is enabled
                followTargetId: 'auto',  // Target to follow: 'auto', 'active-task', 'queue', or agent ID (e.g., 'bna-xxxx')
                followingNodeId: null,  // ID of node currently being followed (for continuous tracking)
                lastFocusSwitchTime: 0,  // Timestamp of last focus switch (for configurable delay)
                // Auto-follow config (loaded from localStorage)
                autoFollowConfig: null,  // Will be loaded: { nodeTypes: { task: true, ... }, focusDelaySeconds: 10 }
                // Pan-through state for multiple new nodes
                panThroughQueue: [],     // Array of node IDs to visit
                panThroughState: 'idle', // 'idle', 'panning', 'paused'
                panThroughPauseDuration: 1200,  // ms to pause on each node
                panThroughPauseStart: null,     // Timestamp when pause started
                focusEndTime: null,             // When focus period ends (after pan-through), null = not focusing
                userPausedFollow: false,        // True when user manually panned, prevents auto re-centering
                // Stat highlight filter state (null = no filter active)
                highlightFilter: null,  // e.g., 'bugs', 'blocked', 'ready', 'ideas', 'milestones'
                // Hide completed nodes filter
                hideCompleted: true,  // When true, hide completed nodes except those in active chains
                // Chain length filter (1 = no filter, 2+ = only show nodes in chains of at least that length)
                minChainLength: 1,
                // Search filter
                searchQuery: '',
                // Cached visibility for hit-testing (null until first frame)
                visibleNodes: null,
                visibleNodeIds: null,
                // Animation time for continuous effects (ms)
                animationTime: 0,
                // Animation stability tracking (for performance optimization)
                isAnimating: false,
                stableFrameCount: 0,
                STABLE_THRESHOLD: 0.01,  // Velocity threshold for "stable" detection
                STABLE_FRAMES_REQUIRED: 30  // Number of consecutive stable frames before stopping
            }
        };

        // View search state
        const viewSearch = {
            nodes: ''
        };

        // Sidebar search state
        let sidebarSearchQuery = '';

        // Include closed state (for searching through completed items)
        const includeClosed = {
            nodes: false
        };

        // Node type filter for consolidated nodes view
        let nodesTypeFilter = '';
        
        // Node tag filter for consolidated nodes view
        let nodesTagFilter = '';

        // WebSocket connection
        let pendingReload = null;
        const RELOAD_DEBOUNCE_MS = 100;  // Client-side debounce as backup
        let wasConnected = false;  // Track connection state for toast notifications
        let disconnectToast = null;  // Track active disconnect toast
        let initialLoadComplete = false;  // Track if we've done the initial data load
        let initialLoadInProgress = false;  // Prevent reload processing during initial load
        const shownClosedToasts = new Set();  // Track task IDs that have shown "closed" notification

        function connectWebSocket() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            state.ws = new WebSocket(`${protocol}//${location.host}/ws`);

            state.ws.onopen = async () => {
                updateConnectionStatus(true);
                // Show reconnection toast only if we were previously connected
                if (wasConnected) {
                    // Dismiss any active disconnect toast
                    if (disconnectToast) {
                        dismissToast(disconnectToast);
                        disconnectToast = null;
                    }
                    showToast('Connection restored', 'success', 3000);
                }
                const isInitialLoad = !wasConnected;
                wasConnected = true;
                // Mark initial load in progress to prevent reload messages from racing
                initialLoadInProgress = true;
                await loadData();
                initialLoadInProgress = false;
                // On initial page load, snap to active task if auto-follow is enabled
                if (isInitialLoad && state.graph.autoFollow) {
                    snapToActiveTask();
                }
            };

            state.ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.type === 'reload') {
                    // Skip reload processing if initial load is still in progress
                    // This prevents race conditions where stale state is compared
                    if (initialLoadInProgress) return;
                    // Debounce rapid reload messages
                    if (pendingReload) clearTimeout(pendingReload);
                    pendingReload = setTimeout(async () => {
                        pendingReload = null;
                        // Save previous statuses for auto-follow detection
                        const prevStatuses = {};
                        const prevTitles = {};
                        if (state.tasks) {
                            state.tasks.forEach(t => {
                                prevStatuses[t.id] = t.status;
                                prevTitles[t.id] = t.title;
                            });
                        }
                        
                        await loadData();
                        
                        // When auto-follow is enabled and we have a selected target,
                        // re-center on the target node if it has moved
                        // Skip if user has manually panned (userPausedFollow)
                        if (state.graph.autoFollow && state.graph.followTargetId && !state.graph.userPausedFollow) {
                            // Check if we're in a focus period (after pan-through)
                            // During focus period, don't resume agent following
                            const now = Date.now();
                            if (state.graph.focusEndTime && now < state.graph.focusEndTime) {
                                // Still in focus period - skip agent follow logic
                                // (let user view the new nodes without interruption)
                            } else {
                                // Focus period expired or not set - clear it and resume normal behavior
                                if (state.graph.focusEndTime) {
                                    state.graph.focusEndTime = null;
                                }
                                
                                // Find the target node based on followTargetId
                                let targetNode = null;
                                if (state.graph.followTargetId === 'auto') {
                                    // Auto mode: follow the agent with the most recent activity
                                    // Use configurable delay (default 10 seconds)
                                    const delaySeconds = state.graph.autoFollowConfig?.focusDelaySeconds || 10;
                                    const FOCUS_SWITCH_DELAY_MS = delaySeconds * 1000;
                                    const mostRecentAgent = findMostRecentlyActiveAgent();
                                    if (mostRecentAgent) {
                                        const timeSinceLastSwitch = now - state.graph.lastFocusSwitchTime;
                                        
                                        if (state.graph.followingNodeId !== mostRecentAgent.id) {
                                            // Different agent is most active - check if we can switch
                                            if (timeSinceLastSwitch >= FOCUS_SWITCH_DELAY_MS || !state.graph.followingNodeId) {
                                                // Enough time has passed, or no current focus - switch
                                                targetNode = mostRecentAgent;
                                                state.graph.lastFocusSwitchTime = now;
                                            } else {
                                                // Keep following current agent (delay not met)
                                                targetNode = state.tasks?.find(t => t.id === state.graph.followingNodeId && t.type === 'agent');
                                            }
                                        } else {
                                            // Same agent - keep following
                                            targetNode = mostRecentAgent;
                                        }
                                    }
                                } else if (state.graph.followTargetId === 'active-task') {
                                    targetNode = state.tasks?.find(t => 
                                        (t.type === 'task' || t.type === 'bug') && t.status === 'in_progress'
                                    );
                                } else if (state.graph.followTargetId === 'queue') {
                                    targetNode = state.tasks?.find(t => t.type === 'queue');
                                } else {
                                    targetNode = state.tasks?.find(t => t.id === state.graph.followTargetId && t.type === 'agent');
                                }
                                
                                if (targetNode && state.graph.followingNodeId !== targetNode.id) {
                                    // Target exists but we weren't following it - start following
                                    state.graph.followingNodeId = targetNode.id;
                                    panToNode(targetNode.id, true);
                                } else if (targetNode) {
                                    // Target is being followed - re-pan to keep it centered
                                    panToNode(targetNode.id, false);  // Don't zoom, just pan
                                }
                            }
                        }
                        
                        // Task completion detection: show toast when task is closed (1 minute timeout)
                        // Track shown notifications by task ID to prevent duplicates across reloads
                        if (state.tasks) {
                            for (const task of state.tasks) {
                                const prevStatus = prevStatuses[task.id];
                                if (task.status === 'done' && prevStatus && prevStatus !== 'done') {
                                    // Task just transitioned to done - show toast only if not shown before
                                    if (!shownClosedToasts.has(task.id)) {
                                        shownClosedToasts.add(task.id);
                                        showToast(`âœ… Task closed: ${task.id} - ${task.title}`, 'success', 60000);
                                    }
                                } else if (task.status !== 'done' && prevStatus === 'done') {
                                    // Task was reopened - allow showing closed toast again if it closes
                                    shownClosedToasts.delete(task.id);
                                }
                            }
                        }
                        
                        // New node detection: show auto-dismissing toast for new additions
                        // Only show if auto-follow is enabled and we've done the initial load
                        if (state.tasks && initialLoadComplete && state.graph.autoFollow) {
                            const config = state.graph.autoFollowConfig || { nodeTypes: { task: true, bug: true } };
                            const newNodeIds = [];  // Collect new node IDs for pan-through
                            for (const task of state.tasks) {
                                // Check if this is a new item (not in previous state)
                                if (prevStatuses[task.id] === undefined) {
                                    // Filter by node type based on config toggles
                                    const nodeType = task.type;
                                    if (config.nodeTypes && config.nodeTypes[nodeType]) {
                                        const icons = {
                                            bug: 'ðŸ›',
                                            task: 'ðŸ“‹',
                                            idea: 'ðŸ’¡',
                                            test: 'ðŸ§ª',
                                            doc: 'ðŸ“„'
                                        };
                                        const icon = icons[nodeType] || 'ðŸ“Œ';
                                        const typeName = nodeType.charAt(0).toUpperCase() + nodeType.slice(1);
                                        const toastType = nodeType === 'bug' ? 'warning' : 'info';
                                        showToast(`${icon} ${typeName} added: ${task.id} - ${task.title || task.name || ''}`, toastType, 5000);
                                        newNodeIds.push(task.id);
                                    }
                                }
                            }
                            // Queue pan-through for multiple new nodes
                            if (newNodeIds.length > 1) {
                                // Clear user pause - new nodes take priority
                                state.graph.userPausedFollow = false;
                                // Small delay to let nodes settle in their positions
                                setTimeout(() => {
                                    queuePanThrough(newNodeIds);
                                }, 300);
                            } else if (newNodeIds.length === 1) {
                                // Clear user pause - new node takes priority
                                state.graph.userPausedFollow = false;
                                // Single new node: just pan to it directly
                                setTimeout(() => {
                                    panToNode(newNodeIds[0], true);
                                }, 300);
                            }
                        }
                        initialLoadComplete = true;
                    }, RELOAD_DEBOUNCE_MS);
                }
            };

            state.ws.onclose = () => {
                updateConnectionStatus(false);
                // Show disconnect toast if we were connected (and don't have one already)
                if (wasConnected && !disconnectToast) {
                    disconnectToast = showToast('Connection lost, reconnecting...', 'warning', 0);
                }
                setTimeout(connectWebSocket, 2000);
            };

            state.ws.onerror = () => {
                updateConnectionStatus(false);
            };
        }

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('status-dot');
            const text = document.getElementById('status-text');
            dot.className = `status-dot status-${connected ? 'connected' : 'disconnected'}`;
            text.textContent = connected ? 'Connected' : 'Disconnected';
        }

        // Data loading
        async function loadData() {
            // Load all data in parallel (log uses pagination)
            const logLimit = state.logPagination.limit;
            const [configData, tasksData, bugsData, ideasData, readyData, testsData, docsData, logData, edgesData, agentsData, queueData] = await Promise.all([
                fetch('/api/config').then(r => r.json()),
                fetch('/api/tasks').then(r => r.json()),
                fetch('/api/bugs').then(r => r.json()),
                fetch('/api/ideas').then(r => r.json()),
                fetch('/api/ready').then(r => r.json()),
                fetch('/api/tests').then(r => r.json()),
                fetch('/api/docs').then(r => r.json()),
                fetch(`/api/log?limit=${logLimit}&offset=0`).then(r => r.json()),
                fetch('/api/edges').then(r => r.json()),
                fetch('/api/agents').then(r => r.json()),
                fetch('/api/queue').then(r => r.json())
            ]);
            
            // Update the document title with project name
            if (configData.project_name) {
                document.title = `${configData.project_name} - Binnacle`;
            }
            
            // Merge tasks, bugs, and ideas into unified tasks array for graph
            // Normalize bugs and ideas to have task-like fields for consistent rendering
            const normalizedBugs = (bugsData.bugs || []).map(bug => ({
                ...bug,
                type: 'bug',
                priority: bug.priority ?? 2,  // Default P2 if not set
                short_name: bug.short_name || null
            }));
            const normalizedIdeas = (ideasData.ideas || []).map(idea => ({
                ...idea,
                type: 'idea',
                priority: 4,  // Ideas are low priority by default
                short_name: idea.short_name || null,
                depends_on: idea.depends_on || []
            }));
            // Normalize queue to have node-like fields for graph rendering
            const normalizedQueue = queueData.queue ? [{
                ...queueData.queue,
                type: 'queue',
                status: 'active',  // Queues don't have status, use 'active' for rendering
                priority: 0,
                short_name: queueData.queue.title || null,
                depends_on: []
            }] : [];
            
            // Normalize agents to have node-like fields for graph rendering
            // Only show worker agents in the graph (filter out planner and buddy agents)
            const workerAgents = (agentsData.agents || []).filter(agent => agent.agent_type === 'worker');
            const normalizedAgents = workerAgents.map(agent => ({
                // Use proper binnacle ID (bna-xxxx) if available, fall back to PID-based ID for backwards compat
                id: agent.id || `agent-${agent.pid}`,
                title: agent.name,
                short_name: agent.purpose || agent.name,
                type: 'agent',
                status: agent.status,  // active, idle, stale
                priority: 0,  // Agents are high priority for visibility
                depends_on: [],
                // Keep original agent data for reference
                _agent: agent
            }));
            
            // Normalize docs to have node-like fields for graph rendering
            const normalizedDocs = (docsData.docs || []).map(doc => ({
                ...doc,
                type: 'doc',
                status: 'active',  // Docs don't have status, use 'active' for rendering
                priority: 3,  // Lower priority for layout
                short_name: doc.short_name || doc.title,
                depends_on: doc.supersedes ? [doc.supersedes] : []  // Version chain as dependency
            }));
            
            state.tasks = [...(tasksData.tasks || []), ...normalizedBugs, ...normalizedIdeas, ...normalizedQueue, ...normalizedAgents, ...normalizedDocs];
            state.ready = readyData.tasks || [];
            state.ideas = ideasData.ideas || [];
            state.tests = testsData.tests || [];
            state.docs = docsData.docs || [];
            state.log = logData.log || [];
            
            // Update log pagination state
            state.logPagination.total = logData.total || state.log.length;
            state.logPagination.offset = state.log.length;
            state.logPagination.hasMore = state.log.length < state.logPagination.total;
            
            // Update user filter dropdown with users from log
            updateUserFilterOptions();
            
            // Build agent-to-task edges ("working_on" edge type)
            // Only include edges from worker agents (same filter as node rendering)
            // Note: These edges should also exist in the main edges data now that working_on is a proper edge type
            // but we still build them here for backwards compatibility with agents without proper binnacle IDs
            const agentEdges = workerAgents
                .filter(agent => !agent.id)  // Only for agents without binnacle IDs
                .flatMap(agent => 
                    (agent.tasks || []).map(taskId => ({
                        source: `agent-${agent.pid}`,
                        target: taskId,
                        edge_type: 'working_on'
                    }))
                );
            
            // Build supersedes edges from docs (version chain)
            const docEdges = normalizedDocs
                .filter(doc => doc.supersedes)
                .map(doc => ({
                    source: doc.id,
                    target: doc.supersedes,
                    edge_type: 'supersedes'
                }));
            
            state.edges = [...(edgesData.edges || []), ...agentEdges, ...docEdges];
            state.agents = agentsData.agents || [];
            
            updateFollowSelector();
            updateStatsOverlay();
            updateActiveTaskPane();
            updateAvailableWorkPane();
            updateRecentlyCompletedPane();
            renderCurrentView();
        }

        function updateStatsOverlay() {
            // Stats are no longer displayed in filter dropdown - node type filters handle visibility
            // Just trigger update of active task pane and recently completed
        }
        
        function updateActiveTaskPane() {
            const pane = document.getElementById('active-task-pane');
            const idEl = document.getElementById('active-task-id');
            const titleEl = document.getElementById('active-task-title');
            const metaEl = document.getElementById('active-task-meta');
            
            // Find first in_progress task
            const activeTask = state.tasks.find(t => t.status === 'in_progress');
            
            if (activeTask) {
                pane.classList.remove('empty');
                idEl.textContent = activeTask.id;
                titleEl.textContent = activeTask.title || 'Untitled task';
                titleEl.title = activeTask.title || '';  // Full title on hover
                
                // Build meta badges
                let metaHtml = '';
                if (activeTask.priority !== undefined) {
                    metaHtml += `<span class="badge badge-priority-${activeTask.priority}">P${activeTask.priority}</span>`;
                }
                if (activeTask.tags && activeTask.tags.length > 0) {
                    activeTask.tags.slice(0, 2).forEach(tag => {
                        metaHtml += `<span class="badge badge-tag">${tag}</span>`;
                    });
                }
                metaEl.innerHTML = metaHtml;
            } else {
                pane.classList.add('empty');
                idEl.textContent = 'No active task';
                titleEl.textContent = '';
                titleEl.title = '';
                metaEl.innerHTML = '';
            }
        }
        
        /**
         * Create an emoji count badge element.
         * @param {string} emoji - The emoji to display
         * @param {number} count - The count to display
         * @param {string} type - The type for styling ('task', 'bug', 'idea')
         * @param {string} label - Accessible label for the badge
         * @returns {HTMLElement} The badge element
         */
        function createEmojiCountBadge(emoji, count, type, label) {
            const badge = document.createElement('span');
            badge.className = `emoji-count-badge type-${type}`;
            badge.title = label;
            badge.innerHTML = `<span class="emoji">${emoji}</span><span class="count">${count}</span>`;
            return badge;
        }

        /**
         * Update the available work counter in the header.
         * Shows total count of claimable items: ready tasks + open bugs + open ideas.
         */
        function updateAvailableWorkPane() {
            const pane = document.getElementById('available-work-pane');
            const countEl = document.getElementById('available-work-count');
            const breakdownEl = document.getElementById('available-work-breakdown');
            
            // Count ready tasks (pending tasks with no blockers, excluding bugs and ideas)
            const readyTasks = (state.ready || []).filter(t => t.type !== 'bug' && t.type !== 'idea');
            const readyTaskCount = readyTasks.length;
            
            // Count open bugs (not done, not cancelled)
            const openBugs = (state.tasks || []).filter(t => 
                t.type === 'bug' && 
                t.status !== 'done' && 
                t.status !== 'cancelled'
            );
            const openBugCount = openBugs.length;
            
            // Count open ideas (seed or germinating)
            const openIdeas = (state.ideas || []).filter(idea => 
                idea.status === 'seed' || idea.status === 'germinating'
            );
            const openIdeaCount = openIdeas.length;
            
            const totalCount = readyTaskCount + openBugCount + openIdeaCount;
            
            countEl.textContent = totalCount;
            
            // Update styling based on whether there's work
            pane.classList.remove('has-work', 'no-work');
            pane.classList.add(totalCount > 0 ? 'has-work' : 'no-work');
            
            // Show breakdown using emoji badges
            breakdownEl.innerHTML = '';
            if (readyTaskCount > 0) {
                breakdownEl.appendChild(createEmojiCountBadge('ðŸ“‹', readyTaskCount, 'task', `${readyTaskCount} ready task${readyTaskCount !== 1 ? 's' : ''}`));
            }
            if (openBugCount > 0) {
                breakdownEl.appendChild(createEmojiCountBadge('ðŸ›', openBugCount, 'bug', `${openBugCount} open bug${openBugCount !== 1 ? 's' : ''}`));
            }
            if (openIdeaCount > 0) {
                breakdownEl.appendChild(createEmojiCountBadge('ðŸ’­', openIdeaCount, 'idea', `${openIdeaCount} open idea${openIdeaCount !== 1 ? 's' : ''}`));
            }
        }
        
        /**
         * Update the recently completed pane in the header.
         * Shows tasks/bugs/ideas completed within the configurable time window.
         */
        function updateRecentlyCompletedPane() {
            const pane = document.getElementById('recently-completed-pane');
            const list = document.getElementById('recently-completed-list');
            
            const now = Date.now();
            
            // Find all items that were closed recently (within the pane window)
            const recentlyCompleted = state.tasks
                .filter(item => {
                    // Must have a closed_at timestamp
                    if (!item.closed_at) return false;
                    // Must be in a completed state
                    if (item.status !== 'done' && item.status !== 'cancelled' && item.status !== 'discarded') return false;
                    // Must be within the time window
                    const closedTime = new Date(item.closed_at).getTime();
                    const age = now - closedTime;
                    return age < RECENTLY_COMPLETED_PANE_WINDOW_MS;
                })
                // Sort by most recently closed first
                .sort((a, b) => new Date(b.closed_at).getTime() - new Date(a.closed_at).getTime())
                // Limit to 5 items to keep the pane compact
                .slice(0, 5);
            
            if (recentlyCompleted.length === 0) {
                pane.classList.add('empty');
                list.innerHTML = '<div class="recently-completed-empty">No recent completions</div>';
                return;
            }
            
            pane.classList.remove('empty');
            
            // Build the list HTML
            list.innerHTML = recentlyCompleted.map(item => {
                const closedTime = new Date(item.closed_at).getTime();
                const age = now - closedTime;
                const ago = formatTimeAgo(age);
                
                // Determine if the item is fading (older than half the window)
                const isFading = age > RECENTLY_COMPLETED_PANE_WINDOW_MS / 2;
                
                // Get display title (use short_name if available, fall back to title)
                const title = item.short_name || item.title || 'Untitled';
                
                // Get type icon
                let icon = '';
                if (item.type === 'bug') icon = 'ðŸ› ';
                else if (item.type === 'idea') icon = 'ðŸ’­ ';
                
                return `
                    <div class="recently-completed-item${isFading ? ' fading' : ''}" title="${title}">
                        <span class="recently-completed-id">${item.id}</span>
                        <span class="recently-completed-title">${icon}${escapeHtml(title)}</span>
                        <span class="recently-completed-ago">${ago}</span>
                    </div>
                `;
            }).join('');
        }
        
        /**
         * Format a time duration in ms to a human-readable "X ago" string.
         */
        function formatTimeAgo(ms) {
            const seconds = Math.floor(ms / 1000);
            if (seconds < 60) return `${seconds}s ago`;
            
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            
            const hours = Math.floor(minutes / 60);
            return `${hours}h ago`;
        }
        
        /**
         * Escape HTML special characters to prevent XSS.
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Initialize node type visibility filters (with eye icons like edge filters)
        function initializeNodeTypeFilters() {
            const container = document.getElementById('sidebar-node-filters');
            if (!container) return;
            
            // Create filter buttons for each node type
            container.innerHTML = '';
            
            // Add "All" toggle button first
            const allBtn = document.createElement('button');
            allBtn.className = 'node-filter-btn node-filter-all';
            allBtn.textContent = 'All';
            allBtn.title = 'Toggle all node types';
            
            const updateAllBtnState = () => {
                const allActive = Object.keys(NODE_TYPES).every(type => state.nodeTypeFilters[type]);
                allBtn.classList.toggle('active', allActive);
            };
            
            allBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const allActive = Object.keys(NODE_TYPES).every(type => state.nodeTypeFilters[type]);
                const newState = !allActive;
                
                for (const type of Object.keys(NODE_TYPES)) {
                    state.nodeTypeFilters[type] = newState;
                }
                
                // Update all visibility button states
                container.querySelectorAll('.node-visibility-btn').forEach(visBtn => {
                    const type = visBtn.dataset.nodeType;
                    if (type) {
                        visBtn.classList.toggle('active', newState);
                        visBtn.title = newState 
                            ? `Hide ${NODE_TYPES[type].name}`
                            : `Show ${NODE_TYPES[type].name}`;
                    }
                });
                updateAllBtnState();
                saveNodeTypeFilters(state.nodeTypeFilters);
                startAnimation();  // Restart animation to apply filter
            });
            
            container.appendChild(allBtn);
            
            for (const [type, info] of Object.entries(NODE_TYPES)) {
                // Create row container: [eye visibility] [emoji label]
                const row = document.createElement('div');
                row.className = 'node-filter-row';
                
                // Create eye visibility button
                const visBtn = document.createElement('button');
                visBtn.className = 'node-visibility-btn' + (state.nodeTypeFilters[type] ? ' active' : '');
                visBtn.dataset.nodeType = type;
                visBtn.innerHTML = 'ðŸ‘';
                visBtn.title = state.nodeTypeFilters[type] 
                    ? `Hide ${info.name}`
                    : `Show ${info.name}`;
                
                // Create label button
                const btn = document.createElement('button');
                btn.className = 'node-filter-btn' + (state.nodeTypeFilters[type] ? ' active' : '');
                btn.dataset.nodeType = type;
                btn.innerHTML = `${info.emoji} ${info.name}`;
                btn.title = `Toggle ${info.name} visibility`;
                
                // Eye button: toggle visibility
                visBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    state.nodeTypeFilters[type] = !state.nodeTypeFilters[type];
                    visBtn.classList.toggle('active', state.nodeTypeFilters[type]);
                    btn.classList.toggle('active', state.nodeTypeFilters[type]);
                    visBtn.title = state.nodeTypeFilters[type] 
                        ? `Hide ${info.name}`
                        : `Show ${info.name}`;
                    updateAllBtnState();
                    saveNodeTypeFilters(state.nodeTypeFilters);
                    startAnimation();
                });
                
                // Label button: also toggles visibility
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    state.nodeTypeFilters[type] = !state.nodeTypeFilters[type];
                    visBtn.classList.toggle('active', state.nodeTypeFilters[type]);
                    btn.classList.toggle('active', state.nodeTypeFilters[type]);
                    visBtn.title = state.nodeTypeFilters[type] 
                        ? `Hide ${info.name}`
                        : `Show ${info.name}`;
                    updateAllBtnState();
                    saveNodeTypeFilters(state.nodeTypeFilters);
                    startAnimation();
                });
                
                row.appendChild(visBtn);
                row.appendChild(btn);
                container.appendChild(row);
            }
            
            updateAllBtnState();
            
            // Reapply sidebar search filter if active
            if (sidebarSearchQuery) {
                filterNodesSection(sidebarSearchQuery);
            }
        }
        
        // Legacy function name for compatibility
        function initializeStatFilters() {
            initializeNodeTypeFilters();
        }
        
        // Toggle stat filter on/off (kept for highlight filter compatibility)
        function toggleStatFilter(filterName) {
            if (state.graph.highlightFilter === filterName) {
                // Clear filter if clicking same one
                state.graph.highlightFilter = null;
            } else {
                // Set new filter
                state.graph.highlightFilter = filterName;
            }
            updateStatFilterHighlights();
            startAnimation();  // Restart animation to apply highlight filter
        }
        
        // Update visual state of stat filter buttons
        function updateStatFilterHighlights() {
            // No longer needed - node type filters handle visibility directly
        }
        
        // Check if a node matches the current highlight filter (deprecated - kept for compatibility)
        function nodeMatchesFilter(node) {
            // With node type filters, all visible nodes match
            return true;
        }

        // View switching
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const view = btn.dataset.view;
                switchView(view);
            });
        });

        function switchView(view) {
            // Clear log keyboard focus when leaving log view
            if (state.currentView === 'log' && view !== 'log') {
                clearLogKeyboardFocus();
            }
            state.currentView = view;
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-view="${view}"]`).classList.add('active');
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(`${view}-view`).classList.add('active');
            renderCurrentView();
        }

        // Rendering
        function renderCurrentView() {
            switch (state.currentView) {
                case 'graph':
                    renderGraph();
                    renderAgentsSidebar();  // Update agents sidebar on graph view
                    break;
                case 'nodes':
                    syncTypeFilterDropdown();  // Sync type filter dropdown with JS variable
                    updateTagFilterDropdown();  // Update tag dropdown when switching to nodes view
                    renderNodes();
                    break;
                case 'agents':
                    renderAgents();
                    break;
                case 'log':
                    renderLog();
                    break;
            }
        }

        function renderGraph() {
            // This will be implemented with spring physics
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            if (state.tasks.length === 0) {
                renderEmptyState(ctx, 'No tasks yet');
                return;
            }

            // Build graph data structure
            buildGraphData();

            // Add mouse event listeners
            setupGraphMouseHandlers(canvas);

            // Initialize zoom display
            updateZoomDisplay();

            // Start animation loop
            startAnimation();
        }

        function setupGraphMouseHandlers(canvas) {
            // Remove old listeners to avoid duplicates
            const newCanvas = canvas.cloneNode(true);
            canvas.parentNode.replaceChild(newCanvas, canvas);
            const finalCanvas = document.getElementById('graph-canvas');

            finalCanvas.addEventListener('mousemove', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Handle canvas panning
                if (state.graph.isPanning) {
                    const dx = mouseX - state.graph.panStartX;
                    const dy = mouseY - state.graph.panStartY;
                    const zoom = state.graph.viewport.zoom;

                    // Update pan offset (inversely proportional to zoom)
                    state.graph.viewport.panX = state.graph.panStartOffsetX + dx / zoom;
                    state.graph.viewport.panY = state.graph.panStartOffsetY + dy / zoom;
                    return;
                }

                const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                if (state.graph.isDragging && state.graph.draggedNode) {
                    // Update dragged node position in world coordinates
                    const currentWorld = screenToWorld(mouseX, mouseY, finalCanvas);
                    const startWorld = screenToWorld(state.graph.dragStartX, state.graph.dragStartY, finalCanvas);
                    const dx = currentWorld.x - startWorld.x;
                    const dy = currentWorld.y - startWorld.y;
                    const node = state.graph.draggedNode;

                    node.x = state.graph.dragNodeStartX + dx;
                    node.y = state.graph.dragNodeStartY + dy;

                    // No boundary clamping for infinite canvas

                    // Track for momentum calculation
                    state.graph.dragLastX = mouseX;
                    state.graph.dragLastY = mouseY;

                    // Update tooltip position
                    updateTooltip(node, e.clientX, e.clientY);
                } else {
                    // Normal hover behavior - use world coordinates
                    state.graph.mouseX = worldPos.x;
                    state.graph.mouseY = worldPos.y;

                    // Find hovered node using world coordinates
                    const hoveredNode = state.graph.nodes.find(node => {
                        const dx = worldPos.x - node.x;
                        const dy = worldPos.y - node.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= node.radius;
                    });

                    if (hoveredNode !== state.graph.hoveredNode) {
                        state.graph.hoveredNode = hoveredNode;
                        updateTooltip(hoveredNode, e.clientX, e.clientY);
                        finalCanvas.classList.toggle('hovering', !!hoveredNode);
                        // Hide edge tooltip when showing node tooltip
                        if (hoveredNode) {
                            state.graph.hoveredEdge = null;
                            updateEdgeTooltip(null);
                        }
                    }

                    // Check for edge hover only if not hovering over a node
                    if (!hoveredNode) {
                        const hoveredEdge = findHoveredEdge(worldPos.x, worldPos.y);
                        if (hoveredEdge !== state.graph.hoveredEdge) {
                            state.graph.hoveredEdge = hoveredEdge;
                            updateEdgeTooltip(hoveredEdge, e.clientX, e.clientY);
                        } else if (hoveredEdge) {
                            // Update position while still hovering same edge
                            updateEdgeTooltip(hoveredEdge, e.clientX, e.clientY);
                        }
                    }
                }
            });

            finalCanvas.addEventListener('mouseleave', () => {
                // End any active drag
                if (state.graph.isDragging && state.graph.draggedNode) {
                    // Apply gentle stop (no momentum on mouse leave)
                    state.graph.draggedNode.vx = 0;
                    state.graph.draggedNode.vy = 0;
                    state.graph.isDragging = false;
                    state.graph.draggedNode = null;
                }

                // End any active pan
                if (state.graph.isPanning) {
                    state.graph.isPanning = false;
                    finalCanvas.style.cursor = 'default';
                }

                state.graph.hoveredNode = null;
                state.graph.hoveredEdge = null;
                updateTooltip(null);
                updateEdgeTooltip(null);
                finalCanvas.classList.remove('hovering', 'dragging');
            });

            finalCanvas.addEventListener('mousedown', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Middle mouse or Shift+Left mouse = always canvas pan
                // But not while auto-follow animation is active
                if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                    if (state.graph.followAnimation && state.graph.autoFollow) {
                        return; // Block panning during auto-follow
                    }
                    // User is manually panning - prevent auto re-centering
                    state.graph.followingNodeId = null;
                    state.graph.userPausedFollow = true;
                    cancelFocusPeriod();
                    cancelPanAnimation();  // Cancel any ongoing camera animation
                    state.graph.isPanning = true;
                    state.graph.panStartX = mouseX;
                    state.graph.panStartY = mouseY;
                    state.graph.panStartOffsetX = state.graph.viewport.panX;
                    state.graph.panStartOffsetY = state.graph.viewport.panY;
                    finalCanvas.style.cursor = 'grabbing';
                    startAnimation();  // Restart animation on interaction
                    e.preventDefault();
                    return;
                }

                // Left mouse button = node drag or canvas pan
                if (e.button === 0) {
                    const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                    // Find node under mouse using world coordinates (visible nodes only)
                    const nodesForHitTest = state.graph.visibleNodes ?? state.graph.nodes;
                    const node = nodesForHitTest.find(n => {
                        const dx = worldPos.x - n.x;
                        const dy = worldPos.y - n.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= n.radius;
                    });

                    if (node) {
                        // Node found - drag the node
                        state.graph.draggedNode = node;
                        state.graph.isDragging = true;
                        state.graph.dragStartX = mouseX;
                        state.graph.dragStartY = mouseY;
                        state.graph.dragNodeStartX = node.x;
                        state.graph.dragNodeStartY = node.y;
                        state.graph.dragStartTime = Date.now();
                        state.graph.dragLastX = mouseX;
                        state.graph.dragLastY = mouseY;
                        finalCanvas.classList.add('dragging');
                        startAnimation();  // Restart animation on drag
                        e.preventDefault();
                    } else {
                        // No node found - pan the canvas (but not during auto-follow animation)
                        if (state.graph.followAnimation && state.graph.autoFollow) {
                            return; // Block panning during auto-follow animation
                        }
                        // User is manually panning - stop following and prevent auto re-centering
                        state.graph.followingNodeId = null;
                        state.graph.userPausedFollow = true;  // Prevent auto re-centering until user re-enables
                        cancelFocusPeriod();  // Cancel any active focus period
                        cancelPanAnimation();  // Cancel any ongoing camera animation
                        state.graph.isPanning = true;
                        state.graph.panStartX = mouseX;
                        state.graph.panStartY = mouseY;
                        state.graph.panStartOffsetX = state.graph.viewport.panX;
                        state.graph.panStartOffsetY = state.graph.viewport.panY;
                        finalCanvas.style.cursor = 'grabbing';
                        startAnimation();  // Restart animation on pan
                        e.preventDefault();
                    }
                }
            });

            finalCanvas.addEventListener('mouseup', (e) => {
                // End canvas panning
                if (state.graph.isPanning) {
                    state.graph.isPanning = false;
                    finalCanvas.style.cursor = 'default';
                }

                // End node dragging
                if (state.graph.isDragging && state.graph.draggedNode) {
                    const rect = finalCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                    // Check if dropped on a queue node (drag-to-queue)
                    const draggedNode = state.graph.draggedNode;
                    const nodesForHitTest = state.graph.visibleNodes ?? state.graph.nodes;
                    const dropTarget = nodesForHitTest.find(n => {
                        if (n.id === draggedNode.id) return false;  // Skip self
                        const dx = worldPos.x - n.x;
                        const dy = worldPos.y - n.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= n.radius;
                    });

                    // If dropped on a queue and the dragged node is task/bug, add to queue
                    if (dropTarget && dropTarget.type === 'queue') {
                        const canBeQueued = ['task', 'bug'].includes(draggedNode.type);
                        const alreadyQueued = isNodeQueued(draggedNode.id);
                        
                        if (canBeQueued && !alreadyQueued) {
                            // Add queued link via API
                            fetch('/api/edges', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    source: draggedNode.id,
                                    target: dropTarget.id,
                                    edge_type: 'queued'
                                })
                            })
                            .then(r => r.json())
                            .then(result => {
                                if (result.success) {
                                    console.log(`Added ${draggedNode.id} to queue`);
                                    // The WebSocket will notify us of the change
                                } else {
                                    console.error('Failed to add to queue:', result.error);
                                }
                            })
                            .catch(err => console.error('Failed to add to queue:', err));
                        }
                    }

                    // Calculate momentum from recent drag motion in screen space
                    // Velocity is in world units per frame, so scale by zoom
                    const zoom = state.graph.viewport.zoom;
                    const velocityX = (mouseX - state.graph.dragLastX) * 2.5 / zoom;
                    const velocityY = (mouseY - state.graph.dragLastY) * 2.5 / zoom;

                    state.graph.draggedNode.vx = velocityX;
                    state.graph.draggedNode.vy = velocityY;

                    // Clear drag state
                    state.graph.isDragging = false;
                    state.graph.draggedNode = null;
                    finalCanvas.classList.remove('dragging');

                    // Update hover state (mouse may still be over a node)
                    const hoveredNode = nodesForHitTest.find(n => {
                        const dx = worldPos.x - n.x;
                        const dy = worldPos.y - n.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= n.radius;
                    });
                    state.graph.hoveredNode = hoveredNode;
                    updateTooltip(hoveredNode, e.clientX, e.clientY);
                    finalCanvas.classList.toggle('hovering', !!hoveredNode);
                }
            });

            finalCanvas.addEventListener('dblclick', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                // Find node under mouse using world coordinates (visible nodes only)
                const nodesForHitTest = state.graph.visibleNodes ?? state.graph.nodes;
                const node = nodesForHitTest.find(n => {
                    const dx = worldPos.x - n.x;
                    const dy = worldPos.y - n.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance <= n.radius;
                });

                if (node) {
                    // Check if it's an agent node - show detail modal
                    if (node.type === 'agent' && node._agent) {
                        showAgentDetailModal(node._agent);
                        e.preventDefault();
                        return;
                    }
                    
                    // Toggle selection for non-agent nodes
                    if (state.graph.selectedNode === node) {
                        state.graph.selectedNode = null;
                    } else {
                        state.graph.selectedNode = node;
                    }
                    // Hide edge info panel when selecting a node
                    state.graph.selectedEdge = null;
                    updateEdgeInfoPanel(null);
                    // Update info panel with current selection
                    updateInfoPanel(state.graph.selectedNode);
                } else {
                    // Check for edge under mouse
                    const edge = findHoveredEdge(worldPos.x, worldPos.y);
                    if (edge) {
                        // Show edge info panel
                        updateEdgeInfoPanel(edge);
                    } else {
                        // Click on empty space deselects everything
                        state.graph.selectedNode = null;
                        state.graph.selectedEdge = null;
                        updateInfoPanel(null);
                        updateEdgeInfoPanel(null);
                    }
                }

                e.preventDefault();
            });

            // Mouse wheel zoom
            finalCanvas.addEventListener('wheel', (e) => {
                e.preventDefault();

                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
                zoomCanvas(zoomDelta, mouseX, mouseY);
            }, { passive: false });
        }

        // Zoom button controls
        document.getElementById('zoom-in').addEventListener('click', () => {
            zoomCanvas(1.2);
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            zoomCanvas(0.8);
        });

        document.getElementById('zoom-reset').addEventListener('click', () => {
            state.graph.viewport.zoom = 1.0;
            state.graph.viewport.panX = 0;
            state.graph.viewport.panY = 0;
            updateZoomDisplay();
            startAnimation();  // Restart animation to redraw
        });

        // Maximize/fullscreen toggle
        document.getElementById('maximize-btn').addEventListener('click', () => {
            toggleGraphFullscreen();
        });

        function toggleGraphFullscreen() {
            const graphView = document.getElementById('graph-view');
            const maximizeBtn = document.getElementById('maximize-btn');
            const isFullscreen = graphView.classList.toggle('fullscreen');
            
            // Update button icon and title
            maximizeBtn.textContent = isFullscreen ? 'â›¶' : 'â›¶';
            maximizeBtn.title = isFullscreen ? 'Exit Fullscreen (Esc)' : 'Fullscreen (Esc to exit)';
            
            // Resize canvas to fit new dimensions
            const canvas = document.getElementById('graph-canvas');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            
            startAnimation();  // Restart animation to redraw
        }

        // Escape key to exit fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const graphView = document.getElementById('graph-view');
                if (graphView.classList.contains('fullscreen')) {
                    toggleGraphFullscreen();
                }
            }
        });

        // Auto-follow toggle and agent selector
        document.getElementById('auto-follow-switch').addEventListener('click', () => {
            state.graph.autoFollow = !state.graph.autoFollow;
            updateAutoFollowDisplay();
            // When enabling auto-follow, reset user pause and immediately snap to selected target
            if (state.graph.autoFollow && state.graph.followTargetId) {
                state.graph.userPausedFollow = false;  // Clear pause on explicit re-enable
                snapToFollowTarget();
            } else if (!state.graph.autoFollow) {
                // When disabling auto-follow, stop tracking
                state.graph.followingNodeId = null;
            }
        });

        document.getElementById('agent-selector').addEventListener('change', (e) => {
            state.graph.followTargetId = e.target.value || 'auto';
            // Reset focus switch time when user manually selects a target
            state.graph.lastFocusSwitchTime = Date.now();
            state.graph.userPausedFollow = false;  // Clear pause on explicit target selection
            // If auto-follow is enabled and we selected a target, snap to it
            if (state.graph.autoFollow && state.graph.followTargetId) {
                snapToFollowTarget();
            } else {
                state.graph.followingNodeId = null;
            }
        });

        // Auto-follow config popover
        const configBtn = document.getElementById('auto-follow-config-btn');
        const configPopover = document.getElementById('auto-follow-config-popover');
        
        // Load saved config from localStorage
        function loadAutoFollowConfig() {
            const saved = localStorage.getItem('binnacle-auto-follow-config');
            if (saved) {
                try {
                    const config = JSON.parse(saved);
                    state.graph.autoFollowConfig = {
                        nodeTypes: config.nodeTypes || { task: true, bug: true, idea: false, test: false, doc: false },
                        focusDelaySeconds: config.focusDelaySeconds || 10
                    };
                } catch (e) {
                    console.error('Failed to parse auto-follow config:', e);
                    state.graph.autoFollowConfig = getDefaultAutoFollowConfig();
                }
            } else {
                state.graph.autoFollowConfig = getDefaultAutoFollowConfig();
            }
        }
        
        function getDefaultAutoFollowConfig() {
            return {
                nodeTypes: { task: true, bug: true, idea: false, test: false, doc: false },
                focusDelaySeconds: 10
            };
        }
        
        function saveAutoFollowConfig() {
            localStorage.setItem('binnacle-auto-follow-config', JSON.stringify(state.graph.autoFollowConfig));
        }
        
        function updateConfigUI() {
            const config = state.graph.autoFollowConfig;
            // Update toggles
            for (const type of ['task', 'bug', 'idea', 'test', 'doc']) {
                const toggle = document.getElementById(`config-follow-${type}s`);
                if (toggle) {
                    toggle.classList.toggle('active', config.nodeTypes[type]);
                }
            }
            // Update duration input
            const delayInput = document.getElementById('config-focus-delay');
            if (delayInput) {
                delayInput.value = config.focusDelaySeconds;
            }
        }
        
        // Initialize config
        loadAutoFollowConfig();
        updateConfigUI();
        
        // Toggle popover visibility
        configBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isVisible = configPopover.classList.contains('visible');
            configPopover.classList.toggle('visible', !isVisible);
            configBtn.classList.toggle('active', !isVisible);
        });
        
        // Close popover when clicking outside
        document.addEventListener('click', (e) => {
            if (!configPopover.contains(e.target) && e.target !== configBtn) {
                configPopover.classList.remove('visible');
                configBtn.classList.remove('active');
            }
        });
        
        // Handle node type toggles
        configPopover.querySelectorAll('.config-toggle').forEach(toggle => {
            toggle.addEventListener('click', () => {
                const type = toggle.dataset.type;
                if (type && state.graph.autoFollowConfig.nodeTypes.hasOwnProperty(type)) {
                    state.graph.autoFollowConfig.nodeTypes[type] = !state.graph.autoFollowConfig.nodeTypes[type];
                    toggle.classList.toggle('active');
                    saveAutoFollowConfig();
                }
            });
        });
        
        // Handle focus delay input
        const focusDelayInput = document.getElementById('config-focus-delay');
        focusDelayInput.addEventListener('change', (e) => {
            const value = parseInt(e.target.value, 10);
            if (!isNaN(value) && value >= 1 && value <= 60) {
                state.graph.autoFollowConfig.focusDelaySeconds = value;
                saveAutoFollowConfig();
            } else {
                e.target.value = state.graph.autoFollowConfig.focusDelaySeconds;
            }
        });

        function updateAutoFollowDisplay() {
            const switchEl = document.getElementById('auto-follow-switch');
            if (state.graph.autoFollow) {
                switchEl.classList.add('active');
            } else {
                switchEl.classList.remove('active');
            }
        }

        function updateFollowSelector() {
            const selector = document.getElementById('agent-selector');
            const workerAgents = (state.agents || []).filter(a => a.agent_type === 'worker');
            const queueNode = state.tasks?.find(t => t.type === 'queue');
            const hasActiveTask = state.tasks?.some(t => 
                (t.type === 'task' || t.type === 'bug') && t.status === 'in_progress'
            );
            
            // Remember current selection
            const currentValue = selector.value;
            
            // Clear and repopulate options - start with 'Auto' (default)
            selector.innerHTML = '<option value="auto">Auto</option>';
            
            // Add "Active Task" option
            const activeOption = document.createElement('option');
            activeOption.value = 'active-task';
            activeOption.textContent = 'Active Task';
            if (!hasActiveTask) {
                activeOption.disabled = true;
                activeOption.textContent = 'Active Task (none)';
            }
            if (currentValue === 'active-task' || state.graph.followTargetId === 'active-task') {
                activeOption.selected = true;
            }
            selector.appendChild(activeOption);
            
            // Add "Queue" option
            if (queueNode) {
                const queueOption = document.createElement('option');
                queueOption.value = 'queue';
                queueOption.textContent = 'Queue';
                if (currentValue === 'queue' || state.graph.followTargetId === 'queue') {
                    queueOption.selected = true;
                }
                selector.appendChild(queueOption);
            }
            
            // Add agents if any exist
            if (workerAgents.length > 0) {
                // Add separator
                const separator = document.createElement('option');
                separator.disabled = true;
                separator.textContent = 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
                selector.appendChild(separator);
                
                workerAgents.forEach(agent => {
                    const agentId = agent.id || `agent-${agent.pid}`;
                    const option = document.createElement('option');
                    option.value = agentId;
                    option.textContent = agent.name || `Agent ${agent.pid}`;
                    if (agentId === currentValue || agentId === state.graph.followTargetId) {
                        option.selected = true;
                    }
                    selector.appendChild(option);
                });
            }
            
            // If currently followed target is an agent that's gone, revert to 'auto'
            if (state.graph.followTargetId && 
                state.graph.followTargetId !== 'auto' &&
                state.graph.followTargetId !== 'active-task' && 
                state.graph.followTargetId !== 'queue') {
                const agentStillExists = workerAgents.some(a => 
                    (a.id || `agent-${a.pid}`) === state.graph.followTargetId
                );
                if (!agentStillExists) {
                    // Agent died - revert to auto mode
                    state.graph.followTargetId = 'auto';
                    state.graph.followingNodeId = null;
                    selector.value = 'auto';
                }
            }
            
            // Ensure auto is selected if that's the current target
            if (state.graph.followTargetId === 'auto' || currentValue === 'auto') {
                selector.value = 'auto';
            }
        }

        // Hide completed toggle
        document.getElementById('hide-completed-switch').addEventListener('click', () => {
            state.graph.hideCompleted = !state.graph.hideCompleted;
            updateHideCompletedDisplay();
            startAnimation();  // Restart animation to apply filter
        });

        function updateHideCompletedDisplay() {
            const switchEl = document.getElementById('hide-completed-switch');
            if (state.graph.hideCompleted) {
                switchEl.classList.add('active');
            } else {
                switchEl.classList.remove('active');
            }
        }

        // Chain length filter
        const chainLengthSlider = document.getElementById('chain-length-slider');
        const chainLengthValue = document.getElementById('chain-length-value');
        const chainLengthFilter = document.getElementById('chain-length-filter');

        // Load saved chain length filter from localStorage
        function loadChainLengthFilter() {
            const saved = localStorage.getItem('binnacle_chain_length_filter');
            if (saved) {
                const value = parseInt(saved, 10);
                if (!isNaN(value) && value >= 1 && value <= 5) {
                    return value;
                }
            }
            return 1;
        }

        // Save chain length filter to localStorage
        function saveChainLengthFilter(value) {
            localStorage.setItem('binnacle_chain_length_filter', value.toString());
        }

        // Initialize chain length filter from saved state
        state.graph.minChainLength = loadChainLengthFilter();
        chainLengthSlider.value = state.graph.minChainLength;
        chainLengthValue.textContent = state.graph.minChainLength >= 5 ? '5+' : state.graph.minChainLength;
        updateChainLengthDisplay();

        chainLengthSlider.addEventListener('input', () => {
            const value = parseInt(chainLengthSlider.value, 10);
            state.graph.minChainLength = value;
            chainLengthValue.textContent = value >= 5 ? '5+' : value;
            saveChainLengthFilter(value);
            updateChainLengthDisplay();
            startAnimation();  // Restart animation to apply filter
        });

        function updateChainLengthDisplay() {
            if (state.graph.minChainLength > 1) {
                chainLengthFilter.classList.add('active');
            } else {
                chainLengthFilter.classList.remove('active');
            }
        }

        function normalizeSearchQuery(query) {
            return (query || '').trim().toLowerCase();
        }

        function nodeMatchesSearch(node, normalizedQuery) {
            if (!normalizedQuery) return true;
            const haystack = `${node.id} ${(node.title || '')} ${(node.short_name || '')}`.toLowerCase();
            return haystack.includes(normalizedQuery);
        }

        function setGraphSearchQuery(query) {
            state.graph.searchQuery = query;
            // Note: We no longer need to clear selection/hover here since
            // non-matching nodes are now dimmed rather than hidden.
            // The visibleNodeIds check only applies to hideCompleted filtering.
            startAnimation();  // Restart animation to apply search filter
        }

        function initializeGraphSearch() {
            const input = document.getElementById('graph-search');
            if (!input) return;

            input.addEventListener('input', () => {
                setGraphSearchQuery(input.value);
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    input.value = '';
                    setGraphSearchQuery('');
                    e.preventDefault();
                }
            });
        }

        // Initialize view search bar for consolidated Nodes view
        function initializeViewSearch() {
            const input = document.getElementById('nodes-search');
            const toggle = document.getElementById('nodes-include-closed');
            const typeFilter = document.getElementById('nodes-type-filter');

            if (input) {
                input.addEventListener('input', () => {
                    viewSearch.nodes = input.value.toLowerCase();
                    renderNodes();
                });

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        input.value = '';
                        viewSearch.nodes = '';
                        renderNodes();
                        e.preventDefault();
                    }
                });
            }

            if (toggle) {
                toggle.addEventListener('click', () => {
                    includeClosed.nodes = !includeClosed.nodes;
                    toggle.classList.toggle('active', includeClosed.nodes);
                    renderNodes();
                });
            }

            if (typeFilter) {
                typeFilter.addEventListener('change', () => {
                    nodesTypeFilter = typeFilter.value;
                    renderNodes();
                });
            }
            
            const tagFilter = document.getElementById('nodes-tag-filter');
            if (tagFilter) {
                tagFilter.addEventListener('change', () => {
                    nodesTagFilter = tagFilter.value;
                    renderNodes();
                });
            }
        }

        // Check if an item matches the view search query
        function itemMatchesViewSearch(item, query) {
            if (!query) return true;
            const haystack = [
                item.id || '',
                item.title || '',
                item.short_name || '',
                item.description || ''
            ].join(' ').toLowerCase();
            return haystack.includes(query);
        }
        
        // Sync type filter dropdown with JS variable (ensures DOM and state match)
        function syncTypeFilterDropdown() {
            const typeFilter = document.getElementById('nodes-type-filter');
            if (!typeFilter) return;
            
            // Sync dropdown DOM value with JS variable
            if (typeFilter.value !== nodesTypeFilter) {
                typeFilter.value = nodesTypeFilter;
            }
        }
        
        // Populate tag filter dropdown with unique tags from all nodes
        function updateTagFilterDropdown() {
            const tagFilter = document.getElementById('nodes-tag-filter');
            if (!tagFilter) return;
            
            // Collect all unique tags from all node types
            const tags = new Set();
            
            (state.tasks || []).forEach(t => {
                (t.tags || []).forEach(tag => tags.add(tag));
            });
            (state.ideas || []).forEach(idea => {
                (idea.tags || []).forEach(tag => tags.add(tag));
            });
            (state.tests || []).forEach(test => {
                (test.tags || []).forEach(tag => tags.add(tag));
            });
            (state.docs || []).forEach(doc => {
                (doc.tags || []).forEach(tag => tags.add(tag));
            });
            
            // Sort tags alphabetically
            const sortedTags = [...tags].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
            
            // Preserve current selection
            const currentValue = tagFilter.value;
            
            // Rebuild options
            tagFilter.innerHTML = '<option value="">All</option>';
            sortedTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                tagFilter.appendChild(option);
            });
            
            // Restore selection if still valid
            if (sortedTags.includes(currentValue)) {
                tagFilter.value = currentValue;
            } else {
                tagFilter.value = '';
                nodesTagFilter = '';
            }
        }

        // Find and pan to the first active agent or in_progress task, zooming to 100%
        // (Legacy function for initial page load - now uses snapToFollowTarget when available)
        function snapToActiveTask() {
            // If we have a selected target to follow, use that instead
            if (state.graph.followTargetId) {
                snapToFollowTarget();
                return;
            }
            
            if (!state.tasks) return;
            
            // Fallback: follow the active task (in_progress), not agent nodes
            const activeTask = state.tasks.find(t => t.status === 'in_progress' && t.type !== 'agent');
            if (activeTask) {
                state.graph.followingNodeId = activeTask.id;
                panToNode(activeTask.id, true);  // Zoom to 100%
            } else {
                state.graph.followingNodeId = null;
            }
        }

        // Snap camera to the currently followed target (active task, queue, auto, or agent)
        function snapToFollowTarget() {
            if (!state.graph.followTargetId || !state.tasks) return;
            
            let targetNode = null;
            
            if (state.graph.followTargetId === 'auto') {
                // Auto mode: follow the agent with the most recent activity
                targetNode = findMostRecentlyActiveAgent();
            } else if (state.graph.followTargetId === 'active-task') {
                // Find the first in_progress task or bug
                targetNode = state.tasks.find(t => 
                    (t.type === 'task' || t.type === 'bug') && t.status === 'in_progress'
                );
            } else if (state.graph.followTargetId === 'queue') {
                // Find the queue node
                targetNode = state.tasks.find(t => t.type === 'queue');
            } else {
                // Find the agent node by ID
                targetNode = state.tasks.find(t => t.id === state.graph.followTargetId && t.type === 'agent');
            }
            
            if (targetNode) {
                state.graph.followingNodeId = targetNode.id;
                panToNode(targetNode.id, true);  // Zoom to 100%
            } else {
                state.graph.followingNodeId = null;
            }
        }
        
        // Find the agent with the most recent activity (for auto-follow mode)
        function findMostRecentlyActiveAgent() {
            const workerAgents = (state.agents || []).filter(a => a.agent_type === 'worker');
            if (workerAgents.length === 0) return null;
            
            // Sort by last_activity_at descending, pick the most recent
            const sortedAgents = [...workerAgents].sort((a, b) => {
                const aTime = a.last_activity_at ? new Date(a.last_activity_at).getTime() : 0;
                const bTime = b.last_activity_at ? new Date(b.last_activity_at).getTime() : 0;
                return bTime - aTime;
            });
            
            const mostRecentAgent = sortedAgents[0];
            if (!mostRecentAgent) return null;
            
            const agentId = mostRecentAgent.id || `agent-${mostRecentAgent.pid}`;
            return state.tasks.find(t => t.id === agentId && t.type === 'agent');
        }

        function zoomCanvas(zoomDelta, centerX, centerY) {
            const canvas = document.getElementById('graph-canvas');
            if (!centerX || !centerY) {
                // Default to canvas center
                centerX = canvas.width / 2;
                centerY = canvas.height / 2;
            }

            // World point under cursor before zoom
            const worldBefore = screenToWorld(centerX, centerY, canvas);

            // Update zoom
            const oldZoom = state.graph.viewport.zoom;
            state.graph.viewport.zoom = Math.max(
                state.graph.viewport.minZoom,
                Math.min(state.graph.viewport.maxZoom, oldZoom * zoomDelta)
            );

            // World point under cursor after zoom
            const worldAfter = screenToWorld(centerX, centerY, canvas);

            // Adjust pan to keep point stationary
            state.graph.viewport.panX += worldBefore.x - worldAfter.x;
            state.graph.viewport.panY += worldBefore.y - worldAfter.y;

            // Update zoom level display
            updateZoomDisplay();
            
            // Restart animation to redraw with new zoom level
            startAnimation();
        }

        function updateZoomDisplay() {
            const zoomLevelEl = document.getElementById('zoom-level');
            if (zoomLevelEl) {
                const percent = Math.round(state.graph.viewport.zoom * 100);
                zoomLevelEl.textContent = `${percent}%`;
            }
        }

        // Ease-in-out-cubic easing function
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Calculate adaptive pan duration based on distance
        function getPanDuration(distance) {
            // Doubled durations for smoother animation
            if (distance < 300) return 600;
            if (distance <= 800) return 1000;
            return 1600;
        }

        // Pan camera smoothly to center on a world position
        function panToWorldPosition(targetX, targetY, targetZoom = null) {
            const canvas = document.getElementById('graph-canvas');
            const { viewport } = state.graph;

            // Target pan values to center the position on screen
            // worldToScreen: screenX = (worldX + panX) * zoom + canvas.width / 2
            // To center targetX, we need: canvas.width / 2 = (targetX + panX) * zoom + canvas.width / 2
            // => 0 = (targetX + panX) * zoom
            // => panX = -targetX
            const targetPanX = -targetX;
            const targetPanY = -targetY;

            // Calculate distance in screen pixels for duration
            const startPanX = viewport.panX;
            const startPanY = viewport.panY;
            const startZoom = viewport.zoom;
            const dx = (targetPanX - startPanX) * viewport.zoom;
            const dy = (targetPanY - startPanY) * viewport.zoom;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Calculate zoom change for duration consideration
            const zoomChange = targetZoom !== null ? Math.abs(targetZoom - startZoom) : 0;

            // Skip animation if already centered (within 1 pixel) and no zoom change
            if (distance < 1 && zoomChange < 0.01) return;

            // Use longer duration if there's significant zoom change
            const baseDuration = getPanDuration(distance);
            const duration = zoomChange > 0.1 ? Math.max(baseDuration, 800) : baseDuration;

            // Start the animation
            state.graph.followAnimation = {
                startPanX,
                startPanY,
                targetPanX,
                targetPanY,
                startZoom,
                targetZoom: targetZoom !== null ? targetZoom : startZoom,
                startTime: performance.now(),
                duration
            };
            
            // Restart animation loop to run the camera animation
            startAnimation();
        }

        // Pan camera smoothly to center on a node by ID, optionally zooming to 100%
        function panToNode(nodeId, zoomTo100 = false) {
            const node = state.graph.nodes.find(n => n.id === nodeId);
            if (node) {
                panToWorldPosition(node.x, node.y, zoomTo100 ? 1.0 : null);
            }
        }

        // Cancel any ongoing pan animation
        function cancelPanAnimation() {
            state.graph.followAnimation = null;
            // Also cancel pan-through if in progress
            if (state.graph.panThroughState !== 'idle') {
                cancelPanThrough();
            }
        }

        // Update pan animation (called from animateGraph)
        function updatePanAnimation() {
            const anim = state.graph.followAnimation;
            if (!anim) return;

            const now = performance.now();
            const elapsed = now - anim.startTime;
            const progress = Math.min(elapsed / anim.duration, 1);
            const easedProgress = easeInOutCubic(progress);

            // Interpolate pan values
            state.graph.viewport.panX = anim.startPanX + (anim.targetPanX - anim.startPanX) * easedProgress;
            state.graph.viewport.panY = anim.startPanY + (anim.targetPanY - anim.startPanY) * easedProgress;

            // Interpolate zoom if target differs from start
            if (anim.targetZoom !== anim.startZoom) {
                state.graph.viewport.zoom = anim.startZoom + (anim.targetZoom - anim.startZoom) * easedProgress;
                updateZoomDisplay();
            }

            // Animation complete
            if (progress >= 1) {
                state.graph.followAnimation = null;
            }
        }

        // Pan-through: queue multiple nodes to visit in sequence
        function queuePanThrough(nodeIds) {
            if (!nodeIds || nodeIds.length === 0) return;
            
            // Add to existing queue (don't replace)
            state.graph.panThroughQueue.push(...nodeIds);
            
            // Start pan-through if not already running
            if (state.graph.panThroughState === 'idle') {
                startNextPanThrough();
            }
        }
        
        function startNextPanThrough() {
            if (state.graph.panThroughQueue.length === 0) {
                // Queue empty - return to idle and start focus period
                state.graph.panThroughState = 'idle';
                state.graph.panThroughPauseStart = null;
                // Set focus end time based on config (prevents immediate snap back to agent)
                const delaySeconds = state.graph.autoFollowConfig?.focusDelaySeconds || 10;
                state.graph.focusEndTime = Date.now() + delaySeconds * 1000;
                return;
            }
            
            // Get next node to visit
            const nodeId = state.graph.panThroughQueue.shift();
            const node = state.graph.nodes.find(n => n.id === nodeId);
            
            if (!node) {
                // Node doesn't exist, skip to next
                startNextPanThrough();
                return;
            }
            
            // Highlight the node temporarily
            state.graph.tempHighlightNode = nodeId;
            state.graph.tempHighlightStart = performance.now();
            
            // Start panning to this node
            state.graph.panThroughState = 'panning';
            panToNode(nodeId, true);  // Zoom to 100%
        }
        
        function updatePanThrough() {
            // Skip if not in pan-through mode
            if (state.graph.panThroughState === 'idle') return;
            
            // Skip if auto-follow is disabled
            if (!state.graph.autoFollow) {
                cancelPanThrough();
                return;
            }
            
            if (state.graph.panThroughState === 'panning') {
                // Check if pan animation is complete
                if (!state.graph.followAnimation) {
                    // Start pause
                    state.graph.panThroughState = 'paused';
                    state.graph.panThroughPauseStart = performance.now();
                }
            } else if (state.graph.panThroughState === 'paused') {
                // Check if pause is complete
                const elapsed = performance.now() - state.graph.panThroughPauseStart;
                if (elapsed >= state.graph.panThroughPauseDuration) {
                    // Move to next node
                    startNextPanThrough();
                }
            }
        }
        
        function cancelPanThrough() {
            state.graph.panThroughQueue = [];
            state.graph.panThroughState = 'idle';
            state.graph.panThroughPauseStart = null;
            // Don't clear focusEndTime here - focus period continues after cancel
        }
        
        // Cancel focus period early (called on manual user interaction)
        function cancelFocusPeriod() {
            state.graph.focusEndTime = null;
        }

        // Continuous follow: keep viewport centered on followed node as it moves
        function updateContinuousFollow(canvas) {
            // Skip if auto-follow is disabled or no node is being followed
            if (!state.graph.autoFollow || !state.graph.followingNodeId) return;
            
            // Skip if an animation is in progress (let it complete)
            if (state.graph.followAnimation) return;
            
            // Skip if user is panning or dragging
            if (state.graph.isPanning || state.graph.draggedNode) return;
            
            // Find the followed node
            const node = state.graph.nodes.find(n => n.id === state.graph.followingNodeId);
            if (!node) {
                // Node no longer exists, clear following
                state.graph.followingNodeId = null;
                return;
            }
            
            // Calculate target pan to center the node
            const targetPanX = -node.x;
            const targetPanY = -node.y;
            
            // Calculate distance to target
            const dx = targetPanX - state.graph.viewport.panX;
            const dy = targetPanY - state.graph.viewport.panY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Snap to exact center if very close (prevents perpetual drift)
            if (distance < 0.5) {
                state.graph.viewport.panX = targetPanX;
                state.graph.viewport.panY = targetPanY;
                return;
            }
            
            // Smoothly interpolate toward target (soft follow)
            // Use higher smoothing (0.15) for responsive tracking while still being smooth
            const smoothing = 0.15;
            state.graph.viewport.panX += dx * smoothing;
            state.graph.viewport.panY += dy * smoothing;
        }

        function updateTooltip(node, mouseX, mouseY) {
            const tooltip = document.getElementById('node-tooltip');
            const titleEl = document.getElementById('tooltip-title');
            const idEl = document.getElementById('tooltip-id');
            const metaEl = document.getElementById('tooltip-meta');

            if (!node) {
                tooltip.classList.remove('visible');
                return;
            }

            // Find full task data
            const task = state.tasks.find(t => t.id === node.id);
            if (!task) return;

            // Update tooltip content - show short_name if available, otherwise title
            titleEl.textContent = task.short_name || task.title;
            idEl.textContent = task.id;

            // Build metadata badges
            metaEl.innerHTML = `
                <span class="badge badge-priority-${task.priority}">P${task.priority}</span>
                <span class="badge badge-status-${task.status}">${task.status}</span>
                ${task.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
            `;

            // Position tooltip
            const offset = 15;
            tooltip.style.left = `${mouseX + offset}px`;
            tooltip.style.top = `${mouseY + offset}px`;

            // Adjust if tooltip goes off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (tooltipRect.right > viewportWidth) {
                tooltip.style.left = `${mouseX - tooltipRect.width - offset}px`;
            }
            if (tooltipRect.bottom > viewportHeight) {
                tooltip.style.top = `${mouseY - tooltipRect.height - offset}px`;
            }

            tooltip.classList.add('visible');
        }

        // Edge tooltip functions
        function getEdgeTypeName(edgeType) {
            const names = {
                'depends_on': 'Depends On',
                'blocks': 'Blocks',
                'related_to': 'Related To',
                'caused_by': 'Caused By',
                'duplicates': 'Duplicates',
                'supersedes': 'Supersedes',
                'pinned': 'Pinned',
                'fixes': 'Fixes',
                'tests': 'Tests',
                'parent_of': 'Parent Of',
                'child_of': 'Child Of',
                'queued': 'Queued',
                'working_on': 'Working On',
                'worked_on': 'Worked On'
            };
            return names[edgeType] || edgeType;
        }

        function distanceToEdge(px, py, edge) {
            // Get node positions
            const fromNode = state.graph.nodes.find(n => n.id === edge.from);
            const toNode = state.graph.nodes.find(n => n.id === edge.to);
            if (!fromNode || !toNode) return Infinity;

            // Calculate edge endpoints (at node boundaries, not centers)
            const dx = toNode.x - fromNode.x;
            const dy = toNode.y - fromNode.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < fromNode.radius + toNode.radius) return Infinity;

            const angle = Math.atan2(dy, dx);
            const x1 = fromNode.x + Math.cos(angle) * fromNode.radius;
            const y1 = fromNode.y + Math.sin(angle) * fromNode.radius;
            const x2 = toNode.x - Math.cos(angle) * toNode.radius;
            const y2 = toNode.y - Math.sin(angle) * toNode.radius;

            // Calculate distance from point to line segment
            const lineDx = x2 - x1;
            const lineDy = y2 - y1;
            const lineLen = Math.sqrt(lineDx * lineDx + lineDy * lineDy);
            if (lineLen === 0) return Infinity;

            // Project point onto line, clamped to segment
            const t = Math.max(0, Math.min(1, ((px - x1) * lineDx + (py - y1) * lineDy) / (lineLen * lineLen)));
            const projX = x1 + t * lineDx;
            const projY = y1 + t * lineDy;

            return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
        }

        function findHoveredEdge(worldX, worldY, threshold = 8) {
            // Adjust threshold for zoom level
            const adjustedThreshold = threshold / state.graph.viewport.zoom;
            
            let closestEdge = null;
            let closestDistance = adjustedThreshold;

            for (const edge of state.graph.edges) {
                // Skip edges that are filtered out
                if (!state.edgeFilters[edge.edge_type]) continue;

                // Skip edges where either endpoint is hidden
                if (state.graph.visibleNodeIds) {
                    if (!state.graph.visibleNodeIds.has(edge.from) || !state.graph.visibleNodeIds.has(edge.to)) {
                        continue;
                    }
                }
                
                const distance = distanceToEdge(worldX, worldY, edge);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestEdge = edge;
                }
            }

            return closestEdge;
        }

        function updateEdgeTooltip(edge, mouseX, mouseY) {
            const tooltip = document.getElementById('edge-tooltip');
            const typeEl = document.getElementById('edge-tooltip-type');
            const idsEl = document.getElementById('edge-tooltip-ids');
            const reasonEl = document.getElementById('edge-tooltip-reason');
            const dateEl = document.getElementById('edge-tooltip-date');

            if (!edge) {
                tooltip.classList.remove('visible');
                return;
            }

            // Get the full edge data from state.edges (API data with created_at)
            const fullEdge = state.edges.find(e => 
                e.source === edge.from && e.target === edge.to && e.edge_type === edge.edge_type
            );

            // Get edge style for color
            const style = getEdgeStyle(edge.edge_type);
            
            // Update tooltip content
            typeEl.innerHTML = `
                <span class="edge-color-dot" style="background-color: ${style.color}"></span>
                ${getEdgeTypeName(edge.edge_type)}${edge.bidirectional ? ' (bidirectional)' : ''}
            `;
            idsEl.textContent = `${edge.from} â†’ ${edge.to}`;

            // Show/hide reason
            if (edge.reason) {
                reasonEl.textContent = `"${edge.reason}"`;
                reasonEl.style.display = 'block';
            } else {
                reasonEl.style.display = 'none';
            }

            // Show created date if available
            if (fullEdge && fullEdge.created_at) {
                const date = new Date(fullEdge.created_at);
                dateEl.textContent = `Created: ${date.toLocaleDateString()}`;
                dateEl.style.display = 'block';
            } else {
                dateEl.style.display = 'none';
            }

            // Position tooltip
            const offset = 15;
            tooltip.style.left = `${mouseX + offset}px`;
            tooltip.style.top = `${mouseY + offset}px`;

            // Adjust if tooltip goes off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (tooltipRect.right > viewportWidth) {
                tooltip.style.left = `${mouseX - tooltipRect.width - offset}px`;
            }
            if (tooltipRect.bottom > viewportHeight) {
                tooltip.style.top = `${mouseY - tooltipRect.height - offset}px`;
            }

            tooltip.classList.add('visible');
        }

        // Info panel state variables (declared before updateInfoPanel so they're in scope)
        let currentInfoPanelEntityId = null;
        let entityActivityCache = {};

        function updateInfoPanel(node) {
            const panel = document.getElementById('info-panel');
            const idEl = document.getElementById('info-panel-id');
            const titleEl = document.getElementById('info-panel-task-title');
            const metaEl = document.getElementById('info-panel-meta');
            const descEl = document.getElementById('info-panel-description');
            const descSection = document.getElementById('info-panel-description-section');
            const depsSection = document.getElementById('info-panel-deps-section');
            const depsList = document.getElementById('info-panel-deps');
            const closedSection = document.getElementById('info-panel-closed-section');
            const closedReason = document.getElementById('info-panel-closed-reason');
            const typeTitleEl = document.getElementById('info-panel-type-title');
            const relationshipsSection = document.getElementById('info-panel-relationships-section');
            const relationshipsList = document.getElementById('info-panel-relationships');
            const timestampsSection = document.getElementById('info-panel-timestamps-section');
            const timestampsList = document.getElementById('info-panel-timestamps');

            if (!node) {
                panel.classList.remove('visible');
                currentInfoPanelEntityId = null;
                return;
            }

            // Find full task data
            const task = state.tasks.find(t => t.id === node.id);
            if (!task) return;

            // Track current entity and reset to Details tab when switching entities
            if (currentInfoPanelEntityId !== task.id) {
                currentInfoPanelEntityId = task.id;
                // Reset to Details tab
                document.querySelectorAll('.info-panel-tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.tab === 'details');
                });
                document.querySelectorAll('.info-panel-tab-content').forEach(content => {
                    content.classList.toggle('active', content.id === 'info-panel-details-tab');
                });
                // Clear activity cache for this entity to force fresh load
                delete entityActivityCache[task.id];
            }

            // Update header title based on node type
            const typeLabels = {
                'task': 'Task Details',
                'bug': 'Bug Details',
                'idea': 'Idea Details',
                'milestone': 'Milestone Details',
                'queue': 'Queue Details',
                'agent': 'Agent Details'
            };
            typeTitleEl.textContent = typeLabels[task.type] || 'Task Details';

            // Update panel content
            idEl.textContent = task.id;
            titleEl.textContent = task.title;

            // Show short_name if set (after title)
            const shortNameEl = document.getElementById('info-panel-short-name');
            const shortNameRow = document.getElementById('info-panel-short-name-row');
            if (task.short_name) {
                shortNameEl.textContent = task.short_name;
                shortNameRow.style.display = 'block';
            } else {
                shortNameRow.style.display = 'none';
            }

            // Build metadata badges
            metaEl.innerHTML = `
                <span class="badge badge-priority-${task.priority}">P${task.priority}</span>
                <span class="badge badge-status-${task.status}">${task.status}</span>
                ${task.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
            `;

            // Description
            if (task.description) {
                descEl.textContent = task.description;
                descEl.classList.remove('empty');
                descSection.style.display = 'block';
            } else {
                descEl.textContent = 'No description provided';
                descEl.classList.add('empty');
                descSection.style.display = 'block';
            }

            // Dependencies - now clickable
            if (task.depends_on && task.depends_on.length > 0) {
                depsList.innerHTML = task.depends_on.map(depId => {
                    const depTask = state.tasks.find(t => t.id === depId);
                    const depTitle = depTask ? ` â€” ${escapeHtml(depTask.title)}` : '';
                    return `<li><span class="info-panel-node-link" data-node-id="${escapeHtml(depId)}">${escapeHtml(depId)}</span>${depTitle}</li>`;
                }).join('');
                depsSection.style.display = 'block';
            } else {
                depsSection.style.display = 'none';
            }

            // Relationships - show all edges connected to this node (excluding depends_on which are shown above)
            const nodeEdges = (state.edges || []).filter(edge => 
                (edge.source === task.id || edge.target === task.id) && edge.edge_type !== 'depends_on'
            );
            if (nodeEdges.length > 0) {
                relationshipsList.innerHTML = nodeEdges.map(edge => {
                    const isOutbound = edge.source === task.id;
                    const relatedId = isOutbound ? edge.target : edge.source;
                    const relatedTask = state.tasks.find(t => t.id === relatedId);
                    const relatedTitle = relatedTask ? escapeHtml(relatedTask.title) : '';
                    const direction = isOutbound ? 'â†’' : 'â†';
                    const edgeTypeName = EDGE_TYPES[edge.edge_type]?.name || edge.edge_type;
                    return `<li>
                        <span class="info-panel-edge-type">${escapeHtml(edgeTypeName)}</span>
                        <span class="info-panel-edge-direction">${direction}</span>
                        <span class="info-panel-node-link" data-node-id="${escapeHtml(relatedId)}">${escapeHtml(relatedId)}</span>
                        ${relatedTitle ? `<span style="color: var(--text-secondary)">â€” ${relatedTitle}</span>` : ''}
                    </li>`;
                }).join('');
                relationshipsSection.style.display = 'block';
            } else {
                relationshipsSection.style.display = 'none';
            }

            // Closed reason
            if (task.status === 'done' && task.closed_reason) {
                closedReason.textContent = task.closed_reason;
                closedSection.style.display = 'block';
            } else {
                closedSection.style.display = 'none';
            }

            // Timestamps
            const formatTimestamp = (ts) => {
                if (!ts) return null;
                const date = new Date(ts);
                return date.toLocaleDateString(undefined, { 
                    year: 'numeric', month: 'short', day: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });
            };
            const created = formatTimestamp(task.created_at);
            const updated = formatTimestamp(task.updated_at);
            const closed = formatTimestamp(task.closed_at);
            
            if (created || updated || closed) {
                let html = '';
                if (created) html += `<dt>Created:</dt><dd>${escapeHtml(created)}</dd>`;
                if (updated && updated !== created) html += `<dt>Updated:</dt><dd>${escapeHtml(updated)}</dd>`;
                if (closed) html += `<dt>Closed:</dt><dd>${escapeHtml(closed)}</dd>`;
                timestampsList.innerHTML = html;
                timestampsSection.style.display = 'block';
            } else {
                timestampsSection.style.display = 'none';
            }

            // Queue toggle - only show for tasks/bugs that can be queued
            const queueSection = document.getElementById('info-panel-queue-section');
            const queueToggle = document.getElementById('queue-toggle-btn');
            const canBeQueued = task.type === 'task' || task.type === 'bug' || !task.type;
            const isCompleted = task.status === 'done' || task.status === 'cancelled' || task.status === 'discarded';
            
            if (canBeQueued && !isCompleted) {
                queueSection.style.display = 'flex';
                const isQueued = isNodeQueued(task.id);
                queueToggle.classList.toggle('active', isQueued);
                queueToggle.title = isQueued ? 'Remove from queue' : 'Add to queue';
            } else {
                queueSection.style.display = 'none';
            }

            // Show panel
            panel.classList.add('visible');
        }

        // Handle clicks on node links in info panel
        document.getElementById('info-panel').addEventListener('click', (e) => {
            const link = e.target.closest('.info-panel-node-link');
            if (link) {
                const nodeId = link.dataset.nodeId;
                if (nodeId) {
                    // Disable auto-follow when user explicitly navigates to a specific node
                    state.graph.autoFollow = false;
                    cancelFocusPeriod();  // Cancel any active focus period
                    updateAutoFollowDisplay();
                    // Find and select the node
                    const targetNode = state.graph.nodes.find(n => n.id === nodeId);
                    if (targetNode) {
                        state.graph.selectedNode = targetNode;
                        updateInfoPanel(targetNode);
                        panToNode(nodeId);
                    }
                }
            }
        });

        // Info panel close button
        document.getElementById('info-panel-close').addEventListener('click', () => {
            state.graph.selectedNode = null;
            updateInfoPanel(null);
        });

        // Info panel tab switching
        document.querySelectorAll('.info-panel-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                
                // Update tab buttons
                document.querySelectorAll('.info-panel-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update tab content
                document.querySelectorAll('.info-panel-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`info-panel-${tabName}-tab`).classList.add('active');
                
                // Load activity when switching to activity tab
                if (tabName === 'activity' && currentInfoPanelEntityId) {
                    loadEntityActivity(currentInfoPanelEntityId);
                }
            });
        });

        // Fetch and display activity log entries for an entity
        async function loadEntityActivity(entityId) {
            const contentEl = document.getElementById('info-panel-activity-content');
            const viewFullLogLink = document.getElementById('info-panel-view-full-log');
            
            // Update the "View full log" link
            viewFullLogLink.onclick = () => {
                // Switch to Log view and set filter
                switchView('log');
                // Set the search filter to the entity ID
                state.logFilters.searchText = entityId;
                const searchInput = document.getElementById('log-search');
                if (searchInput) {
                    searchInput.value = entityId;
                }
                renderLog();
            };
            
            // Check cache first
            if (entityActivityCache[entityId]) {
                renderEntityActivity(entityActivityCache[entityId], entityId);
                return;
            }
            
            contentEl.innerHTML = '<div class="info-panel-activity-loading">Loading activity...</div>';
            
            try {
                // Fetch logs - we'll filter client-side for entries mentioning this entity
                const response = await fetch(`/api/log?limit=200`);
                if (!response.ok) throw new Error('Failed to fetch logs');
                
                const data = await response.json();
                const logs = data.log || [];
                
                // Filter logs for entries that mention this entity ID
                const entityLogs = logs.filter(entry => {
                    // Check if args contains the entity ID
                    const argsStr = JSON.stringify(entry.args || {});
                    return argsStr.includes(entityId);
                });
                
                // Cache the result
                entityActivityCache[entityId] = entityLogs;
                
                renderEntityActivity(entityLogs, entityId);
            } catch (error) {
                console.error('Failed to load entity activity:', error);
                contentEl.innerHTML = '<div class="info-panel-activity-empty">Failed to load activity</div>';
            }
        }

        function renderEntityActivity(logs, entityId) {
            const contentEl = document.getElementById('info-panel-activity-content');
            
            if (logs.length === 0) {
                contentEl.innerHTML = `<div class="info-panel-activity-empty">No activity recorded for ${escapeHtml(entityId)}</div>`;
                return;
            }
            
            const formatTime = (timestamp) => {
                const date = new Date(timestamp);
                const now = new Date();
                const diff = now - date;
                
                // Within last hour
                if (diff < 3600000) {
                    const mins = Math.floor(diff / 60000);
                    return mins <= 1 ? 'just now' : `${mins}m ago`;
                }
                // Within last 24 hours
                if (diff < 86400000) {
                    const hours = Math.floor(diff / 3600000);
                    return `${hours}h ago`;
                }
                // Older
                return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
            };
            
            const formatArgs = (args) => {
                if (!args || typeof args !== 'object') return '';
                // Filter out internal/verbose fields and show key info
                const important = {};
                const skip = ['force', 'check_complexity', 'dry_run'];
                for (const [key, value] of Object.entries(args)) {
                    if (skip.includes(key)) continue;
                    if (value === null || value === undefined) continue;
                    if (Array.isArray(value) && value.length === 0) continue;
                    important[key] = value;
                }
                if (Object.keys(important).length === 0) return '';
                
                // Format as key=value pairs, truncating long values
                return Object.entries(important)
                    .map(([k, v]) => {
                        const strVal = typeof v === 'string' ? v : JSON.stringify(v);
                        const truncated = strVal.length > 30 ? strVal.substring(0, 27) + '...' : strVal;
                        return `${k}=${truncated}`;
                    })
                    .join(', ');
            };
            
            contentEl.innerHTML = logs.slice(0, 20).map(entry => {
                const isError = entry.success === false;
                const argsStr = formatArgs(entry.args);
                
                return `
                    <div class="info-panel-activity-entry ${isError ? 'error' : ''}">
                        <div class="info-panel-activity-header">
                            <span class="info-panel-activity-command">${escapeHtml(entry.command)}</span>
                            <span class="info-panel-activity-time">${formatTime(entry.timestamp)}</span>
                        </div>
                        ${argsStr ? `<div class="info-panel-activity-args">${escapeHtml(argsStr)}</div>` : ''}
                        ${entry.error ? `<div class="info-panel-activity-args" style="color: var(--error-color);">${escapeHtml(entry.error)}</div>` : ''}
                    </div>
                `;
            }).join('');
            
            if (logs.length > 20) {
                contentEl.innerHTML += `<div class="info-panel-activity-empty" style="padding: 0.5rem;">+ ${logs.length - 20} more entries</div>`;
            }
        }

        // Clear activity cache when data refreshes
        function clearEntityActivityCache() {
            entityActivityCache = {};
        }

        // Edge info panel functions
        function updateEdgeInfoPanel(edge) {
            const panel = document.getElementById('edge-info-panel');
            
            if (!edge) {
                panel.classList.remove('visible');
                return;
            }

            // Hide node info panel when showing edge info
            document.getElementById('info-panel').classList.remove('visible');
            state.graph.selectedNode = null;

            // Get full edge data from state.edges
            const fullEdge = state.edges.find(e => 
                e.source === edge.from && e.target === edge.to && e.edge_type === edge.edge_type
            );

            // Get edge style for color
            const style = getEdgeStyle(edge.edge_type);
            
            // Update type with color indicator
            document.getElementById('edge-info-color').style.backgroundColor = style.color;
            document.getElementById('edge-info-type-name').textContent = getEdgeTypeName(edge.edge_type);

            // Find source and target task info
            const sourceTask = state.tasks.find(t => t.id === edge.from);
            const targetTask = state.tasks.find(t => t.id === edge.to);

            // Update connection info
            document.getElementById('edge-info-source-id').textContent = edge.from;
            document.getElementById('edge-info-source-title').textContent = sourceTask?.title || 'Unknown';
            document.getElementById('edge-info-target-id').textContent = edge.to;
            document.getElementById('edge-info-target-title').textContent = targetTask?.title || 'Unknown';

            // Show/hide reason section
            const reasonSection = document.getElementById('edge-info-reason-section');
            const reasonEl = document.getElementById('edge-info-reason');
            if (edge.reason || fullEdge?.reason) {
                reasonEl.textContent = edge.reason || fullEdge.reason;
                reasonSection.style.display = 'block';
            } else {
                reasonSection.style.display = 'none';
            }

            // Show created date if available
            const dateEl = document.getElementById('edge-info-date');
            if (fullEdge && fullEdge.created_at) {
                const date = new Date(fullEdge.created_at);
                dateEl.textContent = `Created: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
                dateEl.style.display = 'block';
            } else {
                dateEl.style.display = 'none';
            }

            // Show panel
            panel.classList.add('visible');
            
            // Store selected edge
            state.graph.selectedEdge = edge;
        }

        // Edge info panel close button
        document.getElementById('edge-info-close').addEventListener('click', () => {
            state.graph.selectedEdge = null;
            updateEdgeInfoPanel(null);
        });

        // Queue toggle button click handler
        document.getElementById('queue-toggle-btn').addEventListener('click', async () => {
            const selectedNode = state.graph.selectedNode;
            if (!selectedNode) return;

            const queueToggle = document.getElementById('queue-toggle-btn');
            queueToggle.disabled = true;

            try {
                const response = await fetch('/api/queue/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ node_id: selectedNode.id })
                });

                const result = await response.json();
                
                if (result.success) {
                    const isQueued = result.queued;
                    queueToggle.classList.toggle('active', isQueued);
                    queueToggle.title = isQueued ? 'Remove from queue' : 'Add to queue';
                    showToast(result.message, 'success');
                    // Refresh data to update edges and visual state
                    await loadData();
                } else {
                    showToast(result.error || 'Failed to toggle queue', 'error');
                }
            } catch (err) {
                showToast('Failed to toggle queue: ' + err.message, 'error');
            } finally {
                queueToggle.disabled = false;
            }
        });

        // Coordinate transformation functions
        function screenToWorld(screenX, screenY, canvas) {
            const { panX, panY, zoom } = state.graph.viewport;
            return {
                x: (screenX - canvas.width / 2) / zoom - panX,
                y: (screenY - canvas.height / 2) / zoom - panY
            };
        }

        function worldToScreen(worldX, worldY, canvas) {
            const { panX, panY, zoom } = state.graph.viewport;
            return {
                x: (worldX + panX) * zoom + canvas.width / 2,
                y: (worldY + panY) * zoom + canvas.height / 2
            };
        }

        /**
         * Build a set of "active" node IDs - nodes that are not in a completed state.
         * Active nodes include: pending, in_progress, blocked, reopened statuses.
         * For ideas: seed, germinating are active; promoted, discarded are not.
         */
        function buildActiveNodeSet() {
            const activeStatuses = ['pending', 'in_progress', 'blocked', 'reopened'];
            const activeIdeaStatuses = ['seed', 'germinating'];

            const activeNodes = new Set();

            state.tasks.forEach(task => {
                let isActive = false;

                if (task.type === 'idea') {
                    isActive = activeIdeaStatuses.includes(task.status);
                } else {
                    isActive = activeStatuses.includes(task.status);
                }

                if (isActive) {
                    activeNodes.add(task.id);
                }
            });

            return activeNodes;
        }

        /**
         * Check if a node is in an "active chain" - meaning it's either:
         * 1. An active node itself, OR
         * 2. Connected (transitively through edges) to an active node
         *
         * This allows completed nodes to remain visible if they're part of
         * a dependency chain with work that's still in progress.
         */
        function isInActiveChain(nodeId, activeNodes, edges) {
            // If the node itself is active, it's in an active chain
            if (activeNodes.has(nodeId)) {
                return true;
            }

            // Build adjacency list for traversal (both directions)
            const adjacency = new Map();
            edges.forEach(edge => {
                if (!adjacency.has(edge.from)) {
                    adjacency.set(edge.from, []);
                }
                if (!adjacency.has(edge.to)) {
                    adjacency.set(edge.to, []);
                }
                // Add bidirectional edges for traversal
                adjacency.get(edge.from).push(edge.to);
                adjacency.get(edge.to).push(edge.from);
            });

            // BFS to check if we can reach any active node from this node
            const visited = new Set();
            const queue = [nodeId];
            visited.add(nodeId);

            while (queue.length > 0) {
                const current = queue.shift();

                // If we reached an active node, this node is in an active chain
                if (activeNodes.has(current)) {
                    return true;
                }

                // Explore neighbors
                const neighbors = adjacency.get(current) || [];
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push(neighbor);
                    }
                }
            }

            return false;
        }

        /**
         * Calculate the length of the chain that contains a node.
         * Chain length = total number of unique nodes reachable through edges from this node
         * (including the node itself).
         */
        function getChainLength(nodeId, adjacency) {
            const visited = new Set();
            const queue = [nodeId];
            visited.add(nodeId);

            while (queue.length > 0) {
                const current = queue.shift();
                const neighbors = adjacency.get(current) || [];
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push(neighbor);
                    }
                }
            }

            return visited.size;
        }

        /**
         * Build adjacency list for chain length calculations.
         * Uses ALL edges regardless of visibility filters to correctly calculate
         * actual dependency chain lengths.
         */
        function buildChainAdjacency(edges) {
            const adjacency = new Map();

            edges.forEach(edge => {
                if (!adjacency.has(edge.from)) {
                    adjacency.set(edge.from, []);
                }
                if (!adjacency.has(edge.to)) {
                    adjacency.set(edge.to, []);
                }
                // Add bidirectional edges for traversal
                adjacency.get(edge.from).push(edge.to);
                adjacency.get(edge.to).push(edge.from);
            });

            return adjacency;
        }

        /**
         * Time window (in ms) for showing recently completed nodes before they fade out completely.
         */
        const RECENTLY_COMPLETED_WINDOW_MS = 5 * 60 * 1000; // 5 minutes

        /**
         * Time window (in ms) for the recently completed pane in the header.
         * Configurable - default is 15 minutes.
         */
        const RECENTLY_COMPLETED_PANE_WINDOW_MS = 15 * 60 * 1000; // 15 minutes

        /**
         * Check if a node was completed recently (within RECENTLY_COMPLETED_WINDOW_MS).
         * Returns the age in ms if recently completed, or null if not.
         */
        function getCompletedAge(node) {
            if (!node.closed_at) return null;
            const closedTime = new Date(node.closed_at).getTime();
            const now = Date.now();
            const age = now - closedTime;
            return age < RECENTLY_COMPLETED_WINDOW_MS ? age : null;
        }

        /**
         * Calculate opacity for a recently completed node based on age.
         * Returns 1.0 for just-completed nodes, fading to 0.3 at the 5-minute mark.
         */
        function getRecentlyCompletedOpacity(node) {
            const age = getCompletedAge(node);
            if (age === null) return 1.0;  // Not recently completed
            // Linear fade from 1.0 (age=0) to 0.3 (age=5min)
            const progress = age / RECENTLY_COMPLETED_WINDOW_MS;
            return 1.0 - (0.7 * progress);
        }

        /**
         * Filter nodes based on hideCompleted setting.
         * Returns array of nodes that should be visible.
         *
         * When hideCompleted is true:
         * - Hide nodes with status 'done' or 'cancelled'
         * - EXCEPT those in active dependency chains
         * - EXCEPT those completed within the last 5 minutes (shown with fade-out)
         */
        function getVisibleNodes(nodes) {
            // First, filter by node type visibility
            let visible = nodes.filter(node => {
                const nodeType = node.type || 'task';
                return state.nodeTypeFilters[nodeType] !== false;
            });

            if (state.graph.hideCompleted) {
                // Build active node set and prepare edges for chain detection
                const activeNodes = buildActiveNodeSet();
                const edges = state.graph.edges;

                // Filter nodes: keep if not completed, or if in active chain, or if recently completed
                visible = visible.filter(node => {
                    const isCompleted = node.status === 'done' || node.status === 'cancelled';

                    // If not completed, always show it
                    if (!isCompleted) {
                        return true;
                    }

                    // If recently completed (within 5 min), show it with fade effect
                    if (getCompletedAge(node) !== null) {
                        return true;
                    }

                    // If completed, only show if it's in an active chain
                    return isInActiveChain(node.id, activeNodes, edges);
                });
            }

            // Apply chain length filter if enabled (minChainLength > 1)
            if (state.graph.minChainLength > 1) {
                const adjacency = buildChainAdjacency(state.graph.edges);

                // Only keep nodes whose chain length meets the minimum
                visible = visible.filter(node => {
                    const chainLen = getChainLength(node.id, adjacency);
                    return chainLen >= state.graph.minChainLength;
                });
            }

            // Note: Search no longer hides nodes - non-matching nodes are dimmed instead
            // See drawNode() for dimming logic
            return visible;
        }

        function buildGraphData() {
            // Build a map of existing node positions to preserve them on reload
            const existingNodes = new Map();
            state.graph.nodes.forEach(node => {
                existingNodes.set(node.id, { x: node.x, y: node.y });
            });

            // Convert tasks to nodes - preserve positions or place in circular layout
            state.graph.nodes = state.tasks.map((task, index) => {
                const existing = existingNodes.get(task.id);

                if (existing) {
                    // Preserve existing position, but reset velocity to prevent oscillation
                    return {
                        id: task.id,
                        title: task.title,
                        short_name: task.short_name,
                        status: task.status,
                        priority: task.priority,
                        type: task.type || 'task',
                        closed_at: task.closed_at,  // Track when node was completed for fade-out
                        x: existing.x,
                        y: existing.y,
                        vx: 0,
                        vy: 0,
                        radius: 30
                    };
                } else {
                    // New node - place in circular layout in world space
                    const totalNodes = state.tasks.length;
                    const angle = (index / totalNodes) * 2 * Math.PI;
                    const radius = 300; // Initial radius in world units

                    return {
                        id: task.id,
                        title: task.title,
                        short_name: task.short_name,
                        status: task.status,
                        priority: task.priority,
                        type: task.type || 'task',
                        closed_at: task.closed_at,  // Track when node was completed for fade-out
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius,
                        vx: 0,
                        vy: 0,
                        radius: 30  // Node radius in world units
                    };
                }
            });

            // Build edges from API data with edge type metadata
            state.graph.edges = (state.edges || []).map(edge => ({
                from: edge.source,
                to: edge.target,
                edge_type: edge.edge_type,
                bidirectional: edge.bidirectional,
                reason: edge.reason
            }));
        }

        // Start or restart the animation loop (safe to call multiple times)
        function startAnimation() {
            // Reset stability counter when animation is explicitly started
            state.graph.stableFrameCount = 0;
            
            // Only start if not already animating
            if (!state.graph.isAnimating && state.currentView === 'graph') {
                state.graph.isAnimating = true;
                requestAnimationFrame(animateGraph);
            }
        }

        function animateGraph() {
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');
            const { nodes, edges, physics } = state.graph;

            // Update canvas size if window was resized
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }

            // Update animation time for continuous effects
            state.graph.animationTime = performance.now();

            // Update camera pan animation if active
            updatePanAnimation();
            
            // Update pan-through state machine
            updatePanThrough();

            // Clear canvas
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Filter nodes based on hideCompleted + search setting
            const visibleNodes = getVisibleNodes(nodes);
            const visibleNodeIds = new Set(visibleNodes.map(n => n.id));
            state.graph.visibleNodes = visibleNodes;
            state.graph.visibleNodeIds = visibleNodeIds;

            if (visibleNodes.length === 0) {
                renderEmptyState(ctx, 'No matching nodes');
                // Stop animation when no visible nodes
                state.graph.isAnimating = false;
                return;
            }

            // Apply forces (circular gravity system) - only to visible nodes
            applyCircularGravity(visibleNodes, physics);
            applyRepulsionForces(visibleNodes, physics);
            applyEdgeAttraction(visibleNodes, edges, physics);
            updatePositions(visibleNodes, edges, physics, canvas);

            // Continuous follow: track the followed node as it moves
            updateContinuousFollow(canvas);

            // Draw edges (filtered by edge type visibility and node visibility)
            edges.forEach(edge => {
                // Skip edges that are filtered out by type
                if (!state.edgeFilters[edge.edge_type]) return;

                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);

                // Skip edges where either endpoint is hidden
                if (!fromNode || !toNode || !visibleNodeIds.has(edge.from) || !visibleNodeIds.has(edge.to)) {
                    return;
                }

                const style = getEdgeStyle(edge.edge_type);
                drawArrow(ctx, fromNode.x, fromNode.y, toNode.x, toNode.y, canvas, fromNode.radius, toNode.radius, style, edge.bidirectional);
            });

            // Draw visible nodes only
            visibleNodes.forEach(node => {
                drawNode(ctx, node, canvas);
            });

            // Check for stability (all nodes have very low velocity)
            // Don't stabilize if dragging, panning, or pan animation is active
            const hasActiveInteraction = state.graph.draggedNode || 
                                          state.graph.isPanning || 
                                          state.graph.followAnimation;
            
            // Check if any nodes require continuous animation (in_progress tasks, active agents)
            const hasAnimatedNodes = visibleNodes.some(node => 
                (node.status === 'in_progress' && node.type !== 'queue' && node.type !== 'agent' && node.type !== 'doc') ||
                (node.type === 'agent' && node.status === 'active')
            );
            
            if (!hasActiveInteraction && !hasAnimatedNodes) {
                const isStable = visibleNodes.every(node => {
                    const speed = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
                    return speed < state.graph.STABLE_THRESHOLD;
                });
                
                if (isStable) {
                    state.graph.stableFrameCount++;
                    if (state.graph.stableFrameCount >= state.graph.STABLE_FRAMES_REQUIRED) {
                        // Graph is stable - stop animation to save CPU/GPU
                        state.graph.isAnimating = false;
                        return;
                    }
                } else {
                    state.graph.stableFrameCount = 0;
                }
            } else {
                // Reset stability counter during interactions or when animated nodes are present
                state.graph.stableFrameCount = 0;
            }

            // Continue animation if still on graph view
            if (state.currentView === 'graph') {
                requestAnimationFrame(animateGraph);
            } else {
                state.graph.isAnimating = false;
            }
        }

        function applyCircularGravity(nodes, physics) {
            const draggedNode = state.graph.draggedNode;
            const { gravityCenter, gravityStrength } = physics;

            nodes.forEach(node => {
                // Don't apply forces to dragged nodes
                if (node === draggedNode) return;

                const dx = gravityCenter.x - node.x;
                const dy = gravityCenter.y - node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    // Queue nodes are HEAVY - they barely respond to gravity
                    // This makes other nodes move toward them via edge attraction
                    const gravityMultiplier = node.type === 'queue' ? 0.1 : 1.0;
                    const force = gravityStrength * gravityMultiplier;
                    node.vx += (dx / distance) * force;
                    node.vy += (dy / distance) * force;
                }
            });
        }

        function applyEdgeAttraction(nodes, edges, physics) {
            if (!physics.edgeAttractionEnabled) return;

            const draggedNode = state.graph.draggedNode;
            const { springStrength, springRestingLength } = physics;

            edges.forEach(edge => {
                // Skip edges with springiness disabled
                const edgeType = edge.edge_type;
                if (edgeType && !state.edgeSpringFilters[edgeType]) return;

                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                if (!fromNode || !toNode) return;

                // Don't apply to dragged nodes
                if (fromNode === draggedNode && toNode === draggedNode) return;

                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance === 0) return;

                // Bidirectional spring force: applies when compressed OR extended
                // Force increases linearly with deviation from resting length
                const deviation = distance - springRestingLength;
                const force = springStrength * deviation;

                // Spring pulls toward resting length:
                // - If compressed (distance < resting): deviation is negative, pushes apart
                // - If extended (distance > resting): deviation is positive, pulls together
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;

                if (fromNode !== draggedNode) {
                    fromNode.vx += fx;
                    fromNode.vy += fy;
                }
                if (toNode !== draggedNode) {
                    toNode.vx -= fx;
                    toNode.vy -= fy;
                }
            });
        }

        function applyRepulsionForces(nodes, physics) {
            const draggedNode = state.graph.draggedNode;

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const n1 = nodes[i];
                    const n2 = nodes[j];
                    const dx = n2.x - n1.x;
                    const dy = n2.y - n1.y;
                    const distanceSq = dx * dx + dy * dy;
                    if (distanceSq === 0) continue;

                    const force = physics.repulsionStrength / distanceSq;
                    const distance = Math.sqrt(distanceSq);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;

                    // Don't apply forces to dragged nodes
                    if (n1 !== draggedNode) {
                        n1.vx -= fx;
                        n1.vy -= fy;
                    }
                    if (n2 !== draggedNode) {
                        n2.vx += fx;
                        n2.vy += fy;
                    }
                }
            }
        }

        function updatePositions(nodes, edges, physics, canvas) {
            const draggedNode = state.graph.draggedNode;
            const { damping, maxVelocity } = physics;

            // Build set of nodes directly connected to dragged node for higher responsiveness
            const connectedToDragged = new Set();
            if (draggedNode) {
                edges.forEach(edge => {
                    if (edge.from === draggedNode.id) {
                        connectedToDragged.add(edge.to);
                    } else if (edge.to === draggedNode.id) {
                        connectedToDragged.add(edge.from);
                    }
                });
            }

            // Connected nodes get higher max velocity for responsiveness
            const connectedMaxVelocity = maxVelocity * 3;

            nodes.forEach(node => {
                // Freeze dragged node
                if (node === draggedNode) {
                    node.vx = 0;
                    node.vy = 0;
                    return;
                }

                // Apply damping
                node.vx *= damping;
                node.vy *= damping;

                // Cap velocity - higher limit for nodes connected to dragged node
                // Queue nodes have very low max velocity (they're heavy anchors)
                const isConnected = connectedToDragged.has(node.id);
                let velocityLimit = isConnected ? connectedMaxVelocity : maxVelocity;
                if (node.type === 'queue') {
                    velocityLimit = maxVelocity * 0.3; // Queue nodes move very slowly
                }
                const speed = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
                if (speed > velocityLimit) {
                    node.vx = (node.vx / speed) * velocityLimit;
                    node.vy = (node.vy / speed) * velocityLimit;
                }

                // Update position (NO BOUNDARY CLAMPING for infinite canvas)
                node.x += node.vx;
                node.y += node.vy;
            });
        }

        // Format node label with word wrap and truncation
        // Returns array of lines (max 2 lines, max 8 chars per line)
        // NOTE: Uses string length (UTF-16 code units), not grapheme clusters.
        // Emoji/complex Unicode may appear shorter visually than their length suggests.
        function formatNodeLabel(text, maxCharsPerLine = 8, maxLines = 2) {
            if (!text) return [];

            const maxTotal = maxCharsPerLine * maxLines;

            // If text fits on one line, return early
            if (text.length <= maxCharsPerLine) {
                return [text];
            }

            // Truncate if too long overall (with ellipsis)
            if (text.length > maxTotal) {
                text = text.substring(0, maxTotal - 1) + 'â€¦';
            }

            const lines = [];
            let remaining = text;

            while (remaining.length > 0 && lines.length < maxLines) {
                if (remaining.length <= maxCharsPerLine) {
                    lines.push(remaining);
                    break;
                }

                // Try to break at a reasonable point (space, hyphen, underscore)
                let breakPoint = maxCharsPerLine;
                for (let i = maxCharsPerLine - 1; i >= Math.floor(maxCharsPerLine / 2); i--) {
                    if (remaining[i] === ' ' || remaining[i] === '-' || remaining[i] === '_') {
                        breakPoint = i + 1;
                        break;
                    }
                }

                lines.push(remaining.substring(0, breakPoint).trim());
                remaining = remaining.substring(breakPoint).trim();
            }

            return lines;
        }

        // Draw a hexagon path centered at (cx, cy) with the given radius
        function drawHexagonPath(ctx, cx, cy, radius) {
            const sides = 6;
            const angleOffset = Math.PI / 6; // Rotate 30 degrees so flat side is at bottom
            ctx.moveTo(
                cx + radius * Math.cos(angleOffset),
                cy + radius * Math.sin(angleOffset)
            );
            for (let i = 1; i <= sides; i++) {
                const angle = angleOffset + (i * 2 * Math.PI / sides);
                ctx.lineTo(
                    cx + radius * Math.cos(angle),
                    cy + radius * Math.sin(angle)
                );
            }
            ctx.closePath();
        }

        // Draw a diamond (rhombus) path centered at (cx, cy) with the given radius
        function drawDiamondPath(ctx, cx, cy, radius) {
            ctx.moveTo(cx, cy - radius);       // Top
            ctx.lineTo(cx + radius, cy);       // Right
            ctx.lineTo(cx, cy + radius);       // Bottom
            ctx.lineTo(cx - radius, cy);       // Left
            ctx.closePath();
        }

        // Draw a person silhouette path for agent nodes (circle head + semicircle body)
        function drawPersonPath(ctx, cx, cy, radius) {
            const headRadius = radius * 0.4;
            const headY = cy - radius * 0.25;
            const bodyY = cy + radius * 0.15;
            const bodyRadius = radius * 0.7;
            
            // Head (full circle)
            ctx.arc(cx, headY, headRadius, 0, Math.PI * 2);
            
            // Body (semicircle below, flat side up)
            ctx.moveTo(cx + bodyRadius, bodyY);
            ctx.arc(cx, bodyY, bodyRadius, 0, Math.PI);
        }

        // Draw a square path centered at (cx, cy) with the given radius (half-side length)
        function drawSquarePath(ctx, cx, cy, radius) {
            ctx.moveTo(cx - radius, cy - radius);  // Top-left
            ctx.lineTo(cx + radius, cy - radius);  // Top-right
            ctx.lineTo(cx + radius, cy + radius);  // Bottom-right
            ctx.lineTo(cx - radius, cy + radius);  // Bottom-left
            ctx.closePath();
        }

        // Draw a cloud/bubble path centered at (cx, cy) with the given radius
        // Uses overlapping circles to create a puffy cloud shape
        function drawCloudPath(ctx, cx, cy, radius) {
            // Classic cloud shape: a main body with overlapping circular bumps
            // Draw using bezier curves for smooth transitions between bumps
            const w = radius * 1.1;  // Width scale
            const h = radius * 0.75;  // Height scale (slightly flattened)
            
            ctx.moveTo(cx - w, cy + h * 0.3);
            
            // Bottom edge (flat-ish base)
            ctx.quadraticCurveTo(cx - w * 0.5, cy + h * 0.5, cx, cy + h * 0.4);
            ctx.quadraticCurveTo(cx + w * 0.5, cy + h * 0.5, cx + w, cy + h * 0.3);
            
            // Right bump
            ctx.quadraticCurveTo(cx + w * 1.2, cy, cx + w * 0.9, cy - h * 0.3);
            
            // Top-right bump  
            ctx.quadraticCurveTo(cx + w * 0.8, cy - h * 0.8, cx + w * 0.3, cy - h * 0.7);
            
            // Top middle bump (main puffy top)
            ctx.quadraticCurveTo(cx + w * 0.1, cy - h * 1.0, cx - w * 0.2, cy - h * 0.75);
            
            // Top-left bump
            ctx.quadraticCurveTo(cx - w * 0.6, cy - h * 0.9, cx - w * 0.8, cy - h * 0.4);
            
            // Left bump (back to start)
            ctx.quadraticCurveTo(cx - w * 1.2, cy, cx - w, cy + h * 0.3);
            
            ctx.closePath();
        }

        // Draw a rounded rectangle path (document/page shape) centered at (cx, cy)
        // Slightly taller than wide to look like a document page
        function drawDocPath(ctx, cx, cy, radius) {
            const w = radius * 0.85;   // Width (narrower than height)
            const h = radius * 1.1;    // Height (taller, page-like)
            const corner = radius * 0.2;  // Corner radius
            const fold = radius * 0.25;   // Corner fold size
            
            // Start at top-left (after corner radius)
            ctx.moveTo(cx - w + corner, cy - h);
            
            // Top edge (until fold corner)
            ctx.lineTo(cx + w - fold, cy - h);
            
            // Folded corner (dog-ear effect)
            ctx.lineTo(cx + w, cy - h + fold);
            
            // Right edge
            ctx.lineTo(cx + w, cy + h - corner);
            
            // Bottom-right corner (rounded)
            ctx.quadraticCurveTo(cx + w, cy + h, cx + w - corner, cy + h);
            
            // Bottom edge
            ctx.lineTo(cx - w + corner, cy + h);
            
            // Bottom-left corner (rounded)
            ctx.quadraticCurveTo(cx - w, cy + h, cx - w, cy + h - corner);
            
            // Left edge
            ctx.lineTo(cx - w, cy - h + corner);
            
            // Top-left corner (rounded)
            ctx.quadraticCurveTo(cx - w, cy - h, cx - w + corner, cy - h);
            
            ctx.closePath();
        }

        // Check if a node is in the queue (has a 'queued' edge to a queue node)
        function isNodeQueued(nodeId) {
            // Check state.edges (API data) directly, not state.graph.edges
            // state.graph.edges is only populated when the graph view is rendered
            return (state.edges || []).some(edge => 
                edge.source === nodeId && edge.edge_type === 'queued'
            );
        }

        // Get the reason(s) why a node is blocked
        // Returns an array of reasons from depends_on edges pointing to unclosed tasks
        function getBlockingReasons(nodeId) {
            const reasons = [];
            const edges = (state.edges || []).filter(edge => 
                edge.source === nodeId && 
                (edge.edge_type === 'depends_on' || edge.edge_type === 'blocks')
            );
            
            for (const edge of edges) {
                // Find the target task to check if it's still open (blocking)
                const targetTask = state.tasks.find(t => t.id === edge.target);
                if (targetTask && targetTask.status !== 'done' && targetTask.status !== 'cancelled') {
                    if (edge.reason) {
                        reasons.push(edge.reason);
                    } else {
                        // If no explicit reason, show what it's blocked by
                        const targetTitle = targetTask.short_name || targetTask.title;
                        reasons.push(`Waiting on: ${targetTitle}`);
                    }
                }
            }
            return reasons;
        }

        function drawNode(ctx, node, canvas) {
            const isHovered = node === state.graph.hoveredNode;
            const isDragging = node === state.graph.draggedNode;
            const isSelected = node === state.graph.selectedNode;
            
            // Check if node matches current highlight filter
            const matchesFilter = nodeMatchesFilter(node);
            const highlightDimmed = state.graph.highlightFilter && !matchesFilter;
            
            // Check if node matches current search query (dim non-matching instead of hiding)
            const normalizedQuery = normalizeSearchQuery(state.graph.searchQuery);
            const matchesSearch = nodeMatchesSearch(node, normalizedQuery);
            const searchDimmed = normalizedQuery && !matchesSearch;
            
            // Node is dimmed if either filter or search doesn't match
            const isDimmed = highlightDimmed || searchDimmed;

            // Transform world coordinates to screen coordinates
            const screenPos = worldToScreen(node.x, node.y, canvas);
            const zoom = state.graph.viewport.zoom;
            const radius = node.radius * zoom;

            // Node colors based on status
            const colors = {
                'pending': '#5bc0de',
                'in_progress': '#f0ad4e',
                'blocked': '#d9534f',
                'done': '#5cb85c'
            };
            
            // Bug colors (reddish tones) - use CSS variables
            const bugColors = {
                'pending': '#e07878',      // --bug-pending
                'in_progress': '#d95050',  // --bug-in-progress
                'blocked': '#b33a3a',      // --bug-blocked
                'done': '#8fbc8f'          // --bug-done
            };
            
            // Idea colors (deeper purple) - use CSS variables
            const ideaColors = {
                'pending': '#8b5fc9',      // --idea-pending
                'in_progress': '#7a4db8',  // --idea-in-progress
                'blocked': '#5c3a8a',      // --idea-blocked
                'done': '#8fbc8f'          // --idea-done
            };
            
            // Queue color (teal) - queues don't have status, always same color
            const queueColor = '#20b2aa';  // --queue-color
            
            // Agent colors (cyan/electric blue) - based on agent status
            const agentColors = {
                'active': '#00d4ff',       // Bright cyan for active
                'idle': '#6bb3c9',         // Muted cyan for idle
                'stale': '#4a6670'         // Dark gray-blue for stale
            };
            
            // Doc colors (by doc_type) - use CSS variables
            const docColors = {
                'prd': '#4a90e2',           // --doc-prd (blue)
                'note': '#e8b84a',          // --doc-note (gold)
                'handoff': '#e87d4a'        // --doc-handoff (orange)
            };
            
            // Select color palette based on node type
            let colorPalette = colors;
            let color;
            if (node.type === 'queue') {
                color = queueColor;
            } else if (node.type === 'bug') {
                colorPalette = bugColors;
                color = colorPalette[node.status] || '#4a90e2';
            } else if (node.type === 'idea') {
                colorPalette = ideaColors;
                color = colorPalette[node.status] || '#4a90e2';
            } else if (node.type === 'agent') {
                colorPalette = agentColors;
                color = colorPalette[node.status] || '#00d4ff';
            } else if (node.type === 'doc') {
                color = docColors[node.doc_type] || '#4a90e2';
            } else {
                color = colorPalette[node.status] || '#4a90e2';
            }
            
            // Apply dimming for filtered-out nodes, and fade-out for recently completed nodes
            let opacity = 1.0;
            if (isDimmed) {
                opacity = 0.3;
            } else {
                // Apply fade-out effect for recently completed nodes (when hideCompleted is on)
                const isCompleted = node.status === 'done' || node.status === 'cancelled';
                if (state.graph.hideCompleted && isCompleted) {
                    opacity = getRecentlyCompletedOpacity(node);
                }
            }
            ctx.globalAlpha = opacity;

            // Draw selection highlight (persistent)
            if (isSelected) {
                ctx.beginPath();
                if (node.type === 'queue') {
                    drawHexagonPath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else if (node.type === 'agent') {
                    drawPersonPath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else if (node.type === 'doc') {
                    drawDocPath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 10 * zoom, 0, Math.PI * 2);
                }
                ctx.strokeStyle = '#f0ad4e';
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.fillStyle = 'rgba(240, 173, 78, 0.15)';
                ctx.fill();
            }
            
            // Draw temporary highlight (pulse animation when jumping to a node from log)
            const isTempHighlighted = state.graph.tempHighlightNode === node.id;
            if (isTempHighlighted && state.graph.tempHighlightStart) {
                const elapsed = performance.now() - state.graph.tempHighlightStart;
                const duration = state.graph.tempHighlightDuration || 1500;
                
                if (elapsed < duration) {
                    // Pulse effect: starts strong, fades out
                    const progress = elapsed / duration;
                    const pulsePhase = Math.sin(progress * Math.PI * 3); // 3 pulses
                    const pulseOpacity = (1 - progress) * 0.6 * Math.max(0, pulsePhase);
                    const pulseRadius = radius + (15 + 10 * pulsePhase) * zoom;
                    
                    ctx.beginPath();
                    if (node.type === 'queue') {
                        drawHexagonPath(ctx, screenPos.x, screenPos.y, pulseRadius);
                    } else if (node.type === 'agent') {
                        drawPersonPath(ctx, screenPos.x, screenPos.y, pulseRadius);
                    } else if (node.type === 'bug') {
                        drawSquarePath(ctx, screenPos.x, screenPos.y, pulseRadius);
                    } else if (node.type === 'idea') {
                        drawCloudPath(ctx, screenPos.x, screenPos.y, pulseRadius);
                    } else if (node.type === 'doc') {
                        drawDocPath(ctx, screenPos.x, screenPos.y, pulseRadius);
                    } else {
                        ctx.arc(screenPos.x, screenPos.y, pulseRadius, 0, Math.PI * 2);
                    }
                    ctx.strokeStyle = `rgba(52, 152, 219, ${pulseOpacity})`;
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    ctx.fillStyle = `rgba(52, 152, 219, ${pulseOpacity * 0.3})`;
                    ctx.fill();
                } else {
                    // Animation complete, clear the highlight
                    state.graph.tempHighlightNode = null;
                    state.graph.tempHighlightStart = null;
                }
            }

            // Draw drag highlight (active)
            if (isDragging) {
                ctx.beginPath();
                if (node.type === 'queue') {
                    drawHexagonPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'agent') {
                    drawPersonPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'doc') {
                    drawDocPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 8 * zoom, 0, Math.PI * 2);
                }
                ctx.fillStyle = 'rgba(74, 144, 226, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            // Draw hover highlight
            else if (isHovered) {
                ctx.beginPath();
                if (node.type === 'queue') {
                    drawHexagonPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'agent') {
                    drawPersonPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'doc') {
                    drawDocPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 8 * zoom, 0, Math.PI * 2);
                }
                ctx.fillStyle = 'rgba(74, 144, 226, 0.2)';
                ctx.fill();
                ctx.strokeStyle = '#6aa8f0';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // Draw queued indicator (teal glow for tasks in the queue)
            const isQueued = node.type !== 'queue' && node.type !== 'agent' && node.type !== 'doc' && isNodeQueued(node.id);
            if (isQueued) {
                ctx.beginPath();
                if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 6 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 6 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 6 * zoom, 0, Math.PI * 2);
                }
                ctx.strokeStyle = '#20b2aa';  // --queue-color
                ctx.lineWidth = 3;
                ctx.stroke();
                // Add subtle glow effect
                ctx.beginPath();
                if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 4 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 4 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 4 * zoom, 0, Math.PI * 2);
                }
                ctx.fillStyle = 'rgba(32, 178, 170, 0.15)';  // --queue-color with transparency
                ctx.fill();
            }

            // Draw dotted yellow border for task nodes (visual distinction from bugs/ideas)
            // Only for task type nodes that are not in_progress (in_progress has animated rings)
            if (node.type === 'task' && node.status !== 'in_progress') {
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, radius + 4 * zoom, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.7)';  // Gold/yellow color
                ctx.lineWidth = 2 * zoom;
                ctx.setLineDash([4 * zoom, 4 * zoom]);  // Dotted pattern
                ctx.stroke();
                ctx.setLineDash([]);  // Reset line dash
            }

            // Draw animated spiral for active agent nodes (design: dark blue #1e3a5f, light grey #d0d0d0)
            // Performant CSS-style animation using canvas - single spiral that rotates smoothly
            if (node.type === 'agent' && node.status === 'active') {
                const animTime = state.graph.animationTime;
                const rotationSpeed = 0.002; // radians per ms - smooth rotation
                const spiralRadius = radius * 0.6;
                
                ctx.save();
                ctx.translate(screenPos.x, screenPos.y);
                ctx.rotate(animTime * rotationSpeed);
                
                // Draw spiral arms using arcs - creates a spinning effect
                const armCount = 3;
                const armWidth = 3 * zoom;
                
                for (let arm = 0; arm < armCount; arm++) {
                    const baseAngle = (arm * Math.PI * 2) / armCount;
                    
                    // Gradient from dark blue to light grey along the arm
                    const gradient = ctx.createLinearGradient(
                        Math.cos(baseAngle) * spiralRadius * 0.3,
                        Math.sin(baseAngle) * spiralRadius * 0.3,
                        Math.cos(baseAngle) * spiralRadius,
                        Math.sin(baseAngle) * spiralRadius
                    );
                    gradient.addColorStop(0, '#1e3a5f'); // Dark blue center
                    gradient.addColorStop(1, '#d0d0d0'); // Light grey outer
                    
                    ctx.beginPath();
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = armWidth;
                    ctx.lineCap = 'round';
                    
                    // Draw curved arm using quadratic bezier
                    const startR = spiralRadius * 0.2;
                    const endR = spiralRadius;
                    const curveAngle = Math.PI * 0.5; // How much the arm curves
                    
                    ctx.moveTo(
                        Math.cos(baseAngle) * startR,
                        Math.sin(baseAngle) * startR
                    );
                    ctx.quadraticCurveTo(
                        Math.cos(baseAngle + curveAngle * 0.5) * spiralRadius * 0.7,
                        Math.sin(baseAngle + curveAngle * 0.5) * spiralRadius * 0.7,
                        Math.cos(baseAngle + curveAngle) * endR,
                        Math.sin(baseAngle + curveAngle) * endR
                    );
                    ctx.stroke();
                }
                
                ctx.restore();
            }

            // Draw active task indicator: counter-rotating hatched rings (Ghost in the Shell style)
            // Only for in_progress tasks/bugs/ideas (not queues/agents/docs)
            if (node.status === 'in_progress' && node.type !== 'queue' && node.type !== 'agent' && node.type !== 'doc') {
                const animTime = state.graph.animationTime;
                const rotationSpeed = 0.001; // radians per ms
                const outerRingRadius = radius + 14 * zoom;
                const innerRingRadius = radius + 8 * zoom;
                const ringWidth = 2.5 * zoom;
                const hatchCount = 12;
                const hatchLength = Math.PI / 18; // Arc length of each hatch
                
                // Outer ring - rotates clockwise
                ctx.save();
                ctx.translate(screenPos.x, screenPos.y);
                ctx.rotate(animTime * rotationSpeed);
                ctx.strokeStyle = 'rgba(240, 173, 78, 0.8)'; // Orange-amber like in_progress color
                ctx.lineWidth = ringWidth;
                ctx.lineCap = 'round';
                for (let i = 0; i < hatchCount; i++) {
                    const startAngle = (i * Math.PI * 2) / hatchCount;
                    ctx.beginPath();
                    ctx.arc(0, 0, outerRingRadius, startAngle, startAngle + hatchLength);
                    ctx.stroke();
                }
                ctx.restore();
                
                // Inner ring - rotates counter-clockwise
                ctx.save();
                ctx.translate(screenPos.x, screenPos.y);
                ctx.rotate(-animTime * rotationSpeed * 1.5); // Faster and opposite direction
                ctx.strokeStyle = 'rgba(255, 200, 100, 0.6)'; // Lighter orange-gold
                ctx.lineWidth = ringWidth * 0.8;
                ctx.lineCap = 'round';
                for (let i = 0; i < hatchCount; i++) {
                    const startAngle = (i * Math.PI * 2) / hatchCount + Math.PI / hatchCount; // Offset from outer ring
                    ctx.beginPath();
                    ctx.arc(0, 0, innerRingRadius, startAngle, startAngle + hatchLength * 0.8);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // Draw node shape (hexagon for queue, person for agent, square for bug, cloud for idea, doc for doc, circle for others)
            ctx.beginPath();
            if (node.type === 'queue') {
                drawHexagonPath(ctx, screenPos.x, screenPos.y, radius);
            } else if (node.type === 'agent') {
                drawPersonPath(ctx, screenPos.x, screenPos.y, radius);
            } else if (node.type === 'bug') {
                drawSquarePath(ctx, screenPos.x, screenPos.y, radius);
            } else if (node.type === 'idea') {
                drawCloudPath(ctx, screenPos.x, screenPos.y, radius);
            } else if (node.type === 'doc') {
                drawDocPath(ctx, screenPos.x, screenPos.y, radius);
            } else {
                ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
            }
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = (isHovered || isDragging) ? '#ffffff' : '#e8edf3';
            ctx.lineWidth = (isHovered || isDragging) ? 3 : 2;
            ctx.stroke();

            // Draw text - show short_name if set, with task ID below in smaller font
            // Skip text for agent nodes (person silhouette is self-explanatory, ID shown on hover/tooltip)
            if (node.type !== 'agent') {
                ctx.fillStyle = '#1a2332';
                const baseFontSize = 12 * Math.max(0.8, Math.min(1.5, zoom));
                const smallFontSize = baseFontSize * 0.75;
                ctx.textAlign = 'center';

                if (node.short_name) {
                    // Format short_name with word wrap
                    const labelLines = formatNodeLabel(node.short_name, 8, 2);
                    const lineHeight = baseFontSize * 1.2;
                    
                    // Calculate total height for centering
                    const totalLines = labelLines.length + 1; // +1 for ID below
                    const totalHeight = (totalLines - 1) * lineHeight;
                    const startY = screenPos.y - totalHeight / 2 + baseFontSize / 2;
                    
                    // Draw short_name lines
                    ctx.font = (isHovered || isDragging) ? `bold ${baseFontSize}px sans-serif` : `${baseFontSize}px sans-serif`;
                    ctx.textBaseline = 'middle';
                    labelLines.forEach((line, i) => {
                        ctx.fillText(line, screenPos.x, startY + i * lineHeight);
                    });
                    
                    // Draw task ID below in smaller font
                    ctx.font = `${smallFontSize}px sans-serif`;
                    ctx.fillStyle = 'rgba(26, 35, 50, 0.7)';
                    ctx.fillText(node.id, screenPos.x, startY + labelLines.length * lineHeight);
                } else {
                    // No short_name - just show task ID centered
                    ctx.font = (isHovered || isDragging) ? `bold ${baseFontSize}px sans-serif` : `${baseFontSize}px sans-serif`;
                    ctx.textBaseline = 'middle';
                    ctx.fillText(node.id, screenPos.x, screenPos.y);
                }
            }
            
            // Reset globalAlpha after drawing
            ctx.globalAlpha = 1.0;
        }

        // Get edge style based on edge type
        function getEdgeStyle(edgeType) {
            const styles = getComputedStyle(document.documentElement);
            switch (edgeType) {
                case 'depends_on':
                case 'blocks':
                    return {
                        color: styles.getPropertyValue('--edge-blocking').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
                case 'related_to':
                case 'caused_by':
                case 'duplicates':
                case 'supersedes':
                    return {
                        color: styles.getPropertyValue('--edge-informational').trim(),
                        dashed: true,
                        lineWidth: 1.5
                    };
                case 'fixes':
                case 'tests':
                    return {
                        color: styles.getPropertyValue('--edge-fixes').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
                case 'parent_of':
                case 'child_of':
                    return {
                        color: styles.getPropertyValue('--edge-hierarchy').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
                case 'queued':
                    return {
                        color: styles.getPropertyValue('--edge-queued').trim(),
                        dashed: true,
                        lineWidth: 2
                    };
                case 'working_on':
                    return {
                        color: styles.getPropertyValue('--edge-agent').trim() || '#00d4ff',
                        dashed: true,  // Dotted line for active work
                        lineWidth: 3  // Thicker to stand out
                    };
                case 'worked_on':
                    return {
                        color: styles.getPropertyValue('--edge-agent-past').trim() || '#6b7a8a',
                        dashed: false,  // Solid grey line (like a dead/historical link)
                        lineWidth: 2
                    };
                case 'pinned':
                    return {
                        color: styles.getPropertyValue('--edge-pinned').trim() || '#5cb85c',
                        dashed: false,  // Solid line for important connections
                        lineWidth: 3    // Thicker to emphasize importance
                    };
                default:
                    return {
                        color: styles.getPropertyValue('--edge-default').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
            }
        }

        function drawArrow(ctx, x1, y1, x2, y2, canvas, fromRadius = 30, toRadius = 30, style = null, bidirectional = false) {
            // Calculate the angle of the line
            const dx = x2 - x1;
            const dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            const distance = Math.sqrt(dx * dx + dy * dy);

            // If nodes are overlapping, skip drawing
            if (distance < fromRadius + toRadius) return;

            // Calculate start point at edge of fromNode
            const startX = x1 + Math.cos(angle) * fromRadius;
            const startY = y1 + Math.sin(angle) * fromRadius;

            // Calculate end point at edge of toNode
            const endX = x2 - Math.cos(angle) * toRadius;
            const endY = y2 - Math.sin(angle) * toRadius;

            // Transform to screen coordinates
            const p1 = worldToScreen(startX, startY, canvas);
            const p2 = worldToScreen(endX, endY, canvas);

            // Apply style
            const defaultStyle = { color: getComputedStyle(document.documentElement).getPropertyValue('--edge-default').trim(), dashed: false, lineWidth: 2 };
            const edgeStyle = style || defaultStyle;
            ctx.strokeStyle = edgeStyle.color;
            ctx.fillStyle = edgeStyle.color;
            ctx.lineWidth = edgeStyle.lineWidth * state.graph.viewport.zoom;

            // Set dash pattern for informational edges
            if (edgeStyle.dashed) {
                ctx.setLineDash([6, 4]);
            } else {
                ctx.setLineDash([]);
            }

            // Calculate midpoint for arrow head
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;

            const headLength = 10 * state.graph.viewport.zoom;
            const screenAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

            // Draw line from start to end
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();

            // Reset dash pattern for arrow heads
            ctx.setLineDash([]);

            // Arrow head at midpoint (pointing from source to target)
            ctx.beginPath();
            ctx.moveTo(midX, midY);
            ctx.lineTo(
                midX - headLength * Math.cos(screenAngle - Math.PI / 6),
                midY - headLength * Math.sin(screenAngle - Math.PI / 6)
            );
            ctx.lineTo(
                midX - headLength * Math.cos(screenAngle + Math.PI / 6),
                midY - headLength * Math.sin(screenAngle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();

            // Draw second arrow head for bidirectional edges (pointing from target to source)
            if (bidirectional) {
                const reverseAngle = screenAngle + Math.PI;
                ctx.beginPath();
                ctx.moveTo(midX, midY);
                ctx.lineTo(
                    midX - headLength * Math.cos(reverseAngle - Math.PI / 6),
                    midY - headLength * Math.sin(reverseAngle - Math.PI / 6)
                );
                ctx.lineTo(
                    midX - headLength * Math.cos(reverseAngle + Math.PI / 6),
                    midY - headLength * Math.sin(reverseAngle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fill();
            }
        }

        // Unified render function for all node types (tasks, bugs, ideas, tests, docs)
        function renderNodes() {
            const list = document.getElementById('nodes-list');
            const searchQuery = viewSearch.nodes;
            const showClosed = includeClosed.nodes;
            const typeFilter = nodesTypeFilter;
            const readyIds = new Set((state.ready || []).map(t => t.id));
            
            // Collect all nodes from different sources
            let allNodes = [];
            
            // Tasks and Bugs (from state.tasks)
            if (!typeFilter || typeFilter === 'task' || typeFilter === 'bug') {
                (state.tasks || []).forEach(t => {
                    if (t.type === 'task' || t.type === 'bug') {
                        if (typeFilter && typeFilter !== t.type) return;
                        allNodes.push({ ...t, nodeType: t.type });
                    }
                });
            }
            
            // Ideas (from state.ideas)
            if (!typeFilter || typeFilter === 'idea') {
                (state.ideas || []).forEach(idea => {
                    allNodes.push({ ...idea, nodeType: 'idea' });
                });
            }
            
            // Tests (from state.tests)
            if (!typeFilter || typeFilter === 'test') {
                (state.tests || []).forEach(test => {
                    allNodes.push({ ...test, nodeType: 'test' });
                });
            }
            
            // Docs (from state.docs)
            if (!typeFilter || typeFilter === 'doc') {
                (state.docs || []).forEach(doc => {
                    allNodes.push({ ...doc, nodeType: 'doc' });
                });
            }
            
            // Filter by closed status
            if (!showClosed) {
                allNodes = allNodes.filter(node => {
                    if (node.nodeType === 'task' || node.nodeType === 'bug') {
                        return node.status !== 'done' && node.status !== 'cancelled';
                    } else if (node.nodeType === 'idea') {
                        return node.status === 'seed' || node.status === 'germinating';
                    }
                    // Tests and docs don't have a closed state
                    return true;
                });
            }
            
            // Apply search filter
            if (searchQuery) {
                allNodes = allNodes.filter(node => itemMatchesViewSearch(node, searchQuery));
            }
            
            // Apply tag filter
            const tagFilter = nodesTagFilter;
            if (tagFilter) {
                allNodes = allNodes.filter(node => {
                    const nodeTags = node.tags || [];
                    return nodeTags.includes(tagFilter);
                });
            }
            
            // Sort: open first, ready first, by priority, then by ID
            allNodes.sort((a, b) => {
                // Type ordering: tasks/bugs first, then ideas, then tests, then docs
                const typeOrder = { task: 0, bug: 1, idea: 2, test: 3, doc: 4 };
                if (typeOrder[a.nodeType] !== typeOrder[b.nodeType]) {
                    return typeOrder[a.nodeType] - typeOrder[b.nodeType];
                }
                
                // For tasks/bugs: open first, ready first, priority
                if (a.nodeType === 'task' || a.nodeType === 'bug') {
                    const aOpen = a.status !== 'done' && a.status !== 'cancelled';
                    const bOpen = b.status !== 'done' && b.status !== 'cancelled';
                    if (aOpen !== bOpen) return bOpen - aOpen;
                    
                    const aReady = readyIds.has(a.id);
                    const bReady = readyIds.has(b.id);
                    if (aReady !== bReady) return bReady - aReady;
                    
                    if ((a.priority ?? 2) !== (b.priority ?? 2)) {
                        return (a.priority ?? 2) - (b.priority ?? 2);
                    }
                }
                
                // For ideas: open first
                if (a.nodeType === 'idea') {
                    const aOpen = a.status === 'seed' || a.status === 'germinating';
                    const bOpen = b.status === 'seed' || b.status === 'germinating';
                    if (aOpen !== bOpen) return bOpen - aOpen;
                }
                
                return a.id.localeCompare(b.id);
            });
            
            if (allNodes.length === 0) {
                const filterDesc = typeFilter ? typeFilter + 's' : 'nodes';
                list.innerHTML = searchQuery 
                    ? `<div class="empty-state">No ${filterDesc} match your search</div>`
                    : `<div class="empty-state">No open ${filterDesc}</div>`;
                return;
            }
            
            list.innerHTML = allNodes.map(node => renderNodeCard(node, readyIds)).join('');
            
            // Attach event handlers to queue toggle buttons
            list.querySelectorAll('.card-queue-toggle').forEach(btn => {
                btn.addEventListener('click', handleCardQueueToggle);
            });
            
            // Attach event handlers to jump buttons
            list.querySelectorAll('.card-jump-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const nodeId = e.currentTarget.getAttribute('data-task-id');
                    state.graph.autoFollow = false;
                    cancelFocusPeriod();  // Cancel any active focus period
                    updateAutoFollowDisplay();
                    switchView('graph');
                    panToNode(nodeId, true);
                    const graphNode = state.graph.nodes.find(n => n.id === nodeId);
                    if (graphNode) {
                        state.graph.selectedNode = graphNode;
                        showInfoPanel(graphNode);
                    }
                });
            });
        }
        
        // Render a single node card based on its type
        function renderNodeCard(node, readyIds) {
            switch (node.nodeType) {
                case 'task':
                case 'bug':
                    return renderTaskBugCard(node, readyIds);
                case 'idea':
                    return renderIdeaCard(node);
                case 'test':
                    return renderTestCard(node);
                case 'doc':
                    return renderDocCard(node);
                default:
                    return '';
            }
        }
        
        function renderTaskBugCard(node, readyIds) {
            const isQueued = isNodeQueued(node.id);
            const isReady = readyIds.has(node.id);
            const isClosed = node.status === 'done' || node.status === 'cancelled';
            const isBlocked = !isClosed && (node.status === 'blocked' || !isReady);
            const isBug = node.nodeType === 'bug';
            const blockingReasons = isBlocked ? getBlockingReasons(node.id) : [];
            const reasonText = blockingReasons.length > 0 ? blockingReasons[0] : '';
            
            return `
            <div class="card ${isBlocked ? 'card-blocked' : ''} ${isClosed ? 'card-closed' : ''}">
                ${isClosed ? `<div class="closed-banner">âœ“ ${node.status === 'done' ? (isBug ? 'Fixed' : 'Done') : 'Cancelled'}</div>` : ''}
                ${isBlocked ? `<div class="blocked-banner">ðŸš« Blocked${reasonText ? `<div class="blocked-reason" title="${escapeHtml(reasonText)}">${escapeHtml(reasonText)}</div>` : ''}</div>` : ''}
                <div class="card-header">
                    <div class="card-title">${isBug ? 'ðŸ› ' : ''}${escapeHtml(node.title)}</div>
                    <div class="card-actions">
                        <button class="card-jump-btn" data-task-id="${node.id}" title="Jump to node on graph">
                            ðŸ“
                        </button>
                        ${!isClosed ? `<button class="card-queue-toggle ${isQueued ? 'active' : ''}" 
                                data-task-id="${node.id}" 
                                title="${isQueued ? 'Remove from queue' : 'Add to queue'}">
                        </button>` : ''}
                    </div>
                </div>
                ${node.description ? `<div class="card-description">${escapeHtml(node.description)}</div>` : ''}
                <div class="card-meta">
                    <span class="badge badge-priority-${node.priority ?? 2}">P${node.priority ?? 2}</span>
                    <span class="badge" style="background: var(--bg-tertiary)">${node.id}</span>
                    ${(node.tags || []).map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
                </div>
            </div>`;
        }
        
        function renderIdeaCard(idea) {
            const isClosed = idea.status !== 'seed' && idea.status !== 'germinating';
            const statusLabel = idea.status === 'seed' ? 'ðŸŒ± Seed' 
                : idea.status === 'germinating' ? 'ðŸŒ¿ Germinating'
                : idea.status === 'promoted' ? 'ðŸš€ Promoted'
                : idea.status === 'wilted' ? 'ðŸ¥€ Wilted'
                : idea.status;
            
            return `
            <div class="card ${isClosed ? 'card-closed' : ''}">
                ${isClosed ? `<div class="closed-banner">âœ“ ${idea.status === 'promoted' ? 'Promoted' : 'Wilted'}</div>` : ''}
                <div class="card-header">
                    <div class="card-title">ðŸ’¡ ${escapeHtml(idea.title)}</div>
                    <div class="card-actions">
                        <button class="card-jump-btn" data-task-id="${idea.id}" title="Jump to node on graph">
                            ðŸ“
                        </button>
                    </div>
                </div>
                ${idea.description ? `<div class="card-description">${escapeHtml(idea.description)}</div>` : ''}
                <div class="card-meta">
                    <span class="badge" style="background: var(--idea-${idea.status === 'seed' || idea.status === 'germinating' ? idea.status : 'done'})">${statusLabel}</span>
                    <span class="badge" style="background: var(--bg-tertiary)">${idea.id}</span>
                    ${(idea.tags || []).map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
                </div>
            </div>`;
        }
        
        function renderTestCard(test) {
            return `
            <div class="card">
                <div class="card-header">
                    <div class="card-title">ðŸ§ª ${escapeHtml(test.name)}</div>
                    <div class="card-actions">
                        <button class="card-jump-btn" data-task-id="${test.id}" title="Jump to node on graph">
                            ðŸ“
                        </button>
                    </div>
                </div>
                <div class="card-meta">
                    <span class="badge" style="background: var(--bg-tertiary)">${test.id}</span>
                    <span class="badge ${test.last_status === 'passed' ? 'badge-status-done' : 'badge-status-blocked'}">
                        ${test.last_status || 'Not run'}
                    </span>
                </div>
            </div>`;
        }
        
        function renderDocCard(doc) {
            function getDocTypeLabel(docType) {
                switch (docType) {
                    case 'prd': return { label: 'ðŸ“‹ PRD', color: 'var(--accent-blue)' };
                    case 'note': return { label: 'ðŸ“ Note', color: 'var(--info)' };
                    case 'handoff': return { label: 'ðŸ”„ Handoff', color: 'var(--warning)' };
                    default: return { label: docType, color: 'var(--bg-tertiary)' };
                }
            }
            
            function countLinkedEntities(docId) {
                return state.edges.filter(e => 
                    (e.source === docId || e.target === docId) && 
                    e.edge_type === 'pinned'
                ).length;
            }
            
            const typeInfo = getDocTypeLabel(doc.doc_type);
            const linkedCount = countLinkedEntities(doc.id);
            const summaryDirty = doc.summary_dirty;
            const summaryPreview = (doc.summary || '').split('\n').filter(l => l.trim()).slice(0, 1).join('').substring(0, 200);
            
            return `
            <div class="card" data-doc-id="${escapeHtml(doc.id)}" onclick="openDocViewer('${escapeHtml(doc.id)}')">
                <div class="card-header">
                    <div class="card-title">${escapeHtml(doc.title)}${summaryDirty ? ' <span style="color: var(--warning)" title="Summary needs update">âš ï¸</span>' : ''}</div>
                    <div class="card-actions">
                        <button class="card-jump-btn" data-task-id="${doc.id}" title="Jump to node on graph" onclick="event.stopPropagation()">
                            ðŸ“
                        </button>
                    </div>
                </div>
                ${summaryPreview ? `<div class="card-description">${escapeHtml(summaryPreview)}${summaryPreview.length >= 200 ? 'â€¦' : ''}</div>` : (doc.description ? `<div class="card-description">${escapeHtml(doc.description)}</div>` : '')}
                <div class="card-meta">
                    <span class="badge" style="background: ${typeInfo.color}">${typeInfo.label}</span>
                    <span class="badge" style="background: var(--bg-tertiary)">${doc.id}</span>
                    ${linkedCount > 0 ? `<span class="badge" style="background: var(--edge-hierarchy)">ðŸ”— ${linkedCount}</span>` : ''}
                    ${(doc.tags || []).map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
                </div>
            </div>`;
        }

        async function handleCardQueueToggle(event) {
            event.stopPropagation();
            const btn = event.currentTarget;
            const taskId = btn.dataset.taskId;
            
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/queue/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ node_id: taskId })
                });

                const result = await response.json();
                
                if (result.success) {
                    const isQueued = result.queued;
                    btn.classList.toggle('active', isQueued);
                    btn.title = isQueued ? 'Remove from queue' : 'Add to queue';
                    showToast(result.message, 'success');
                    // Refresh data to update edges and visual state
                    await loadData();
                } else {
                    showToast(result.error || 'Failed to toggle queue', 'error');
                }
            } catch (err) {
                showToast('Failed to toggle queue: ' + err.message, 'error');
            } finally {
                btn.disabled = false;
            }
        }

        /**
         * Compute agent activity statistics from log entries.
         * @param {string} agentName - The agent's name
         * @param {Date} startedAt - When the agent started
         * @returns {Object} Statistics: duration, successRate, topActions, recentEntries
         */
        function computeAgentStats(agentName, startedAt) {
            const log = state.log || [];
            
            // Filter log entries for this agent
            const agentEntries = log.filter(entry => entry.user === agentName);
            
            // Compute duration
            const now = new Date();
            const durationMs = now - startedAt;
            const durationMinutes = Math.floor(durationMs / 60000);
            const durationHours = Math.floor(durationMinutes / 60);
            const durationDays = Math.floor(durationHours / 24);
            
            let durationStr;
            if (durationDays > 0) {
                durationStr = `${durationDays}d ${durationHours % 24}h`;
            } else if (durationHours > 0) {
                durationStr = `${durationHours}h ${durationMinutes % 60}m`;
            } else {
                durationStr = `${durationMinutes}m`;
            }
            
            // Compute success rate
            const totalCommands = agentEntries.length;
            const failedCommands = agentEntries.filter(e => e.success === false).length;
            const successfulCommands = totalCommands - failedCommands;
            const successRate = totalCommands > 0 
                ? Math.round((successfulCommands / totalCommands) * 100) 
                : 100;
            
            // Compute top actions (most common commands)
            const actionCounts = {};
            agentEntries.forEach(entry => {
                const command = entry.command || entry.action || 'unknown';
                actionCounts[command] = (actionCounts[command] || 0) + 1;
            });
            
            const topActions = Object.entries(actionCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([action, count]) => ({ action, count }));
            
            // Get recent entries for timeline (last 20)
            const recentEntries = agentEntries.slice(0, 20);
            
            return {
                duration: durationStr,
                successRate,
                failedCommands,
                totalCommands,
                topActions,
                recentEntries
            };
        }

        /**
         * Toggle the expandable agent timeline.
         */
        function toggleAgentTimeline(agentName) {
            const toggle = document.querySelector(`.agent-timeline-toggle[data-agent="${agentName}"]`);
            const content = document.querySelector(`.agent-timeline-content[data-agent="${agentName}"]`);
            if (toggle && content) {
                toggle.classList.toggle('expanded');
                content.classList.toggle('expanded');
            }
        }

        function renderAgents() {
            const list = document.getElementById('agents-list');
            const activityLog = document.getElementById('agents-activity-log');
            
            if (!state.agents || state.agents.length === 0) {
                list.innerHTML = '<div class="empty-state">No agents registered</div>';
                activityLog.innerHTML = '<div class="empty-state">No agent activity</div>';
                return;
            }
            list.innerHTML = state.agents.map(agent => {
                const startedAt = new Date(agent.started_at);
                const lastActivity = new Date(agent.last_activity_at).toLocaleString();
                const stats = computeAgentStats(agent.name, startedAt);
                
                const tasksHtml = agent.tasks && agent.tasks.length > 0 
                    ? agent.tasks.map(t => `<span class="task-link" data-node-id="${escapeHtml(t)}">${escapeHtml(t)}</span>`).join(', ')
                    : '<span class="no-tasks">No active tasks</span>';
                // Store task IDs as data attribute (not HTML) for terminate modal
                const taskIds = agent.tasks && agent.tasks.length > 0 
                    ? agent.tasks.join(',') 
                    : '';
                const purposeHtml = agent.purpose 
                    ? `<div class="agent-purpose">${escapeHtml(agent.purpose)}</div>` 
                    : `<div class="agent-purpose agent-type-label">${escapeHtml(agent.agent_type || 'worker')} agent</div>`;
                const agentNodeId = `agent-${agent.name}`;
                
                // Success rate color class
                let successRateClass = 'success';
                if (stats.successRate < 90) successRateClass = 'warning';
                if (stats.successRate < 70) successRateClass = 'error';
                
                // Top actions chips
                const topActionsHtml = stats.topActions.length > 0
                    ? `<div class="agent-top-actions">
                        <div class="agent-top-actions-label">Top actions:</div>
                        <div class="agent-top-actions-list">
                            ${stats.topActions.map(a => `<span class="agent-action-chip">${escapeHtml(a.action)}<span class="action-count">Ã—${a.count}</span></span>`).join('')}
                        </div>
                    </div>`
                    : '';
                
                // Timeline entries
                const timelineHtml = stats.recentEntries.length > 0
                    ? `<button class="agent-timeline-toggle" data-agent="${escapeHtml(agent.name)}" onclick="toggleAgentTimeline('${escapeHtml(agent.name)}')">
                        <span>ðŸ“œ Activity timeline (${stats.recentEntries.length} entries)</span>
                        <span class="toggle-icon">â–¼</span>
                    </button>
                    <div class="agent-timeline-content" data-agent="${escapeHtml(agent.name)}">
                        ${stats.recentEntries.map(entry => {
                            const time = new Date(entry.timestamp).toLocaleTimeString();
                            const formatted = formatLogEntry(entry);
                            const errorClass = entry.success === false ? 'timeline-error' : '';
                            const statusIcon = entry.success === false ? 'âŒ' : 'âœ“';
                            return `<div class="agent-timeline-entry ${errorClass}">
                                <span class="timeline-time">${time}</span>
                                <span class="timeline-status">${statusIcon}</span>
                                <span class="timeline-action">${escapeHtml(formatted.action)}</span>
                            </div>`;
                        }).join('')}
                    </div>`
                    : '';
                
                return `
                <div class="card agent-card">
                    <button class="terminate-btn" data-pid="${agent.pid}" data-name="${escapeHtml(agent.name)}" data-tasks="${escapeHtml(taskIds)}">âœ• Terminate</button>
                    <div class="agent-name">${escapeHtml(agent.name)}</div>
                    ${purposeHtml}
                    <div class="agent-pid">PID: ${agent.pid} | ID: ${escapeHtml(agent.id || 'N/A')}</div>
                    <div class="card-meta">
                        <span class="badge badge-agent-${agent.status}">${agent.status}</span>
                    </div>
                    <div class="agent-tasks">Tasks: ${tasksHtml}</div>
                    
                    <!-- Agent Summary Panel -->
                    <div class="agent-summary">
                        <div class="agent-summary-stats">
                            <div class="agent-summary-stat">
                                <span class="stat-icon">â±ï¸</span>
                                <span class="stat-label">Duration:</span>
                                <span class="stat-value">${stats.duration}</span>
                            </div>
                            <div class="agent-summary-stat">
                                <span class="stat-icon">ðŸ“Š</span>
                                <span class="stat-label">Commands:</span>
                                <span class="stat-value">${agent.command_count}</span>
                            </div>
                            <div class="agent-summary-stat">
                                <span class="stat-icon">âœ…</span>
                                <span class="stat-label">Success:</span>
                                <span class="stat-value ${successRateClass}">${stats.successRate}%</span>
                            </div>
                            <div class="agent-summary-stat">
                                <span class="stat-icon">âŒ</span>
                                <span class="stat-label">Failures:</span>
                                <span class="stat-value ${stats.failedCommands > 0 ? 'error' : ''}">${stats.failedCommands}</span>
                            </div>
                        </div>
                        ${topActionsHtml}
                    </div>
                    
                    ${timelineHtml}
                    
                    <div class="agent-stats" style="margin-top: 0.5rem;">
                        <span>â±ï¸ Last active: ${lastActivity}</span>
                    </div>
                    <button class="focus-btn" data-agent-id="${escapeHtml(agentNodeId)}">ðŸŽ¯ Focus on Graph</button>
                </div>
            `}).join('');
            
            // Render recent agent-related activity from the log
            const agentNames = new Set(state.agents.map(a => a.name));
            const agentActivity = (state.log || [])
                .filter(entry => {
                    // Filter for agent-related entries based on command field
                    const command = entry.command || entry.action || entry.message || '';
                    return command.includes('agent') || 
                           command === 'hello' || 
                           command === 'goodbye' ||
                           command === 'orient' ||
                           command === 'task update' ||
                           command === 'task close' ||
                           command === 'bug update' ||
                           command === 'bug close';
                })
                .slice(0, 20);
            
            if (agentActivity.length === 0) {
                activityLog.innerHTML = '<div class="empty-state">No recent agent activity</div>';
            } else {
                activityLog.innerHTML = agentActivity.map(entry => {
                    const time = new Date(entry.timestamp).toLocaleTimeString();
                    const formatted = formatLogEntry(entry);
                    const statusIcon = entry.success === false ? 'âŒ' : 'âœ“';
                    // Linkify entity IDs in action and details
                    const linkedAction = linkifyEntityIds(escapeHtml(formatted.action));
                    const linkedDetails = formatted.details ? linkifyEntityIds(escapeHtml(formatted.details)) : '';
                    return `
                        <div class="activity-entry ${entry.success === false ? 'activity-error' : ''}">
                            <span class="activity-time">${time}</span>
                            <span class="activity-status">${statusIcon}</span>
                            <span class="activity-action">${linkedAction}</span>
                            ${linkedDetails ? `<span class="activity-details">${linkedDetails}</span>` : ''}
                        </div>
                    `;
                }).join('');
                
                // Attach click handlers for entity links
                attachEntityLinkHandlers(activityLog);
            }
            
            // Also update the sidebar on graph view
            renderAgentsSidebar();
        }
        
        // Render agents in the graph sidebar
        function renderAgentsSidebar() {
            const list = document.getElementById('agents-sidebar-list');
            const workerAgents = (state.agents || []).filter(a => a.agent_type === 'worker');
            
            if (workerAgents.length === 0) {
                list.innerHTML = '<div class="agents-sidebar-empty">No active agents</div>';
                // Reapply sidebar filter to update visibility
                if (sidebarSearchQuery) {
                    filterAgentsSection(sidebarSearchQuery);
                }
                return;
            }
            
            list.innerHTML = workerAgents.map(agent => {
                const agentId = agent.id || `agent-${agent.pid}`;
                const currentTask = agent.tasks && agent.tasks.length > 0 ? agent.tasks[0] : null;
                return `
                <div class="agents-sidebar-item" data-agent-id="${agentId}" title="${escapeHtml(agent.name)}">
                    <div class="agents-sidebar-item-header">
                        <span class="agents-sidebar-item-name">${escapeHtml(agent.name)}</span>
                        <span class="agents-sidebar-item-status ${agent.status}"></span>
                    </div>
                    ${currentTask ? `<div class="agents-sidebar-item-task">â†’ ${escapeHtml(currentTask)}</div>` : ''}
                </div>
            `}).join('');
            
            // Add click handlers to pan to agent on graph
            list.querySelectorAll('.agents-sidebar-item').forEach(item => {
                item.addEventListener('click', () => {
                    const agentId = item.dataset.agentId;
                    // Disable auto-follow when user explicitly navigates to a specific node
                    state.graph.autoFollow = false;
                    cancelFocusPeriod();  // Cancel any active focus period
                    updateAutoFollowDisplay();
                    panToNode(agentId, true);
                    const node = state.graph.nodes.find(n => n.id === agentId);
                    if (node) {
                        state.graph.selectedNode = node;
                        showInfoPanel(node);
                    }
                });
            });
            
            // Reapply sidebar filter to update visibility
            if (sidebarSearchQuery) {
                filterAgentsSection(sidebarSearchQuery);
            }
        }

        // Event delegation for agent card interactive elements
        document.getElementById('agents-list').addEventListener('click', (e) => {
            // Handle task link clicks
            const taskLink = e.target.closest('.task-link');
            if (taskLink) {
                const nodeId = taskLink.dataset.nodeId;
                if (nodeId) {
                    navigateToNodeOnGraph(nodeId);
                }
                return;
            }
            
            // Handle focus button clicks
            const focusBtn = e.target.closest('.focus-btn');
            if (focusBtn) {
                const agentId = focusBtn.dataset.agentId;
                if (agentId) {
                    navigateToNodeOnGraph(agentId);
                }
                return;
            }
            
            // Handle terminate button clicks
            const terminateBtn = e.target.closest('.terminate-btn');
            if (terminateBtn) {
                const pid = parseInt(terminateBtn.dataset.pid, 10);
                const name = terminateBtn.dataset.name;
                const taskIds = terminateBtn.dataset.tasks;
                // Format task IDs as HTML for the modal
                const tasksHtml = taskIds 
                    ? taskIds.split(',').map(t => `<span class="task-id">${escapeHtml(t)}</span>`).join(', ')
                    : 'None';
                showTerminateModal(pid, name, tasksHtml);
                return;
            }
        });

        // Navigate to graph view and focus on a specific node
        function navigateToNodeOnGraph(nodeId) {
            // Disable auto-follow when user explicitly navigates to a specific node
            // This indicates they want to look at that specific node, not have it auto-switch
            state.graph.autoFollow = false;
            cancelFocusPeriod();  // Cancel any active focus period
            updateAutoFollowDisplay();
            // Switch to graph view
            switchView('graph');
            // Wait for graph to render, then pan to node
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    panToNode(nodeId, true);
                    // Also select the node to show info panel
                    const node = state.graph.nodes.find(n => n.id === nodeId);
                    if (node) {
                        state.selectedNode = node;
                        updateInfoPanel(node);
                    }
                });
            });
        }

        // Agent termination modal functions
        let terminatingPid = null;

        function showTerminateModal(pid, name, tasks) {
            terminatingPid = pid;
            const modal = document.getElementById('terminate-modal');
            const info = document.getElementById('modal-agent-info');
            info.innerHTML = `
                <div class="agent-name">${escapeHtml(name)}</div>
                <div class="agent-detail">PID: ${pid}</div>
                <div class="agent-detail">Tasks: ${tasks}</div>
            `;
            modal.style.display = 'flex';
            document.getElementById('confirm-terminate-btn').onclick = confirmTerminate;
        }

        function closeTerminateModal() {
            terminatingPid = null;
            document.getElementById('terminate-modal').style.display = 'none';
        }

        async function confirmTerminate() {
            if (!terminatingPid) return;
            const pid = terminatingPid;
            closeTerminateModal();
            
            try {
                const response = await fetch(`/api/agents/${pid}/kill`, { method: 'POST' });
                const result = await response.json();
                if (response.ok) {
                    showToast(result.message, 'success');
                    await loadData(); // Refresh the agents list
                } else {
                    showToast(`Failed to terminate agent: ${result.message || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                showToast(`Failed to terminate agent: ${error}`, 'error');
            }
        }

        // Agent Detail Modal functions (for graph node double-click)
        let detailAgentPid = null;

        function showAgentDetailModal(agent) {
            detailAgentPid = agent.pid;
            const modal = document.getElementById('agent-detail-modal');
            
            // Populate modal content
            document.getElementById('agent-modal-name').textContent = agent.name;
            document.getElementById('agent-modal-pid').textContent = `PID: ${agent.pid}`;
            
            // Status badge
            const statusBadge = document.getElementById('agent-modal-status-badge');
            statusBadge.textContent = agent.status;
            statusBadge.className = `badge badge-agent-${agent.status}`;
            
            // Purpose
            const purposeSection = document.getElementById('agent-modal-purpose-section');
            const purposeEl = document.getElementById('agent-modal-purpose');
            if (agent.purpose) {
                purposeEl.textContent = agent.purpose;
                purposeSection.style.display = 'block';
            } else {
                purposeEl.textContent = 'Not registered - use bn orient --register "purpose"';
                purposeEl.style.fontStyle = 'italic';
                purposeSection.style.display = 'block';
            }
            
            // Statistics
            document.getElementById('agent-modal-command-count').textContent = agent.command_count || 0;
            document.getElementById('agent-modal-task-count').textContent = (agent.tasks || []).length;
            
            // Tasks
            const tasksSection = document.getElementById('agent-modal-tasks-section');
            const tasksEl = document.getElementById('agent-modal-tasks');
            if (agent.tasks && agent.tasks.length > 0) {
                tasksEl.innerHTML = agent.tasks.map(t => 
                    `<span class="agent-detail-task-id">${escapeHtml(t)}</span>`
                ).join('');
                tasksSection.style.display = 'block';
            } else {
                tasksSection.style.display = 'none';
            }
            
            // Timeline
            document.getElementById('agent-modal-started').textContent = 
                `ðŸ• Started: ${new Date(agent.started_at).toLocaleString()}`;
            document.getElementById('agent-modal-last-activity').textContent = 
                `â±ï¸ Last active: ${new Date(agent.last_activity_at).toLocaleString()}`;
            
            // Set up terminate button
            document.getElementById('agent-modal-terminate-btn').onclick = () => {
                closeAgentDetailModal();
                const tasksHtml = agent.tasks && agent.tasks.length > 0 
                    ? agent.tasks.map(t => `<span class="task-id">${escapeHtml(t)}</span>`).join(', ')
                    : 'None';
                showTerminateModal(agent.pid, agent.name, tasksHtml);
            };
            
            modal.style.display = 'flex';
        }

        function closeAgentDetailModal() {
            detailAgentPid = null;
            document.getElementById('agent-detail-modal').style.display = 'none';
        }

        // Close modal when clicking outside content
        document.getElementById('agent-detail-modal').addEventListener('click', (e) => {
            if (e.target.id === 'agent-detail-modal') {
                closeAgentDetailModal();
            }
        });

        // ==================== Doc Viewer ====================

        /**
         * Simple markdown to HTML converter
         * Handles: headings, bold, italic, code blocks, inline code, lists, links, blockquotes, tables
         */
        function renderMarkdown(markdown) {
            if (!markdown) return '';
            
            let html = markdown;
            
            // Escape HTML first (but preserve what we need)
            const escapeHtmlInText = (text) => text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            // Store code blocks to protect them from other transformations
            const codeBlocks = [];
            html = html.replace(/```(\w*)\n([\s\S]*?)```/g, (match, lang, code) => {
                const index = codeBlocks.length;
                const highlightedCode = highlightSyntax(escapeHtmlInText(code.trim()), lang);
                codeBlocks.push(`<pre${lang ? ` data-lang="${lang}"` : ''}><code>${highlightedCode}</code></pre>`);
                return `__CODE_BLOCK_${index}__`;
            });
            
            // Store inline code
            const inlineCode = [];
            html = html.replace(/`([^`]+)`/g, (match, code) => {
                const index = inlineCode.length;
                inlineCode.push(`<code>${escapeHtmlInText(code)}</code>`);
                return `__INLINE_CODE_${index}__`;
            });
            
            // Escape remaining HTML
            html = escapeHtmlInText(html);
            
            // Restore code blocks and inline code
            html = html.replace(/__CODE_BLOCK_(\d+)__/g, (match, index) => codeBlocks[parseInt(index)]);
            html = html.replace(/__INLINE_CODE_(\d+)__/g, (match, index) => inlineCode[parseInt(index)]);
            
            // Headings (must be at start of line)
            html = html.replace(/^######\s+(.+)$/gm, '<h6>$1</h6>');
            html = html.replace(/^#####\s+(.+)$/gm, '<h5>$1</h5>');
            html = html.replace(/^####\s+(.+)$/gm, '<h4>$1</h4>');
            html = html.replace(/^###\s+(.+)$/gm, '<h3>$1</h3>');
            html = html.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');
            
            // Bold and italic (careful order)
            html = html.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
            html = html.replace(/___(.+?)___/g, '<strong><em>$1</em></strong>');
            html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
            html = html.replace(/_(.+?)_/g, '<em>$1</em>');
            
            // Links
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
            
            // Horizontal rules
            html = html.replace(/^---+$/gm, '<hr>');
            html = html.replace(/^\*\*\*+$/gm, '<hr>');
            
            // Blockquotes
            html = html.replace(/^&gt;\s+(.+)$/gm, '<blockquote>$1</blockquote>');
            
            // Task lists (before regular lists)
            html = html.replace(/^(\s*)[-*]\s+\[x\]\s+(.+)$/gm, '$1<li class="task-list-item"><input type="checkbox" checked disabled> $2</li>');
            html = html.replace(/^(\s*)[-*]\s+\[\s?\]\s+(.+)$/gm, '$1<li class="task-list-item"><input type="checkbox" disabled> $2</li>');
            
            // Unordered lists
            html = html.replace(/^[-*]\s+(.+)$/gm, '<li>$1</li>');
            
            // Ordered lists
            html = html.replace(/^\d+\.\s+(.+)$/gm, '<li>$1</li>');
            
            // Wrap consecutive <li> in <ul> (simple approach)
            html = html.replace(/((?:<li[^>]*>.*<\/li>\n?)+)/g, '<ul>$1</ul>');
            
            // Tables (simple implementation)
            const tableRegex = /^\|(.+)\|$/gm;
            const rows = html.match(tableRegex);
            if (rows && rows.length >= 2) {
                let tableHtml = '<table>';
                rows.forEach((row, i) => {
                    const cells = row.slice(1, -1).split('|').map(c => c.trim());
                    // Skip separator row (contains only dashes)
                    if (cells.every(c => /^[-:]+$/.test(c))) return;
                    
                    const tag = i === 0 ? 'th' : 'td';
                    tableHtml += '<tr>' + cells.map(c => `<${tag}>${c}</${tag}>`).join('') + '</tr>';
                });
                tableHtml += '</table>';
                
                // Replace the table in the HTML
                let rowsPattern = rows.map(r => r.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('\\n?');
                html = html.replace(new RegExp(rowsPattern), tableHtml);
            }
            
            // Paragraphs - wrap text blocks that aren't already wrapped
            html = html.split('\n\n').map(block => {
                block = block.trim();
                if (!block) return '';
                // Don't wrap if already starts with HTML tag
                if (/^<(h[1-6]|p|ul|ol|li|pre|blockquote|table|hr|div)/.test(block)) {
                    return block;
                }
                return `<p>${block}</p>`;
            }).join('\n');
            
            // Clean up excessive newlines
            html = html.replace(/\n{3,}/g, '\n\n');
            
            return html;
        }

        /**
         * Basic syntax highlighting for code blocks
         * Uses a two-pass approach: first tokenize, then wrap with spans
         * This avoids the issue of regex patterns matching our own HTML markup
         */
        function highlightSyntax(code, lang) {
            if (!lang) return code;
            
            lang = lang.toLowerCase();
            
            // Keywords by language family
            const keywords = {
                rust: ['fn', 'let', 'mut', 'const', 'pub', 'mod', 'use', 'struct', 'enum', 'impl', 'trait', 'where', 'for', 'while', 'loop', 'if', 'else', 'match', 'return', 'break', 'continue', 'async', 'await', 'move', 'ref', 'self', 'Self', 'super', 'crate', 'dyn', 'static', 'type', 'unsafe', 'extern', 'as', 'in'],
                javascript: ['function', 'const', 'let', 'var', 'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'break', 'continue', 'return', 'class', 'extends', 'new', 'this', 'super', 'import', 'export', 'default', 'async', 'await', 'try', 'catch', 'finally', 'throw', 'typeof', 'instanceof', 'in', 'of', 'yield'],
                typescript: ['function', 'const', 'let', 'var', 'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'break', 'continue', 'return', 'class', 'extends', 'new', 'this', 'super', 'import', 'export', 'default', 'async', 'await', 'try', 'catch', 'finally', 'throw', 'typeof', 'instanceof', 'in', 'of', 'yield', 'interface', 'type', 'enum', 'namespace', 'module', 'declare', 'readonly', 'private', 'public', 'protected', 'static', 'abstract', 'implements'],
                python: ['def', 'class', 'if', 'elif', 'else', 'for', 'while', 'try', 'except', 'finally', 'with', 'as', 'import', 'from', 'return', 'yield', 'raise', 'pass', 'break', 'continue', 'and', 'or', 'not', 'in', 'is', 'None', 'True', 'False', 'lambda', 'global', 'nonlocal', 'async', 'await'],
                go: ['func', 'var', 'const', 'type', 'struct', 'interface', 'map', 'chan', 'if', 'else', 'for', 'range', 'switch', 'case', 'default', 'break', 'continue', 'return', 'go', 'defer', 'select', 'package', 'import', 'make', 'new', 'nil', 'true', 'false', 'iota'],
                json: ['null', 'true', 'false'],
                bash: ['if', 'then', 'else', 'elif', 'fi', 'for', 'while', 'do', 'done', 'case', 'esac', 'function', 'return', 'exit', 'echo', 'export', 'source', 'alias', 'cd', 'pwd', 'ls', 'mkdir', 'rm', 'cp', 'mv', 'cat', 'grep', 'sed', 'awk', 'find', 'chmod', 'chown', 'sudo'],
                sh: ['if', 'then', 'else', 'elif', 'fi', 'for', 'while', 'do', 'done', 'case', 'esac', 'function', 'return', 'exit', 'echo', 'export', 'source', 'alias', 'cd', 'pwd', 'ls', 'mkdir', 'rm', 'cp', 'mv', 'cat', 'grep', 'sed', 'awk', 'find', 'chmod', 'chown', 'sudo'],
            };
            
            const keywordSet = new Set(keywords[lang] || keywords.javascript);
            
            // Tokenize the code first, then apply highlighting to tokens
            // This prevents regex from matching our own HTML markup
            const tokens = [];
            let remaining = code;
            
            while (remaining.length > 0) {
                let matched = false;
                
                // Try to match a comment (// or #)
                const singleLineComment = remaining.match(/^(\/\/.*|#.*)$/m);
                if (singleLineComment && remaining.indexOf(singleLineComment[0]) === 0) {
                    tokens.push({ type: 'comment', value: singleLineComment[0] });
                    remaining = remaining.slice(singleLineComment[0].length);
                    matched = true;
                }
                
                // Try to match a double-quoted string
                if (!matched) {
                    const doubleString = remaining.match(/^"(?:[^"\\]|\\.)*"/);
                    if (doubleString) {
                        tokens.push({ type: 'string', value: doubleString[0] });
                        remaining = remaining.slice(doubleString[0].length);
                        matched = true;
                    }
                }
                
                // Try to match a single-quoted string
                if (!matched) {
                    const singleString = remaining.match(/^'(?:[^'\\]|\\.)*'/);
                    if (singleString) {
                        tokens.push({ type: 'string', value: singleString[0] });
                        remaining = remaining.slice(singleString[0].length);
                        matched = true;
                    }
                }
                
                // Try to match a number
                if (!matched) {
                    const number = remaining.match(/^\d+\.?\d*/);
                    if (number) {
                        tokens.push({ type: 'number', value: number[0] });
                        remaining = remaining.slice(number[0].length);
                        matched = true;
                    }
                }
                
                // Try to match an identifier (potential keyword)
                if (!matched) {
                    const identifier = remaining.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
                    if (identifier) {
                        const word = identifier[0];
                        if (keywordSet.has(word)) {
                            tokens.push({ type: 'keyword', value: word });
                        } else {
                            tokens.push({ type: 'text', value: word });
                        }
                        remaining = remaining.slice(word.length);
                        matched = true;
                    }
                }
                
                // Otherwise, take one character as plain text
                if (!matched) {
                    tokens.push({ type: 'text', value: remaining[0] });
                    remaining = remaining.slice(1);
                }
            }
            
            // Convert tokens to HTML
            return tokens.map(token => {
                switch (token.type) {
                    case 'keyword':
                        return `<span class="keyword">${token.value}</span>`;
                    case 'string':
                        return `<span class="string">${token.value}</span>`;
                    case 'number':
                        return `<span class="number">${token.value}</span>`;
                    case 'comment':
                        return `<span class="comment">${token.value}</span>`;
                    default:
                        return token.value;
                }
            }).join('');
        }

        /**
         * Open the doc viewer modal and load a doc by ID
         */
        async function openDocViewer(docId) {
            const modal = document.getElementById('doc-viewer-modal');
            const titleEl = document.getElementById('doc-viewer-title-text');
            const metaEl = document.getElementById('doc-viewer-meta');
            const summaryEl = document.getElementById('doc-viewer-summary');
            const summaryContentEl = document.getElementById('doc-viewer-summary-content');
            const contentEl = document.getElementById('doc-viewer-content');
            const dirtyIndicator = document.getElementById('doc-viewer-dirty-indicator');
            const historySidebar = document.getElementById('doc-viewer-history-sidebar');
            const historyList = document.getElementById('doc-viewer-history-list');
            
            // Show loading state
            modal.classList.add('visible');
            titleEl.textContent = 'Loading...';
            metaEl.innerHTML = '';
            summaryEl.style.display = 'none';
            contentEl.innerHTML = '<div class="doc-viewer-loading">Loading document...</div>';
            dirtyIndicator.style.display = 'none';
            historySidebar.classList.remove('visible');
            historyList.innerHTML = '';
            
            try {
                // Fetch doc content and history in parallel
                const [docResponse, historyResponse] = await Promise.all([
                    fetch(`/api/docs/${encodeURIComponent(docId)}`),
                    fetch(`/api/docs/${encodeURIComponent(docId)}/history`)
                ]);
                
                if (!docResponse.ok) {
                    throw new Error(`Failed to load doc: ${docResponse.status}`);
                }
                
                const data = await docResponse.json();
                const doc = data.doc;
                
                // Set title
                titleEl.textContent = doc.title || 'Untitled';
                
                // Show dirty indicator if summary needs update
                if (doc.summary_dirty) {
                    dirtyIndicator.style.display = 'inline';
                    summaryEl.classList.add('dirty');
                } else {
                    dirtyIndicator.style.display = 'none';
                    summaryEl.classList.remove('dirty');
                }
                
                // Build meta badges
                const docTypeLabels = {
                    prd: { label: 'ðŸ“‹ PRD', color: 'var(--accent-blue)' },
                    note: { label: 'ðŸ“ Note', color: 'var(--info)' },
                    handoff: { label: 'ðŸ”„ Handoff', color: 'var(--warning)' }
                };
                const typeInfo = docTypeLabels[doc.doc_type] || { label: doc.doc_type, color: 'var(--bg-tertiary)' };
                
                let metaHtml = `
                    <span class="badge" style="background: ${typeInfo.color}">${typeInfo.label}</span>
                    <span class="badge" style="background: var(--bg-tertiary)">${escapeHtml(doc.id)}</span>
                `;
                
                if (doc.tags && doc.tags.length > 0) {
                    metaHtml += doc.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('');
                }
                
                if (doc.editors && doc.editors.length > 0) {
                    const editorNames = doc.editors.map(e => e.name || e.agent_name || 'Unknown').join(', ');
                    metaHtml += `<span class="badge" style="background: var(--bg-tertiary)">âœï¸ ${escapeHtml(editorNames)}</span>`;
                }
                
                metaEl.innerHTML = metaHtml;
                
                // Render summary section prominently
                if (doc.summary && doc.summary.trim()) {
                    summaryEl.style.display = 'block';
                    summaryContentEl.innerHTML = renderMarkdown(doc.summary);
                } else {
                    summaryEl.style.display = 'none';
                }
                
                // Render main content (excluding summary section to avoid duplication)
                let mainContent = doc.content || '';
                // Remove the summary section from main content since we show it separately
                mainContent = mainContent.replace(/^#\s*Summary\s*\n[\s\S]*?(?=^#\s|\Z)/mi, '').trim();
                
                if (mainContent) {
                    contentEl.innerHTML = renderMarkdown(mainContent);
                } else if (!doc.summary) {
                    contentEl.innerHTML = '<div class="empty-state">No content</div>';
                } else {
                    contentEl.innerHTML = '';
                }
                
                // Render version history sidebar
                if (historyResponse.ok) {
                    const historyData = await historyResponse.json();
                    if (historyData.versions && historyData.versions.length > 1) {
                        historySidebar.classList.add('visible');
                        historyList.innerHTML = historyData.versions.map((version, index) => {
                            const date = new Date(version.created_at);
                            const dateStr = date.toLocaleDateString('en-US', { 
                                year: 'numeric', 
                                month: 'short', 
                                day: 'numeric' 
                            });
                            const editorName = version.editors && version.editors.length > 0 
                                ? (version.editors[0].name || version.editors[0].agent_name || 'Unknown')
                                : 'Unknown';
                            const isCurrent = version.is_current;
                            return `
                                <div class="doc-viewer-history-item ${isCurrent ? 'current' : ''}" 
                                     onclick="openDocViewer('${escapeHtml(version.id)}')"
                                     title="${escapeHtml(version.title)}">
                                    <div class="doc-viewer-history-item-version">v${historyData.versions.length - index}</div>
                                    <div class="doc-viewer-history-item-date">${dateStr}</div>
                                    <div class="doc-viewer-history-item-editor">by ${escapeHtml(editorName)}</div>
                                </div>
                            `;
                        }).join('');
                    } else {
                        historySidebar.classList.remove('visible');
                    }
                }
                
            } catch (error) {
                console.error('Failed to load doc:', error);
                contentEl.innerHTML = `<div class="empty-state" style="color: var(--danger)">Failed to load document: ${escapeHtml(error.message)}</div>`;
            }
        }

        /**
         * Close the doc viewer modal
         */
        function closeDocViewer() {
            document.getElementById('doc-viewer-modal').classList.remove('visible');
        }

        // Close doc viewer when clicking outside the container
        document.getElementById('doc-viewer-modal').addEventListener('click', (e) => {
            if (e.target.id === 'doc-viewer-modal') {
                closeDocViewer();
            }
        });

        // Close doc viewer with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('doc-viewer-modal');
                if (modal.classList.contains('visible')) {
                    closeDocViewer();
                }
            }
        });

        // ==================== End Doc Viewer ====================

        // Command category mapping for filtering
        const COMMAND_CATEGORIES = {
            tasks: ['task create', 'task update', 'task close', 'task delete', 'task reopen', 'task list', 'task show'],
            tests: ['test create', 'test run', 'test link', 'test unlink', 'test list', 'test show', 'test delete'],
            links: ['link add', 'link rm', 'link list'],
            bugs: ['bug create', 'bug update', 'bug close', 'bug delete', 'bug list', 'bug show'],
            ideas: ['idea create', 'idea update', 'idea list', 'idea show'],
            docs: ['doc create', 'doc update', 'doc list', 'doc show', 'doc attach'],
            system: ['system init', 'config', 'doctor', 'orient', 'hello', 'goodbye', 'ready', 'blocked', 'log', 'compact', 'sync', 'agent list', 'agent kill'],
            queue: ['queue create', 'queue show', 'queue delete', 'queue add', 'queue rm']
        };

        // Check if a command belongs to a category
        // Check if a command belongs to any of the selected categories
        function commandMatchesCategory(command, categories) {
            // Empty array means "all" - show everything
            if (!categories || categories.length === 0) return true;
            // Check if command matches any selected category
            return categories.some(category => {
                const commands = COMMAND_CATEGORIES[category] || [];
                return commands.some(c => command.startsWith(c));
            });
        }

        // Check if a user is an agent (bna- prefix)
        function isAgent(user) {
            return user && user.startsWith('bna-');
        }

        // Get date threshold for date range filter
        function getDateThreshold(range) {
            const now = new Date();
            switch (range) {
                case 'hour': return new Date(now - 60 * 60 * 1000);
                case 'day': return new Date(now - 24 * 60 * 60 * 1000);
                case 'week': return new Date(now - 7 * 24 * 60 * 60 * 1000);
                case 'month': return new Date(now - 30 * 24 * 60 * 60 * 1000);
                default: return null; // 'all'
            }
        }

        // Apply all filters to log entries
        function filterLogEntries(entries) {
            const { commandCategories, userFilter, statusFilter, searchText, dateRange, customDateFrom, customDateTo } = state.logFilters;
            const dateThreshold = getDateThreshold(dateRange);
            const searchLower = searchText.toLowerCase();
            
            // Parse custom date range bounds
            const customFrom = customDateFrom ? new Date(customDateFrom + 'T00:00:00') : null;
            const customTo = customDateTo ? new Date(customDateTo + 'T23:59:59.999') : null;

            return entries.filter(entry => {
                const command = entry.command || entry.action || '';
                
                // Command category filter (multi-select)
                if (!commandMatchesCategory(command, commandCategories)) return false;
                
                // User filter
                if (userFilter === 'humans' && isAgent(entry.user)) return false;
                if (userFilter === 'agents' && !isAgent(entry.user)) return false;
                if (userFilter !== 'all' && userFilter !== 'humans' && userFilter !== 'agents') {
                    // Specific user selected
                    if (entry.user !== userFilter) return false;
                }
                
                // Status filter
                if (statusFilter === 'success' && entry.success === false) return false;
                if (statusFilter === 'failure' && entry.success !== false) return false;
                
                // Date range filter
                const entryDate = new Date(entry.timestamp);
                if (dateRange === 'custom') {
                    // Custom range: check both bounds
                    if (customFrom && entryDate < customFrom) return false;
                    if (customTo && entryDate > customTo) return false;
                } else if (dateThreshold && entryDate < dateThreshold) {
                    return false;
                }
                
                // Text search filter
                if (searchLower) {
                    const searchFields = [
                        command,
                        entry.user || '',
                        entry.error || '',
                        JSON.stringify(entry.args || {})
                    ].join(' ').toLowerCase();
                    if (!searchFields.includes(searchLower)) return false;
                }
                
                return true;
            });
        }

        // Highlight search matches in text
        function highlightText(text, searchText) {
            if (!searchText) return escapeHtml(text);
            const escaped = escapeHtml(text);
            const searchLower = searchText.toLowerCase();
            const textLower = text.toLowerCase();
            
            let result = '';
            let lastIndex = 0;
            let index = textLower.indexOf(searchLower);
            
            while (index !== -1) {
                result += escaped.substring(lastIndex, index);
                result += `<span class="log-highlight">${escaped.substring(index, index + searchText.length)}</span>`;
                lastIndex = index + searchText.length;
                index = textLower.indexOf(searchLower, lastIndex);
            }
            result += escaped.substring(lastIndex);
            
            return result;
        }

        // Update user filter dropdown with unique users from log
        function updateUserFilterOptions() {
            const select = document.getElementById('user-filter');
            const users = [...new Set(state.log.map(e => e.user).filter(Boolean))].sort();
            
            // Separate agents and humans
            const agents = users.filter(isAgent);
            const humans = users.filter(u => !isAgent(u));
            
            // Keep first 3 options (All, Humans, Agents)
            while (select.options.length > 3) {
                select.remove(3);
            }
            
            // Add agents group
            if (agents.length > 0) {
                const agentGroup = document.createElement('optgroup');
                agentGroup.label = 'ðŸ¤– Agents';
                agents.forEach(user => {
                    const opt = document.createElement('option');
                    opt.value = user;
                    opt.textContent = user;
                    agentGroup.appendChild(opt);
                });
                select.appendChild(agentGroup);
            }
            
            // Add humans group
            if (humans.length > 0) {
                const humanGroup = document.createElement('optgroup');
                humanGroup.label = 'ðŸ‘¤ Humans';
                humans.forEach(user => {
                    const opt = document.createElement('option');
                    opt.value = user;
                    opt.textContent = user;
                    humanGroup.appendChild(opt);
                });
                select.appendChild(humanGroup);
            }
        }

        // Update filter summary
        function updateFilterSummary(loadedCount, filteredCount) {
            const summary = document.getElementById('log-filter-summary');
            const total = state.logPagination.total;
            const hasMore = state.logPagination.hasMore;
            
            if (filteredCount === loadedCount && loadedCount === total) {
                summary.textContent = `Showing all ${total} entries`;
            } else if (filteredCount === loadedCount && hasMore) {
                summary.textContent = `Showing ${filteredCount} of ${total} total entries (scroll for more)`;
            } else if (filteredCount === loadedCount) {
                summary.textContent = `Showing all ${total} entries`;
            } else {
                summary.textContent = `Showing ${filteredCount} of ${loadedCount} loaded (${total} total)`;
            }
        }

        // Activity Timeline Heatmap - shows activity density over time
        let selectedTimelineSegment = null;

        function renderActivityTimeline(entries) {
            const svg = document.getElementById('timeline-svg');
            const labels = document.getElementById('timeline-labels');
            const rangeDisplay = document.getElementById('timeline-range');
            
            if (!entries || entries.length === 0) {
                svg.innerHTML = '';
                labels.innerHTML = '';
                rangeDisplay.textContent = '';
                document.getElementById('activity-timeline').style.display = 'none';
                return;
            }
            
            document.getElementById('activity-timeline').style.display = 'block';
            
            // Get time range from entries
            const timestamps = entries.map(e => new Date(e.timestamp).getTime());
            const minTime = Math.min(...timestamps);
            const maxTime = Math.max(...timestamps);
            const timeRange = maxTime - minTime;
            
            // Determine bucket size based on time range
            let bucketMs, bucketLabel;
            const oneHour = 60 * 60 * 1000;
            const oneDay = 24 * oneHour;
            const oneWeek = 7 * oneDay;
            
            if (timeRange <= 2 * oneHour) {
                bucketMs = 5 * 60 * 1000; // 5 minutes
                bucketLabel = '5min';
            } else if (timeRange <= oneDay) {
                bucketMs = oneHour; // 1 hour
                bucketLabel = 'hour';
            } else if (timeRange <= oneWeek) {
                bucketMs = 6 * oneHour; // 6 hours
                bucketLabel = '6hr';
            } else {
                bucketMs = oneDay; // 1 day
                bucketLabel = 'day';
            }
            
            // Create time buckets
            const bucketStart = Math.floor(minTime / bucketMs) * bucketMs;
            const bucketEnd = Math.ceil(maxTime / bucketMs) * bucketMs;
            const bucketCount = Math.max(1, Math.ceil((bucketEnd - bucketStart) / bucketMs));
            
            // Limit to reasonable number of buckets
            const maxBuckets = 50;
            const effectiveBucketCount = Math.min(bucketCount, maxBuckets);
            const effectiveBucketMs = effectiveBucketCount < bucketCount 
                ? (bucketEnd - bucketStart) / effectiveBucketCount 
                : bucketMs;
            
            // Initialize buckets
            const buckets = Array(effectiveBucketCount).fill(null).map((_, i) => ({
                start: bucketStart + i * effectiveBucketMs,
                end: bucketStart + (i + 1) * effectiveBucketMs,
                count: 0,
                failures: 0
            }));
            
            // Fill buckets
            entries.forEach(entry => {
                const time = new Date(entry.timestamp).getTime();
                const bucketIndex = Math.min(
                    effectiveBucketCount - 1,
                    Math.floor((time - bucketStart) / effectiveBucketMs)
                );
                if (bucketIndex >= 0 && bucketIndex < buckets.length) {
                    buckets[bucketIndex].count++;
                    if (entry.success === false) {
                        buckets[bucketIndex].failures++;
                    }
                }
            });
            
            // Find max count for scaling
            const maxCount = Math.max(1, ...buckets.map(b => b.count));
            
            // Render SVG
            const svgWidth = svg.clientWidth || 600;
            const svgHeight = 40;
            const segmentWidth = svgWidth / effectiveBucketCount;
            const padding = 1;
            
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            
            let svgContent = '';
            buckets.forEach((bucket, i) => {
                if (bucket.count === 0) return;
                
                const x = i * segmentWidth + padding;
                const width = Math.max(1, segmentWidth - padding * 2);
                const opacity = 0.2 + (bucket.count / maxCount) * 0.8;
                const hasFailures = bucket.failures > 0;
                const isSelected = selectedTimelineSegment && 
                    selectedTimelineSegment.start === bucket.start && 
                    selectedTimelineSegment.end === bucket.end;
                
                const classes = [
                    'activity-timeline-segment',
                    hasFailures ? 'has-failures' : '',
                    isSelected ? 'selected' : ''
                ].filter(Boolean).join(' ');
                
                svgContent += `
                    <rect 
                        class="${classes}"
                        x="${x}" 
                        y="0" 
                        width="${width}" 
                        height="${svgHeight}"
                        style="opacity: ${opacity}"
                        data-bucket-index="${i}"
                        data-start="${bucket.start}"
                        data-end="${bucket.end}"
                        data-count="${bucket.count}"
                        data-failures="${bucket.failures}"
                    >
                        <title>${bucket.count} entries${bucket.failures > 0 ? ` (${bucket.failures} failures)` : ''}\n${new Date(bucket.start).toLocaleString()}</title>
                    </rect>
                `;
            });
            
            svg.innerHTML = svgContent;
            
            // Add click handlers
            svg.querySelectorAll('.activity-timeline-segment').forEach(rect => {
                rect.addEventListener('click', (e) => {
                    const start = parseInt(rect.dataset.start);
                    const end = parseInt(rect.dataset.end);
                    
                    // Toggle selection
                    if (selectedTimelineSegment && 
                        selectedTimelineSegment.start === start && 
                        selectedTimelineSegment.end === end) {
                        // Deselect - clear custom date filter
                        selectedTimelineSegment = null;
                        state.logFilters.dateRange = 'all';
                        state.logFilters.customDateFrom = '';
                        state.logFilters.customDateTo = '';
                        document.getElementById('custom-date-range').style.display = 'none';
                        document.querySelectorAll('.date-preset-btn').forEach(b => {
                            b.classList.toggle('active', b.dataset.range === 'all');
                        });
                    } else {
                        // Select - set custom date filter
                        selectedTimelineSegment = { start, end };
                        state.logFilters.dateRange = 'custom';
                        state.logFilters.customDateFrom = new Date(start).toISOString().split('T')[0];
                        state.logFilters.customDateTo = new Date(end).toISOString().split('T')[0];
                        document.getElementById('custom-date-range').style.display = 'flex';
                        document.getElementById('date-from').value = state.logFilters.customDateFrom;
                        document.getElementById('date-to').value = state.logFilters.customDateTo;
                        document.querySelectorAll('.date-preset-btn').forEach(b => {
                            b.classList.toggle('active', b.dataset.range === 'custom');
                        });
                    }
                    
                    saveLogFiltersToURL();
                    renderLog();
                });
            });
            
            // Update labels
            const startDate = new Date(bucketStart);
            const endDate = new Date(bucketEnd);
            labels.innerHTML = `
                <span>${startDate.toLocaleDateString()} ${startDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
                <span>${endDate.toLocaleDateString()} ${endDate.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</span>
            `;
            
            // Update range display
            rangeDisplay.textContent = `${entries.length} entries â€¢ ${bucketLabel} buckets`;
        }

        // Command Frequency Chart - shows top 10 commands
        let selectedFrequencyCommand = null;
        let frequencyChartCollapsed = false;

        function toggleFrequencyChart() {
            const chart = document.getElementById('command-frequency-chart');
            frequencyChartCollapsed = !frequencyChartCollapsed;
            chart.classList.toggle('collapsed', frequencyChartCollapsed);
        }

        function renderCommandFrequencyChart(entries) {
            const barsContainer = document.getElementById('frequency-bars');
            const pieContainer = document.getElementById('frequency-pie');
            const chart = document.getElementById('command-frequency-chart');
            
            if (!entries || entries.length === 0) {
                chart.style.display = 'none';
                return;
            }
            
            chart.style.display = 'block';
            
            // Count commands
            const commandCounts = {};
            entries.forEach(entry => {
                const command = entry.command || entry.action || entry.message || 'unknown';
                commandCounts[command] = (commandCounts[command] || 0) + 1;
            });
            
            // Sort by count and take top 10
            const sortedCommands = Object.entries(commandCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            if (sortedCommands.length === 0) {
                barsContainer.innerHTML = '<div class="frequency-empty">No commands to display</div>';
                pieContainer.innerHTML = '';
                return;
            }
            
            const maxCount = sortedCommands[0][1];
            const total = sortedCommands.reduce((sum, [_, count]) => sum + count, 0);
            
            // Color palette
            const colors = [
                'var(--freq-color-0)', 'var(--freq-color-1)', 'var(--freq-color-2)',
                'var(--freq-color-3)', 'var(--freq-color-4)', 'var(--freq-color-5)',
                'var(--freq-color-6)', 'var(--freq-color-7)', 'var(--freq-color-8)',
                'var(--freq-color-9)'
            ];
            
            // Render bar chart
            barsContainer.innerHTML = sortedCommands.map(([command, count], index) => {
                const percentage = (count / maxCount) * 100;
                const isSelected = selectedFrequencyCommand === command;
                const color = colors[index % colors.length];
                return `
                    <div class="frequency-bar-row ${isSelected ? 'selected' : ''}" 
                         data-command="${escapeHtml(command)}"
                         title="${escapeHtml(command)}: ${count} (${((count / total) * 100).toFixed(1)}%)">
                        <div class="frequency-bar-label">${escapeHtml(command)}</div>
                        <div class="frequency-bar-container">
                            <div class="frequency-bar" style="width: ${percentage}%; background: ${color}"></div>
                        </div>
                        <div class="frequency-bar-count">${count}</div>
                    </div>
                `;
            }).join('');
            
            // Add click handlers for bar chart
            barsContainer.querySelectorAll('.frequency-bar-row').forEach(row => {
                row.addEventListener('click', () => {
                    const command = row.dataset.command;
                    handleFrequencyCommandClick(command);
                });
            });
            
            // Render pie chart
            renderFrequencyPieChart(pieContainer, sortedCommands, total, colors);
        }

        function renderFrequencyPieChart(container, commandData, total, colors) {
            const size = 150;
            const center = size / 2;
            const radius = 60;
            
            let currentAngle = -Math.PI / 2; // Start at top
            
            let paths = '';
            commandData.forEach(([command, count], index) => {
                const sliceAngle = (count / total) * 2 * Math.PI;
                const endAngle = currentAngle + sliceAngle;
                
                const x1 = center + radius * Math.cos(currentAngle);
                const y1 = center + radius * Math.sin(currentAngle);
                const x2 = center + radius * Math.cos(endAngle);
                const y2 = center + radius * Math.sin(endAngle);
                
                const largeArc = sliceAngle > Math.PI ? 1 : 0;
                const color = colors[index % colors.length];
                const isSelected = selectedFrequencyCommand === command;
                
                // Create pie slice path
                const pathData = `M ${center} ${center} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArc} 1 ${x2} ${y2} Z`;
                
                paths += `
                    <path class="frequency-pie-segment ${isSelected ? 'selected' : ''}"
                          d="${pathData}"
                          fill="${color}"
                          data-command="${escapeHtml(command)}"
                          title="${escapeHtml(command)}: ${count} (${((count / total) * 100).toFixed(1)}%)">
                    </path>
                `;
                
                currentAngle = endAngle;
            });
            
            container.innerHTML = `
                <svg viewBox="0 0 ${size} ${size}">
                    ${paths}
                </svg>
            `;
            
            // Add click handlers for pie segments
            container.querySelectorAll('.frequency-pie-segment').forEach(segment => {
                segment.addEventListener('click', () => {
                    const command = segment.dataset.command;
                    handleFrequencyCommandClick(command);
                });
            });
        }

        function handleFrequencyCommandClick(command) {
            if (selectedFrequencyCommand === command) {
                // Deselect - clear command filter
                selectedFrequencyCommand = null;
                state.logFilters.commandCategories = ['all'];
                // Reset filter chips
                document.querySelectorAll('#command-filter-chips .filter-chip').forEach(chip => {
                    chip.classList.toggle('active', chip.dataset.category === 'all');
                });
            } else {
                // Select - filter to this command
                selectedFrequencyCommand = command;
                // Map the command to a category if possible, otherwise use search
                const category = getCommandCategory(command);
                if (category && category !== 'other') {
                    state.logFilters.commandCategories = [category];
                    document.querySelectorAll('#command-filter-chips .filter-chip').forEach(chip => {
                        chip.classList.toggle('active', chip.dataset.category === category);
                    });
                } else {
                    // Use search filter for specific command
                    state.logFilters.commandCategories = ['all'];
                    state.logFilters.searchText = command;
                    document.getElementById('log-search').value = command;
                    document.querySelectorAll('#command-filter-chips .filter-chip').forEach(chip => {
                        chip.classList.toggle('active', chip.dataset.category === 'all');
                    });
                }
            }
            
            saveLogFiltersToURL();
            renderLog();
        }

        function getCommandCategory(command) {
            // Map command to filter category
            if (command.startsWith('task ')) return 'tasks';
            if (command.startsWith('test ')) return 'tests';
            if (command.startsWith('link ')) return 'links';
            if (command.startsWith('bug ')) return 'bugs';
            if (command.startsWith('idea ')) return 'ideas';
            if (command.startsWith('doc ')) return 'docs';
            if (command.startsWith('queue ')) return 'queue';
            if (['orient', 'ready', 'blocked', 'init', 'doctor', 'config', 'hello', 'goodbye', 'sync'].includes(command)) return 'system';
            return 'other';
        }

        function renderLog() {
            const list = document.getElementById('log-list');
            
            if (state.log.length === 0 && !state.logPagination.hasMore) {
                list.innerHTML = '<div class="empty-state">No activity yet</div>';
                updateFilterSummary(0, 0);
                renderActivityTimeline([]);
                renderCommandFrequencyChart([]);
                return;
            }
            
            // Apply filters
            const filteredEntries = filterLogEntries(state.log);
            updateFilterSummary(state.log.length, filteredEntries.length);
            
            // Render timeline with all entries (not filtered by date, to show full range)
            // but respect command, user, and status filters for timeline density
            const timelineEntries = state.log.filter(entry => {
                // Apply non-date filters for timeline
                const { commandCategories, userFilter, statusFilter } = state.logFilters;
                const command = entry.command || entry.action || entry.message || '';
                
                // Command category filter
                if (!commandMatchesCategory(command, commandCategories)) return false;
                
                // User filter
                if (userFilter === 'humans' && isAgent(entry.user)) return false;
                if (userFilter === 'agents' && !isAgent(entry.user)) return false;
                if (userFilter && userFilter !== 'all' && userFilter !== 'humans' && userFilter !== 'agents') {
                    if (entry.user !== userFilter) return false;
                }
                
                // Status filter
                if (statusFilter === 'success' && entry.success === false) return false;
                if (statusFilter === 'failure' && entry.success !== false) return false;
                
                return true;
            });
            renderActivityTimeline(timelineEntries);
            renderCommandFrequencyChart(timelineEntries);
            
            if (filteredEntries.length === 0 && !state.logPagination.hasMore) {
                list.innerHTML = '<div class="empty-state">No entries match current filters</div>';
                return;
            }
            
            const searchText = state.logFilters.searchText;
            
            // Check if showing mixed results (for enhanced failure highlighting)
            const showingMixed = state.logFilters.statusFilter === 'all';
            
            // Check view mode: flat or grouped (sessions)
            const viewMode = state.logFilters.viewMode || 'flat';
            
            let entriesHtml = '';
            if (viewMode === 'grouped') {
                // Session-grouped view
                const sessions = groupEntriesIntoSessions(filteredEntries);
                entriesHtml = renderSessionGroups(sessions, searchText, showingMixed);
            } else {
                // Flat view - show all filtered entries (no artificial limit)
                entriesHtml = filteredEntries.map(entry => 
                    renderLogEntry(entry, searchText, showingMixed)
                ).join('');
            }
            
            // Add "Load More" button if there are more entries
            if (state.logPagination.hasMore) {
                const loadMoreHtml = `
                    <div class="log-load-more">
                        <button class="log-load-more-btn" onclick="loadMoreLogEntries()" ${state.logPagination.loading ? 'disabled' : ''}>
                            ${state.logPagination.loading ? 'Loading...' : `Load More (${state.logPagination.total - state.log.length} remaining)`}
                        </button>
                    </div>
                `;
                entriesHtml += loadMoreHtml;
            }
            
            list.innerHTML = entriesHtml;
            
            // Attach click handlers for entity links
            attachEntityLinkHandlers(list);
        }

        // Load more log entries (pagination)
        async function loadMoreLogEntries() {
            if (state.logPagination.loading || !state.logPagination.hasMore) return;
            
            state.logPagination.loading = true;
            renderLog(); // Update button state to "Loading..."
            
            try {
                const limit = state.logPagination.limit;
                const offset = state.logPagination.offset;
                const response = await fetch(`/api/log?limit=${limit}&offset=${offset}`);
                const data = await response.json();
                
                const newEntries = data.log || [];
                if (newEntries.length > 0) {
                    // Append new entries to existing log
                    state.log = [...state.log, ...newEntries];
                    state.logPagination.offset = state.log.length;
                    state.logPagination.total = data.total || state.logPagination.total;
                    state.logPagination.hasMore = state.log.length < state.logPagination.total;
                    
                    // Update user filter dropdown with new users
                    updateUserFilterOptions();
                } else {
                    state.logPagination.hasMore = false;
                }
            } catch (err) {
                console.error('Failed to load more log entries:', err);
            } finally {
                state.logPagination.loading = false;
                renderLog();
            }
        }

        // Infinite scroll handler for log view
        function setupLogInfiniteScroll() {
            const logList = document.getElementById('log-list');
            if (!logList) return;
            
            // Use the log-view container for scroll detection since log-list grows with content
            const logView = document.getElementById('log-view');
            if (!logView) return;
            
            logView.addEventListener('scroll', () => {
                // Only trigger if we're in the log view
                if (state.currentView !== 'log') return;
                
                // Check if we're near the bottom (within 200px)
                const scrollBottom = logView.scrollTop + logView.clientHeight;
                const threshold = logView.scrollHeight - 200;
                
                if (scrollBottom >= threshold) {
                    loadMoreLogEntries();
                }
            });
        }

        // Format a log entry into a human-readable action and details
        function formatLogEntry(entry) {
            const command = entry.command || entry.action || entry.message || 'unknown';
            const args = entry.args || {};
            
            // Build a human-readable action description
            let action = command;
            let details = '';
            
            switch (command) {
                case 'task create':
                    action = `Created task`;
                    details = args.title || '';
                    break;
                case 'task update':
                    action = `Updated task ${args.id || ''}`;
                    const updates = [];
                    if (args.status) updates.push(`status â†’ ${args.status}`);
                    if (args.priority !== null && args.priority !== undefined) updates.push(`priority â†’ ${args.priority}`);
                    if (args.title) updates.push(`title changed`);
                    details = updates.join(', ');
                    break;
                case 'task close':
                    action = `Closed task ${args.id || ''}`;
                    details = args.reason || '';
                    break;
                case 'task delete':
                    action = `Deleted task ${args.id || ''}`;
                    break;
                case 'bug create':
                    action = `Created bug`;
                    details = args.title || '';
                    break;
                case 'bug update':
                    action = `Updated bug ${args.id || ''}`;
                    const bugUpdates = [];
                    if (args.status) bugUpdates.push(`status â†’ ${args.status}`);
                    if (args.severity) bugUpdates.push(`severity â†’ ${args.severity}`);
                    details = bugUpdates.join(', ');
                    break;
                case 'bug close':
                    action = `Closed bug ${args.id || ''}`;
                    details = args.reason || '';
                    break;
                case 'idea create':
                    action = `Created idea`;
                    details = args.title || '';
                    break;
                case 'link add':
                    action = `Linked ${args.source || ''} â†’ ${args.target || ''}`;
                    details = args.edge_type ? `(${args.edge_type})` : '';
                    break;
                case 'link rm':
                    action = `Unlinked ${args.source || ''} from ${args.target || ''}`;
                    break;
                case 'orient':
                    action = `Agent oriented`;
                    break;
                case 'ready':
                    action = `Checked ready tasks`;
                    break;
                case 'hello':
                    action = `Agent started`;
                    details = args.purpose || '';
                    break;
                case 'goodbye':
                    action = `Agent finished`;
                    details = args.reason || args.summary || '';
                    break;
                case 'test run':
                    action = `Ran tests`;
                    details = args.id || (args.all ? 'all tests' : '');
                    break;
                default:
                    // For other commands, just show command with first meaningful arg
                    if (args.id) {
                        action = `${command} ${args.id}`;
                    }
                    break;
            }
            
            // Look up entity titles if we have an ID reference
            const entityId = args.id || args.task_id;
            if (entityId && !details) {
                const entity = findEntityById(entityId);
                if (entity && entity.title) {
                    details = entity.title;
                }
            }
            
            return { action, details };
        }
        
        // Reconstruct CLI command from log entry
        function reconstructCLICommand(entry) {
            const command = entry.command || '';
            const args = entry.args || {};
            
            // Helper to quote strings with spaces/special chars
            const quote = (s) => {
                if (!s) return '';
                const str = String(s);
                if (str.includes(' ') || str.includes('"') || str.includes("'") || str.includes('\\')) {
                    return `"${str.replace(/"/g, '\\"')}"`;
                }
                return str;
            };
            
            // Build command parts
            const parts = ['bn'];
            
            switch (command) {
                case 'task create':
                    parts.push('task', 'create');
                    if (args.title) parts.push(quote(args.title));
                    if (args.short_name) parts.push('-s', quote(args.short_name));
                    if (args.priority !== undefined && args.priority !== null) parts.push('-p', args.priority);
                    if (args.description) parts.push('-d', quote(args.description));
                    if (args.tags && Array.isArray(args.tags)) {
                        args.tags.forEach(t => parts.push('-t', quote(t)));
                    }
                    if (args.assignee) parts.push('-a', quote(args.assignee));
                    break;
                    
                case 'task update':
                    parts.push('task', 'update');
                    if (args.id) parts.push(args.id);
                    if (args.status) parts.push('--status', args.status);
                    if (args.priority !== undefined && args.priority !== null) parts.push('--priority', args.priority);
                    if (args.title) parts.push('--title', quote(args.title));
                    if (args.description) parts.push('--description', quote(args.description));
                    if (args.short_name) parts.push('--short-name', quote(args.short_name));
                    break;
                    
                case 'task close':
                    parts.push('task', 'close');
                    if (args.id) parts.push(args.id);
                    if (args.reason) parts.push('--reason', quote(args.reason));
                    break;
                    
                case 'task delete':
                    parts.push('task', 'delete');
                    if (args.id) parts.push(args.id);
                    break;
                    
                case 'task show':
                    parts.push('task', 'show');
                    if (args.id) parts.push(args.id);
                    break;
                    
                case 'task list':
                    parts.push('task', 'list');
                    if (args.status) parts.push('--status', args.status);
                    if (args.priority !== undefined && args.priority !== null) parts.push('--priority', args.priority);
                    if (args.tag) parts.push('--tag', quote(args.tag));
                    break;
                    
                case 'bug create':
                    parts.push('bug', 'create');
                    if (args.title) parts.push(quote(args.title));
                    if (args.severity) parts.push('--severity', args.severity);
                    if (args.description) parts.push('-d', quote(args.description));
                    break;
                    
                case 'bug update':
                    parts.push('bug', 'update');
                    if (args.id) parts.push(args.id);
                    if (args.status) parts.push('--status', args.status);
                    if (args.severity) parts.push('--severity', args.severity);
                    break;
                    
                case 'bug close':
                    parts.push('bug', 'close');
                    if (args.id) parts.push(args.id);
                    if (args.reason) parts.push('--reason', quote(args.reason));
                    break;
                    
                case 'idea create':
                    parts.push('idea', 'create');
                    if (args.title) parts.push(quote(args.title));
                    if (args.description) parts.push('-d', quote(args.description));
                    break;
                    
                case 'idea update':
                    parts.push('idea', 'update');
                    if (args.id) parts.push(args.id);
                    if (args.status) parts.push('--status', args.status);
                    break;
                    
                case 'link add':
                    parts.push('link', 'add');
                    if (args.source) parts.push(args.source);
                    if (args.target) parts.push(args.target);
                    if (args.edge_type) parts.push('-t', args.edge_type);
                    if (args.reason) parts.push('--reason', quote(args.reason));
                    break;
                    
                case 'link rm':
                    parts.push('link', 'rm');
                    if (args.source) parts.push(args.source);
                    if (args.target) parts.push(args.target);
                    break;
                    
                case 'test create':
                    parts.push('test', 'create');
                    if (args.name) parts.push(quote(args.name));
                    if (args.command) parts.push('--cmd', quote(args.command));
                    if (args.task_id) parts.push('--task', args.task_id);
                    break;
                    
                case 'test run':
                    parts.push('test', 'run');
                    if (args.id) parts.push(args.id);
                    if (args.all) parts.push('--all');
                    if (args.task_id) parts.push('--task', args.task_id);
                    break;
                    
                case 'queue add':
                    parts.push('queue', 'add');
                    if (args.task_id) parts.push(args.task_id);
                    break;
                    
                case 'queue rm':
                    parts.push('queue', 'rm');
                    if (args.task_id) parts.push(args.task_id);
                    break;
                    
                case 'orient':
                    parts.push('orient');
                    break;
                    
                case 'ready':
                    parts.push('ready');
                    break;
                    
                case 'hello':
                    parts.push('hello');
                    if (args.purpose) parts.push(quote(args.purpose));
                    break;
                    
                case 'goodbye':
                    parts.push('goodbye');
                    if (args.summary || args.reason) parts.push(quote(args.summary || args.reason));
                    break;
                    
                default:
                    // Generic fallback: just reconstruct from command name
                    const cmdParts = command.split(' ');
                    parts.push(...cmdParts);
                    // Add id if present
                    if (args.id) parts.push(args.id);
                    break;
            }
            
            return parts.join(' ');
        }
        
        // Copy CLI command from log entry to clipboard
        async function copyLogEntryCommand(event, entry) {
            event.stopPropagation(); // Don't toggle expand when clicking copy button
            
            const command = reconstructCLICommand(entry);
            
            try {
                await navigator.clipboard.writeText(command);
                showToast(`Copied: ${command}`, 'success', 3000);
            } catch (err) {
                // Fallback for older browsers or when clipboard API fails
                const textarea = document.createElement('textarea');
                textarea.value = command;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    showToast(`Copied: ${command}`, 'success', 3000);
                } catch (e) {
                    showToast('Failed to copy command', 'error', 3000);
                }
                document.body.removeChild(textarea);
            }
        }
        
        // Copy CLI command from button element's data attribute
        async function copyLogEntryCommandFromElement(event, buttonElement) {
            event.stopPropagation(); // Don't toggle expand when clicking copy button
            
            const command = buttonElement.dataset.command;
            if (!command) {
                showToast('No command to copy', 'error', 3000);
                return;
            }
            
            try {
                await navigator.clipboard.writeText(command);
                showToast(`Copied: ${command}`, 'success', 3000);
            } catch (err) {
                // Fallback for older browsers or when clipboard API fails
                const textarea = document.createElement('textarea');
                textarea.value = command;
                textarea.style.position = 'fixed';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    showToast(`Copied: ${command}`, 'success', 3000);
                } catch (e) {
                    showToast('Failed to copy command', 'error', 3000);
                }
                document.body.removeChild(textarea);
            }
        }
        
        // Group log entries into sessions based on time gaps (>5 min) or agent changes
        function groupEntriesIntoSessions(entries) {
            if (!entries || entries.length === 0) return [];
            
            const SESSION_GAP_MS = 5 * 60 * 1000; // 5 minutes
            const sessions = [];
            let currentSession = null;
            
            // Sort entries by timestamp (newest first is already the case, but we need oldest first for grouping)
            const sortedEntries = [...entries].sort((a, b) => 
                new Date(a.timestamp) - new Date(b.timestamp)
            );
            
            for (const entry of sortedEntries) {
                const entryTime = new Date(entry.timestamp);
                const entryAgent = entry.user || 'unknown';
                
                // Check if we need to start a new session
                const needsNewSession = !currentSession ||
                    // Time gap > 5 minutes
                    (entryTime - currentSession.endTime > SESSION_GAP_MS) ||
                    // Different agent
                    (currentSession.agent !== entryAgent);
                
                if (needsNewSession) {
                    // Start a new session
                    currentSession = {
                        startTime: entryTime,
                        endTime: entryTime,
                        agent: entryAgent,
                        entries: [],
                        successCount: 0,
                        failureCount: 0,
                        commandTypes: new Set()
                    };
                    sessions.push(currentSession);
                }
                
                // Add entry to current session
                currentSession.entries.push(entry);
                currentSession.endTime = entryTime;
                
                // Track statistics
                if (entry.success === false) {
                    currentSession.failureCount++;
                } else {
                    currentSession.successCount++;
                }
                
                const command = entry.command || entry.action || '';
                if (command) {
                    const cmdType = command.split(' ')[0];
                    currentSession.commandTypes.add(cmdType);
                }
            }
            
            // Reverse sessions so newest is first, and reverse entries within each session
            return sessions.reverse().map(session => ({
                ...session,
                entries: session.entries.reverse(),
                commandTypes: Array.from(session.commandTypes)
            }));
        }
        
        // Format a duration in milliseconds to a human-readable string
        function formatDuration(ms) {
            if (ms < 1000) return 'instant';
            if (ms < 60000) return `${Math.round(ms / 1000)}s`;
            if (ms < 3600000) return `${Math.round(ms / 60000)}m`;
            return `${Math.round(ms / 3600000)}h`;
        }
        
        // Render a single log entry (extracted for reuse)
        function renderLogEntry(entry, searchText, showingMixed) {
            const formatted = formatLogEntry(entry);
            const isFailure = entry.success === false;
            const statusClass = isFailure ? 'log-error' : (showingMixed ? 'log-success' : '');
            // First highlight search text, then linkify entity IDs
            const highlightedAction = linkifyEntityIds(highlightText(formatted.action, searchText));
            const highlightedDetails = formatted.details ? linkifyEntityIds(highlightText(formatted.details, searchText)) : '';
            const highlightedError = entry.error ? linkifyEntityIds(highlightText(entry.error, searchText)) : '';
            
            // Show status badge when in mixed mode for clearer differentiation
            const statusBadge = showingMixed 
                ? (isFailure 
                    ? '<span class="log-status-badge badge-failure">FAILED</span>'
                    : '<span class="log-status-badge badge-success">OK</span>')
                : '';
            
            // Build expanded content sections
            const expandedSections = [];
            
            // Full arguments (if any beyond what's shown in summary)
            const args = entry.args || {};
            const hasArgs = Object.keys(args).length > 0;
            if (hasArgs) {
                const argsJson = JSON.stringify(args, null, 2);
                expandedSections.push(`
                    <div class="log-expanded-section">
                        <div class="log-expanded-label">Arguments</div>
                        <div class="log-expanded-args">${escapeHtml(argsJson)}</div>
                    </div>
                `);
            }
            
            // Duration (if available)
            if (entry.duration_ms !== undefined && entry.duration_ms !== null) {
                const durationStr = formatDuration(entry.duration_ms);
                expandedSections.push(`
                    <div class="log-expanded-section">
                        <div class="log-expanded-label">Duration</div>
                        <div class="log-expanded-duration">${durationStr} (${entry.duration_ms}ms)</div>
                    </div>
                `);
            }
            
            // Full error/stack trace (if error and more details)
            if (isFailure && entry.error) {
                expandedSections.push(`
                    <div class="log-expanded-section">
                        <div class="log-expanded-label">Error Details</div>
                        <div class="log-expanded-error">${escapeHtml(entry.error)}</div>
                    </div>
                `);
            }
            
            // Metadata section
            const metaItems = [];
            if (entry.command) {
                metaItems.push(`<span class="log-expanded-meta-item">ðŸ“‹ Command: <code>${escapeHtml(entry.command)}</code></span>`);
            }
            if (entry.user) {
                metaItems.push(`<span class="log-expanded-meta-item">${isAgent(entry.user) ? 'ðŸ¤–' : 'ðŸ‘¤'} User: ${escapeHtml(entry.user)}</span>`);
            }
            if (entry.result_id) {
                metaItems.push(`<span class="log-expanded-meta-item">ðŸ†” Result: ${linkifyEntityIds(entry.result_id)}</span>`);
            }
            
            if (metaItems.length > 0) {
                expandedSections.push(`
                    <div class="log-expanded-section">
                        <div class="log-expanded-label">Metadata</div>
                        <div class="log-expanded-meta">${metaItems.join('')}</div>
                    </div>
                `);
            }
            
            // Actions section with copy button
            const cliCommand = reconstructCLICommand(entry);
            expandedSections.push(`
                <div class="log-expanded-section log-actions-section">
                    <div class="log-expanded-label">CLI Command</div>
                    <div class="log-cli-command">
                        <code class="log-cli-code">${escapeHtml(cliCommand)}</code>
                        <button class="log-copy-btn" onclick="copyLogEntryCommandFromElement(event, this)" data-command="${escapeHtml(cliCommand).replace(/"/g, '&quot;')}" title="Copy to clipboard">
                            ðŸ“‹ Copy
                        </button>
                    </div>
                </div>
            `);
            
            const hasExpandedContent = expandedSections.length > 0;
            const expandIndicator = hasExpandedContent ? '<span class="log-expand-indicator">â–¼</span>' : '';
            
            return `
                <div class="card log-entry ${statusClass}" data-expandable="${hasExpandedContent}" onclick="toggleLogEntryExpand(event, this)">
                    <div class="log-header">
                        <div class="log-time">${statusBadge}${new Date(entry.timestamp).toLocaleString()}</div>
                        ${entry.user ? `<div class="log-user">${isAgent(entry.user) ? 'ðŸ¤–' : 'ðŸ‘¤'} ${escapeHtml(entry.user)}</div>` : ''}
                        ${expandIndicator}
                    </div>
                    <div class="card-title">${highlightedAction}</div>
                    ${highlightedDetails ? `<div class="log-details">${highlightedDetails}</div>` : ''}
                    ${isFailure && entry.error ? `<div class="log-error-msg">âŒ ${highlightedError}</div>` : ''}
                    ${hasExpandedContent ? `<div class="log-expanded-content">${expandedSections.join('')}</div>` : ''}
                </div>
            `;
        }
        
        // Render sessions with collapsible groups
        function renderSessionGroups(sessions, searchText, showingMixed) {
            return sessions.map((session, idx) => {
                const duration = session.endTime - session.startTime;
                const durationStr = formatDuration(duration);
                const isAgentSession = isAgent(session.agent);
                const agentIcon = isAgentSession ? 'ðŸ¤–' : 'ðŸ‘¤';
                
                // Create summary text
                const entryCount = session.entries.length;
                const failureText = session.failureCount > 0 
                    ? `<span style="color: var(--danger)">${session.failureCount} failed</span>` 
                    : '';
                
                // Format time range
                const startStr = new Date(session.startTime).toLocaleTimeString();
                const dateStr = new Date(session.startTime).toLocaleDateString();
                
                // Render entries
                const entriesHtml = session.entries.map(entry => 
                    renderLogEntry(entry, searchText, showingMixed)
                ).join('');
                
                return `
                    <div class="session-group" data-session-idx="${idx}">
                        <div class="session-header" onclick="toggleSession(${idx})">
                            <span class="session-toggle">â–¼</span>
                            <div class="session-info">
                                <span class="session-time">${dateStr} ${startStr}</span>
                                <span class="session-agent">${agentIcon} ${escapeHtml(session.agent)}</span>
                                <span class="session-summary">
                                    <span class="count">${entryCount} actions</span>
                                    ${failureText}
                                    <span class="duration">(${durationStr})</span>
                                </span>
                            </div>
                        </div>
                        <div class="session-entries">
                            ${entriesHtml}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Toggle session collapse/expand
        function toggleSession(idx) {
            const group = document.querySelector(`.session-group[data-session-idx="${idx}"]`);
            if (group) {
                group.classList.toggle('collapsed');
            }
        }
        
        // Toggle log entry expansion
        function toggleLogEntryExpand(event, element) {
            // Don't expand if clicking on a link inside the entry
            if (event.target.closest('.entity-link')) {
                return;
            }
            
            // Only toggle if the entry has expandable content
            if (element.dataset.expandable !== 'true') {
                return;
            }
            
            // If clicking on expanded content area (except for close action), don't collapse
            if (event.target.closest('.log-expanded-content') && element.classList.contains('expanded')) {
                return;
            }
            
            element.classList.toggle('expanded');
        }
        
        // Collapse all expanded log entries (called on Escape)
        function collapseAllLogEntries() {
            document.querySelectorAll('.log-entry.expanded').forEach(entry => {
                entry.classList.remove('expanded');
            });
        }
        
        // === Log Keyboard Navigation ===
        
        // Get all visible log entries (respects current view mode)
        function getVisibleLogEntries() {
            const list = document.getElementById('log-list');
            if (!list) return [];
            return Array.from(list.querySelectorAll('.log-entry'));
        }
        
        // Clear keyboard focus from log entries
        function clearLogKeyboardFocus() {
            document.querySelectorAll('.log-entry.keyboard-focused').forEach(entry => {
                entry.classList.remove('keyboard-focused');
            });
            state.logKeyboard.focusedIndex = -1;
            state.logKeyboard.enabled = false;
        }
        
        // Set keyboard focus on a log entry by index
        function setLogKeyboardFocus(index) {
            const entries = getVisibleLogEntries();
            if (entries.length === 0) return;
            
            // Clear previous focus
            document.querySelectorAll('.log-entry.keyboard-focused').forEach(entry => {
                entry.classList.remove('keyboard-focused');
            });
            
            // Clamp index to valid range
            const clampedIndex = Math.max(0, Math.min(entries.length - 1, index));
            state.logKeyboard.focusedIndex = clampedIndex;
            state.logKeyboard.enabled = true;
            
            // Apply focus
            const entry = entries[clampedIndex];
            if (entry) {
                entry.classList.add('keyboard-focused');
                // Scroll into view
                entry.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }
        
        // Move keyboard focus up/down
        function moveLogKeyboardFocus(direction) {
            const entries = getVisibleLogEntries();
            if (entries.length === 0) return;
            
            let newIndex;
            if (state.logKeyboard.focusedIndex === -1) {
                // Start from top or bottom depending on direction
                newIndex = direction > 0 ? 0 : entries.length - 1;
            } else {
                newIndex = state.logKeyboard.focusedIndex + direction;
                // Clamp to valid range
                newIndex = Math.max(0, Math.min(entries.length - 1, newIndex));
            }
            
            setLogKeyboardFocus(newIndex);
        }
        
        // Toggle expansion on the focused log entry
        function toggleFocusedLogEntry() {
            const entries = getVisibleLogEntries();
            if (state.logKeyboard.focusedIndex < 0 || state.logKeyboard.focusedIndex >= entries.length) return;
            
            const entry = entries[state.logKeyboard.focusedIndex];
            if (entry && entry.dataset.expandable === 'true') {
                entry.classList.toggle('expanded');
            }
        }
        
        // Copy CLI command from the focused log entry
        function copyFocusedLogEntryCommand() {
            const entries = getVisibleLogEntries();
            if (state.logKeyboard.focusedIndex < 0 || state.logKeyboard.focusedIndex >= entries.length) return;
            
            const entry = entries[state.logKeyboard.focusedIndex];
            if (!entry) return;
            
            // Find the CLI code element within this entry
            const cliCode = entry.querySelector('.log-cli-code');
            if (cliCode) {
                const command = cliCode.textContent.trim();
                navigator.clipboard.writeText(command).then(() => {
                    // Show brief feedback
                    const copyBtn = entry.querySelector('.log-cli-copy');
                    if (copyBtn) {
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = 'âœ“';
                        setTimeout(() => { copyBtn.textContent = originalText; }, 1000);
                    }
                });
            }
        }
        
        // Focus the log search input
        function focusLogSearch() {
            const searchInput = document.getElementById('log-search');
            if (searchInput) {
                searchInput.focus();
                searchInput.select();
            }
        }
        
        // Log view keyboard event handler
        function handleLogKeyboardNavigation(e) {
            // Only handle when in log view
            if (state.currentView !== 'log') return;
            
            // Don't handle if focus is in an input
            const activeEl = document.activeElement;
            const isInInput = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA');
            
            // '/' focuses search even from input (standard shortcut)
            if (e.key === '/' && !isInInput) {
                e.preventDefault();
                focusLogSearch();
                return;
            }
            
            // Don't handle other keys if in input
            if (isInInput) return;
            
            // Navigation keys
            switch (e.key) {
                case 'j':
                case 'ArrowDown':
                    e.preventDefault();
                    moveLogKeyboardFocus(1);
                    break;
                    
                case 'k':
                case 'ArrowUp':
                    e.preventDefault();
                    moveLogKeyboardFocus(-1);
                    break;
                    
                case 'Enter':
                    if (state.logKeyboard.enabled && state.logKeyboard.focusedIndex >= 0) {
                        e.preventDefault();
                        toggleFocusedLogEntry();
                    }
                    break;
                    
                case 'Escape':
                    // First collapse expanded entries, then clear focus
                    const expandedEntries = document.querySelectorAll('.log-entry.expanded');
                    if (expandedEntries.length > 0) {
                        e.preventDefault();
                        collapseAllLogEntries();
                    } else if (state.logKeyboard.enabled) {
                        e.preventDefault();
                        clearLogKeyboardFocus();
                    }
                    break;
                    
                case 'c':
                    if (state.logKeyboard.enabled && state.logKeyboard.focusedIndex >= 0) {
                        e.preventDefault();
                        copyFocusedLogEntryCommand();
                    }
                    break;
            }
        }
        
        // Add log keyboard navigation listener
        document.addEventListener('keydown', handleLogKeyboardNavigation);
        
        // Clear keyboard focus when clicking elsewhere in log list or switching views
        document.addEventListener('click', (e) => {
            if (state.currentView === 'log') {
                // If clicking on a log entry, update focus to that entry
                const clickedEntry = e.target.closest('.log-entry');
                if (clickedEntry) {
                    const entries = getVisibleLogEntries();
                    const index = entries.indexOf(clickedEntry);
                    if (index >= 0) {
                        setLogKeyboardFocus(index);
                    }
                } else {
                    // Clicked elsewhere, clear focus
                    clearLogKeyboardFocus();
                }
            }
        });

        // Find an entity (task, bug, idea) by ID
        function findEntityById(id) {
            if (!id) return null;
            const allEntities = [...(state.tasks || []), ...(state.bugs || []), ...(state.ideas || [])];
            return allEntities.find(e => e.id === id);
        }
        
        // Convert entity IDs in text to clickable links
        // Matches: bn-xxxx, bnt-xxxx, bnq-xxxx (4 hex chars)
        function linkifyEntityIds(text) {
            if (!text) return '';
            // Pattern matches entity IDs: bn-, bnt-, bnq- followed by 4 hex chars
            const entityPattern = /\b(bn-[a-f0-9]{4}|bnt-[a-f0-9]{4}|bnq-[a-f0-9]{4})\b/gi;
            return text.replace(entityPattern, (match) => {
                return `<span class="entity-link" data-entity-id="${match.toLowerCase()}">${match}</span>`;
            });
        }
        
        // Navigate to an entity in the graph view
        function navigateToEntity(entityId) {
            if (!entityId) return;
            
            // Switch to graph view
            switchView('graph');
            
            // Disable auto-follow to prevent interference
            state.graph.autoFollow = false;
            cancelFocusPeriod();  // Cancel any active focus period
            updateAutoFollowDisplay();
            
            // Find and pan to the node
            const node = state.graph.nodes.find(n => n.id === entityId);
            if (node) {
                // Pan to node with zoom
                panToNode(entityId, true);
                
                // Select the node and show info panel
                state.graph.selectedNode = node;
                showInfoPanel(node);
                
                // Add a temporary highlight effect
                highlightNodeTemporarily(entityId);
            }
        }
        
        // Temporarily highlight a node with a pulse animation
        function highlightNodeTemporarily(nodeId) {
            // Store the highlighted node and start time
            state.graph.tempHighlightNode = nodeId;
            state.graph.tempHighlightStart = performance.now();
            state.graph.tempHighlightDuration = 1500; // 1.5 seconds
        }
        
        // Attach click handlers for entity links (call after rendering log content)
        function attachEntityLinkHandlers(container) {
            if (!container) return;
            container.querySelectorAll('.entity-link').forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const entityId = e.target.getAttribute('data-entity-id');
                    navigateToEntity(entityId);
                });
            });
        }


        function renderEmptyState(ctx, message) {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(message, ctx.canvas.width / 2, ctx.canvas.height / 2);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Edge filter UI functions
        function getEdgeCategoryColor(category) {
            const styles = getComputedStyle(document.documentElement);
            switch (category) {
                case 'blocking': return styles.getPropertyValue('--edge-blocking').trim();
                case 'informational': return styles.getPropertyValue('--edge-informational').trim();
                case 'fixes': return styles.getPropertyValue('--edge-fixes').trim();
                case 'hierarchy': return styles.getPropertyValue('--edge-hierarchy').trim();
                case 'queued': return styles.getPropertyValue('--edge-queued').trim();
                default: return styles.getPropertyValue('--edge-default').trim();
            }
        }

        function initializeEdgeFilters() {
            const container = document.getElementById('sidebar-edge-filters');
            if (!container) return;
            
            // Create filter buttons for each edge type
            container.innerHTML = '';
            
            // Add "All" toggle button first
            const allBtn = document.createElement('button');
            allBtn.className = 'edge-filter-btn edge-filter-all';
            allBtn.textContent = 'All';
            allBtn.title = 'Toggle all edge types';
            
            const updateAllBtnState = () => {
                const allActive = Object.keys(EDGE_TYPES).every(type => state.edgeFilters[type]);
                allBtn.classList.toggle('active', allActive);
            };
            
            // Update spring button state (independent of visibility)
            const updateSpringBtnState = (springBtn, type) => {
                springBtn.title = state.edgeSpringFilters[type] 
                    ? `Disable spring physics for ${EDGE_TYPES[type].name} edges`
                    : `Enable spring physics for ${EDGE_TYPES[type].name} edges`;
            };
            
            allBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const allActive = Object.keys(EDGE_TYPES).every(type => state.edgeFilters[type]);
                const newState = !allActive;
                
                for (const type of Object.keys(EDGE_TYPES)) {
                    state.edgeFilters[type] = newState;
                }
                
                // Update all visibility button states
                container.querySelectorAll('.edge-visibility-btn').forEach(visBtn => {
                    const type = visBtn.dataset.edgeType;
                    if (type) {
                        visBtn.classList.toggle('active', newState);
                        visBtn.title = newState 
                            ? `Hide ${EDGE_TYPES[type].name} edges`
                            : `Show ${EDGE_TYPES[type].name} edges`;
                    }
                });
                // Update all label button states (active when BOTH visible AND spring)
                container.querySelectorAll('.edge-filter-btn[data-edge-type]').forEach(btn => {
                    const type = btn.dataset.edgeType;
                    btn.classList.toggle('active', newState && state.edgeSpringFilters[type]);
                });
                // Update all spring button states
                container.querySelectorAll('.edge-spring-btn').forEach(springBtn => {
                    const type = springBtn.dataset.edgeType;
                    if (type) updateSpringBtnState(springBtn, type);
                });
                updateAllBtnState();
                saveEdgeFilters(state.edgeFilters);
                startAnimation();  // Restart animation to apply edge filter
            });
            
            container.appendChild(allBtn);
            
            for (const [type, info] of Object.entries(EDGE_TYPES)) {
                // Create row container: [eye visibility] [color label] [magnet spring]
                const row = document.createElement('div');
                row.className = 'edge-filter-row';
                
                // Create eye visibility button (toggles visibility only)
                const visBtn = document.createElement('button');
                visBtn.className = 'edge-visibility-btn' + (state.edgeFilters[type] ? ' active' : '');
                visBtn.dataset.edgeType = type;
                visBtn.innerHTML = 'ðŸ‘';
                visBtn.title = state.edgeFilters[type] 
                    ? `Hide ${info.name} edges`
                    : `Show ${info.name} edges`;
                
                // Create color label button (toggles BOTH visibility AND magnet)
                const btn = document.createElement('button');
                btn.className = 'edge-filter-btn' + (state.edgeFilters[type] && state.edgeSpringFilters[type] ? ' active' : '');
                btn.dataset.edgeType = type;
                btn.title = `Toggle ${info.name} visibility and physics`;
                
                const dot = document.createElement('span');
                dot.className = 'edge-filter-dot';
                dot.style.backgroundColor = getEdgeCategoryColor(info.category);
                
                btn.appendChild(dot);
                btn.appendChild(document.createTextNode(info.name));
                
                // Create spring toggle button (toggles magnet/physics only)
                const springBtn = document.createElement('button');
                springBtn.className = 'edge-spring-btn' + (state.edgeSpringFilters[type] ? ' active' : '');
                springBtn.dataset.edgeType = type;
                springBtn.innerHTML = 'ðŸ§²';  // Magnet emoji for springiness
                updateSpringBtnState(springBtn, type);
                
                // Helper to update visibility button state
                const updateVisBtnState = () => {
                    visBtn.classList.toggle('active', state.edgeFilters[type]);
                    visBtn.title = state.edgeFilters[type] 
                        ? `Hide ${info.name} edges`
                        : `Show ${info.name} edges`;
                };
                
                // Helper to update label button state (active when BOTH visible AND spring are on)
                const updateLabelBtnState = () => {
                    btn.classList.toggle('active', state.edgeFilters[type] && state.edgeSpringFilters[type]);
                };
                
                // Eye button: toggle visibility only
                visBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    state.edgeFilters[type] = !state.edgeFilters[type];
                    updateVisBtnState();
                    updateLabelBtnState();
                    updateSpringBtnState(springBtn, type);
                    updateAllBtnState();
                    saveEdgeFilters(state.edgeFilters);
                    startAnimation();
                });
                
                // Label button: toggle BOTH visibility AND magnet together
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // If both are on, turn both off; otherwise turn both on
                    const bothActive = state.edgeFilters[type] && state.edgeSpringFilters[type];
                    const newState = !bothActive;
                    state.edgeFilters[type] = newState;
                    state.edgeSpringFilters[type] = newState;
                    updateVisBtnState();
                    updateLabelBtnState();
                    springBtn.classList.toggle('active', newState);
                    updateSpringBtnState(springBtn, type);
                    updateAllBtnState();
                    saveEdgeFilters(state.edgeFilters);
                    saveEdgeSpringFilters(state.edgeSpringFilters);
                    startAnimation();
                });
                
                // Magnet button: toggle spring physics only (independent of visibility)
                springBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    state.edgeSpringFilters[type] = !state.edgeSpringFilters[type];
                    springBtn.classList.toggle('active', state.edgeSpringFilters[type]);
                    updateLabelBtnState();
                    updateSpringBtnState(springBtn, type);
                    saveEdgeSpringFilters(state.edgeSpringFilters);
                    startAnimation();
                });
                
                row.appendChild(visBtn);
                row.appendChild(btn);
                row.appendChild(springBtn);
                container.appendChild(row);
            }
            
            updateAllBtnState();
            
            // Reapply sidebar search filter if active
            if (sidebarSearchQuery) {
                filterEdgesSection(sidebarSearchQuery);
            }
        }

        // Global escape key handler to close modals
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close terminate modal if open
                const terminateModal = document.getElementById('terminate-modal');
                if (terminateModal && terminateModal.style.display !== 'none') {
                    closeTerminateModal();
                    e.preventDefault();
                    return;
                }
                // Close edge info panel if open
                const edgeInfoPanel = document.getElementById('edge-info-panel');
                if (edgeInfoPanel && edgeInfoPanel.classList.contains('visible')) {
                    state.graph.selectedEdge = null;
                    updateEdgeInfoPanel(null);
                    e.preventDefault();
                    return;
                }
                // Log entry collapse is handled by handleLogKeyboardNavigation when in log view
                // Only handle here for other views (e.g., info panel activity log)
                if (state.currentView !== 'log') {
                    const expandedEntries = document.querySelectorAll('.log-entry.expanded');
                    if (expandedEntries.length > 0) {
                        collapseAllLogEntries();
                        e.preventDefault();
                        return;
                    }
                }
            }
        });

        // Collapsible sidebar sections
        const SIDEBAR_COLLAPSE_KEY = 'binnacle_sidebar_collapsed';
        
        function loadSidebarCollapseState() {
            try {
                const saved = localStorage.getItem(SIDEBAR_COLLAPSE_KEY);
                return saved ? JSON.parse(saved) : {};
            } catch {
                return {};
            }
        }
        
        function saveSidebarCollapseState(state) {
            try {
                localStorage.setItem(SIDEBAR_COLLAPSE_KEY, JSON.stringify(state));
            } catch {
                // Ignore localStorage errors
            }
        }
        
        function initializeCollapsibleSections() {
            const collapsedState = loadSidebarCollapseState();
            const sections = document.querySelectorAll('.sidebar-section.collapsible');
            
            sections.forEach(section => {
                const sectionKey = section.dataset.section;
                const title = section.querySelector('.sidebar-section-title');
                
                // Restore collapsed state
                if (sectionKey && collapsedState[sectionKey]) {
                    section.classList.add('collapsed');
                }
                
                // Add click handler to title
                if (title) {
                    title.addEventListener('click', () => {
                        section.classList.toggle('collapsed');
                        
                        // Save state
                        if (sectionKey) {
                            const newState = loadSidebarCollapseState();
                            newState[sectionKey] = section.classList.contains('collapsed');
                            saveSidebarCollapseState(newState);
                        }
                    });
                }
            });
        }

        // Initialize sidebar search functionality
        function initializeSidebarSearch() {
            const input = document.getElementById('sidebar-search');
            if (!input) return;

            input.addEventListener('input', () => {
                sidebarSearchQuery = input.value.toLowerCase();
                applySidebarFilter();
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    input.value = '';
                    sidebarSearchQuery = '';
                    applySidebarFilter();
                    e.preventDefault();
                }
            });
        }

        // Apply sidebar search filter to all sections
        function applySidebarFilter() {
            const query = sidebarSearchQuery.trim();
            
            // Filter agents section
            filterAgentsSection(query);
            
            // Filter nodes section
            filterNodesSection(query);
            
            // Filter edges section
            filterEdgesSection(query);
        }

        // Filter agents sidebar items
        function filterAgentsSection(query) {
            const agentsSection = document.getElementById('agents-section');
            const list = document.getElementById('agents-sidebar-list');
            if (!list || !agentsSection) return;

            const items = list.querySelectorAll('.agents-sidebar-item');
            let visibleCount = 0;

            items.forEach(item => {
                const name = item.querySelector('.agents-sidebar-item-name');
                const task = item.querySelector('.agents-sidebar-item-task');
                const agentId = item.dataset.agentId || '';
                
                const nameText = name ? name.textContent.toLowerCase() : '';
                const taskText = task ? task.textContent.toLowerCase() : '';
                const idText = agentId.toLowerCase();
                
                const matches = !query || 
                    nameText.includes(query) || 
                    taskText.includes(query) || 
                    idText.includes(query);
                
                item.classList.toggle('filtered-hidden', !matches);
                if (matches) visibleCount++;
            });

            // Show/hide empty message
            const emptyMsg = list.querySelector('.agents-sidebar-empty');
            if (emptyMsg) {
                emptyMsg.style.display = visibleCount === 0 && !query ? '' : 'none';
            }

            // Hide section if no matches (and there was a query)
            agentsSection.classList.toggle('filtered-empty', visibleCount === 0 && query);
        }

        // Filter nodes section items
        function filterNodesSection(query) {
            const container = document.getElementById('sidebar-node-filters');
            const section = container?.closest('.sidebar-section');
            if (!container || !section) return;

            const rows = container.querySelectorAll('.node-filter-row');
            let visibleCount = 0;

            rows.forEach(row => {
                const btn = row.querySelector('.node-filter-btn');
                if (!btn) return;
                
                const text = btn.textContent.toLowerCase();
                const matches = !query || text.includes(query);
                
                row.classList.toggle('filtered-hidden', !matches);
                if (matches) visibleCount++;
            });

            // Handle "All" button visibility
            const allBtn = container.querySelector('.node-filter-all');
            if (allBtn) {
                allBtn.classList.toggle('filtered-hidden', query && visibleCount === 0);
            }

            section.classList.toggle('filtered-empty', visibleCount === 0 && query);
        }

        // Filter edges section items
        function filterEdgesSection(query) {
            const container = document.getElementById('sidebar-edge-filters');
            const section = container?.closest('.sidebar-section');
            if (!container || !section) return;

            const rows = container.querySelectorAll('.edge-filter-row');
            let visibleCount = 0;

            rows.forEach(row => {
                const btn = row.querySelector('.edge-filter-btn');
                if (!btn) return;
                
                const text = btn.textContent.toLowerCase();
                const matches = !query || text.includes(query);
                
                row.classList.toggle('filtered-hidden', !matches);
                if (matches) visibleCount++;
            });

            // Handle "All" button visibility
            const allBtn = container.querySelector('.edge-filter-all');
            if (allBtn) {
                allBtn.classList.toggle('filtered-hidden', query && visibleCount === 0);
            }

            section.classList.toggle('filtered-empty', visibleCount === 0 && query);
        }

        // Update filter chip UI to reflect current state
        function updateFilterChipUI() {
            const chipContainer = document.getElementById('command-filter-chips');
            if (!chipContainer) return;
            
            const categories = state.logFilters.commandCategories;
            chipContainer.querySelectorAll('.filter-chip').forEach(chip => {
                const cat = chip.dataset.category;
                if (cat === 'all') {
                    // "All" is active when no specific categories are selected
                    chip.classList.toggle('active', categories.length === 0);
                } else {
                    chip.classList.toggle('active', categories.includes(cat));
                }
            });
        }

        // Save log filters to URL for persistence and sharing
        function saveLogFiltersToURL() {
            const params = new URLSearchParams(window.location.search);
            const filters = state.logFilters;
            
            // Command categories (multi-select)
            if (filters.commandCategories.length > 0) {
                params.set('categories', filters.commandCategories.join(','));
            } else {
                params.delete('categories');
            }
            
            // User filter
            if (filters.userFilter !== 'all') {
                params.set('user', filters.userFilter);
            } else {
                params.delete('user');
            }
            
            // Status filter
            if (filters.statusFilter !== 'all') {
                params.set('status', filters.statusFilter);
            } else {
                params.delete('status');
            }
            
            // Search text
            if (filters.searchText) {
                params.set('search', filters.searchText);
            } else {
                params.delete('search');
            }
            
            // Date range
            if (filters.dateRange !== 'all') {
                params.set('date', filters.dateRange);
            } else {
                params.delete('date');
            }
            
            // Custom date range
            if (filters.dateRange === 'custom') {
                if (filters.customDateFrom) {
                    params.set('from', filters.customDateFrom);
                } else {
                    params.delete('from');
                }
                if (filters.customDateTo) {
                    params.set('to', filters.customDateTo);
                } else {
                    params.delete('to');
                }
            } else {
                params.delete('from');
                params.delete('to');
            }
            
            // View mode (flat or grouped)
            if (filters.viewMode && filters.viewMode !== 'flat') {
                params.set('view', filters.viewMode);
            } else {
                params.delete('view');
            }
            
            // Update URL without page reload
            const newURL = params.toString() 
                ? `${window.location.pathname}?${params.toString()}`
                : window.location.pathname;
            window.history.replaceState({}, '', newURL);
        }

        // Load log filters from URL on page load
        function loadLogFiltersFromURL() {
            const params = new URLSearchParams(window.location.search);
            
            // Command categories (multi-select)
            const categories = params.get('categories');
            if (categories) {
                state.logFilters.commandCategories = categories.split(',').filter(c => 
                    ['tasks', 'tests', 'links', 'bugs', 'ideas', 'docs', 'system', 'queue'].includes(c)
                );
            }
            
            // User filter
            const user = params.get('user');
            if (user) {
                state.logFilters.userFilter = user;
            }
            
            // Status filter
            const status = params.get('status');
            if (status && ['success', 'failure'].includes(status)) {
                state.logFilters.statusFilter = status;
            }
            
            // Search text
            const search = params.get('search');
            if (search) {
                state.logFilters.searchText = search;
                // Also update the search input field
                const searchInput = document.getElementById('log-search');
                if (searchInput) searchInput.value = search;
            }
            
            // Date range
            const date = params.get('date');
            if (date && ['hour', 'day', 'week', 'month', 'custom'].includes(date)) {
                state.logFilters.dateRange = date;
            }
            
            // Custom date range
            const dateFrom = params.get('from');
            const dateTo = params.get('to');
            if (dateFrom) {
                state.logFilters.customDateFrom = dateFrom;
            }
            if (dateTo) {
                state.logFilters.customDateTo = dateTo;
            }
            
            // View mode (flat or grouped)
            const viewMode = params.get('view');
            if (viewMode && ['flat', 'grouped'].includes(viewMode)) {
                state.logFilters.viewMode = viewMode;
                // Update view toggle buttons
                document.querySelectorAll('.view-toggle-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.view === viewMode);
                });
            }
            
            // Update UI to reflect loaded state
            updateFilterChipUI();
            updateFilterUIFromState();
        }

        // Update other filter UI elements from state
        function updateFilterUIFromState() {
            const filters = state.logFilters;
            
            // User filter dropdown
            const userSelect = document.getElementById('user-filter');
            if (userSelect) userSelect.value = filters.userFilter;
            
            // Status toggle
            const statusToggle = document.getElementById('status-filter-toggle');
            if (statusToggle) {
                statusToggle.querySelectorAll('.status-toggle-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.status === filters.statusFilter);
                });
            }
            
            // Date presets
            const datePresets = document.getElementById('date-filter-presets');
            if (datePresets) {
                datePresets.querySelectorAll('.date-preset-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.range === filters.dateRange);
                });
            }
            
            // Custom date range inputs
            const customDateRange = document.getElementById('custom-date-range');
            if (customDateRange) {
                customDateRange.classList.toggle('visible', filters.dateRange === 'custom');
            }
            const dateFromInput = document.getElementById('date-from');
            const dateToInput = document.getElementById('date-to');
            if (dateFromInput) dateFromInput.value = filters.customDateFrom || '';
            if (dateToInput) dateToInput.value = filters.customDateTo || '';
        }

        // Initialize Activity Log filters
        function initializeLogFilters() {
            // Load filters from URL on init
            loadLogFiltersFromURL();
            
            // Command category filter chips (multi-select)
            const chipContainer = document.getElementById('command-filter-chips');
            if (chipContainer) {
                chipContainer.addEventListener('click', (e) => {
                    const chip = e.target.closest('.filter-chip');
                    if (!chip) return;
                    
                    const category = chip.dataset.category;
                    
                    if (category === 'all') {
                        // "All" clears the filter (empty array = show all)
                        state.logFilters.commandCategories = [];
                    } else {
                        // Toggle the category in the array
                        const idx = state.logFilters.commandCategories.indexOf(category);
                        if (idx === -1) {
                            state.logFilters.commandCategories.push(category);
                        } else {
                            state.logFilters.commandCategories.splice(idx, 1);
                        }
                    }
                    
                    // Update active states
                    updateFilterChipUI();
                    saveLogFiltersToURL();
                    renderLog();
                });
            }
            
            // User filter dropdown
            const userSelect = document.getElementById('user-filter');
            if (userSelect) {
                userSelect.addEventListener('change', (e) => {
                    state.logFilters.userFilter = e.target.value;
                    saveLogFiltersToURL();
                    renderLog();
                });
            }
            
            // Status filter toggle
            const statusToggle = document.getElementById('status-filter-toggle');
            if (statusToggle) {
                statusToggle.addEventListener('click', (e) => {
                    const btn = e.target.closest('.status-toggle-btn');
                    if (!btn) return;
                    
                    const status = btn.dataset.status;
                    state.logFilters.statusFilter = status;
                    
                    // Update active state
                    statusToggle.querySelectorAll('.status-toggle-btn').forEach(b => {
                        b.classList.toggle('active', b.dataset.status === status);
                    });
                    
                    saveLogFiltersToURL();
                    renderLog();
                });
            }
            
            // Text search with debounce
            const searchInput = document.getElementById('log-search');
            if (searchInput) {
                let searchTimeout;
                searchInput.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        state.logFilters.searchText = e.target.value.trim();
                        saveLogFiltersToURL();
                        renderLog();
                    }, 200); // 200ms debounce
                });
            }
            
            // Date range presets
            const datePresets = document.getElementById('date-filter-presets');
            const customDateRange = document.getElementById('custom-date-range');
            if (datePresets) {
                datePresets.addEventListener('click', (e) => {
                    const btn = e.target.closest('.date-preset-btn');
                    if (!btn) return;
                    
                    const range = btn.dataset.range;
                    state.logFilters.dateRange = range;
                    
                    // Update active state
                    datePresets.querySelectorAll('.date-preset-btn').forEach(b => {
                        b.classList.toggle('active', b.dataset.range === range);
                    });
                    
                    // Show/hide custom date range inputs
                    if (customDateRange) {
                        customDateRange.classList.toggle('visible', range === 'custom');
                    }
                    
                    saveLogFiltersToURL();
                    renderLog();
                });
            }
            
            // Custom date range inputs
            const dateFromInput = document.getElementById('date-from');
            const dateToInput = document.getElementById('date-to');
            
            if (dateFromInput) {
                dateFromInput.addEventListener('change', (e) => {
                    state.logFilters.customDateFrom = e.target.value;
                    saveLogFiltersToURL();
                    renderLog();
                });
            }
            
            if (dateToInput) {
                dateToInput.addEventListener('change', (e) => {
                    state.logFilters.customDateTo = e.target.value;
                    saveLogFiltersToURL();
                    renderLog();
                });
            }
            
            // View mode toggle (Flat / Sessions)
            const viewToggleButtons = document.querySelectorAll('.view-toggle-btn');
            viewToggleButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const viewMode = btn.dataset.view;
                    state.logFilters.viewMode = viewMode;
                    
                    // Update active state
                    viewToggleButtons.forEach(b => {
                        b.classList.toggle('active', b.dataset.view === viewMode);
                    });
                    
                    saveLogFiltersToURL();
                    renderLog();
                });
            });
        }

        // Initialize
        initializeCollapsibleSections();
        initializeSidebarSearch();
        initializeEdgeFilters();
        initializeStatFilters();
        initializeLogFilters();
        setupLogInfiniteScroll();
        updateAutoFollowDisplay();
        updateHideCompletedDisplay();
        initializeGraphSearch();
        initializeViewSearch();
        connectWebSocket();
        
        // Periodically refresh the recently completed pane to keep "time ago" display current
        setInterval(() => {
            updateRecentlyCompletedPane();
        }, 30000); // Refresh every 30 seconds
    </script>
</body>
</html>
