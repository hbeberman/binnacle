<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binnacle - Project State Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a2332;
            --bg-secondary: #243447;
            --bg-tertiary: #2d4059;
            --text-primary: #e8edf3;
            --text-secondary: #b8c5d6;
            --accent-blue: #4a90e2;
            --accent-light: #6aa8f0;
            --border-color: #3a4d66;
            --success: #5cb85c;
            --warning: #f0ad4e;
            --danger: #d9534f;
            --info: #5bc0de;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            border-bottom: 2px solid var(--border-color);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--accent-light);
        }

        .subtitle {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        nav {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
        }

        .nav-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-light);
        }

        main {
            flex: 1;
            overflow: auto;
            padding: 2rem;
        }

        .view {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .view.active {
            display: block;
        }

        #graph-view {
            position: relative;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #graph-canvas {
            width: 100%;
            height: calc(100vh - 200px);
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .task-list, .test-list, .log-list {
            display: grid;
            gap: 1rem;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            border-color: var(--accent-blue);
        }

        .card-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .card-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.75rem;
        }

        .badge {
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .badge-priority-0 { background: var(--danger); color: white; }
        .badge-priority-1 { background: var(--warning); color: white; }
        .badge-priority-2 { background: var(--info); color: white; }
        .badge-priority-3 { background: var(--success); color: white; }

        .badge-status-pending { background: var(--info); color: white; }
        .badge-status-in_progress { background: var(--warning); color: white; }
        .badge-status-blocked { background: var(--danger); color: white; }
        .badge-status-done { background: var(--success); color: white; }

        .badge-tag {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .log-entry {
            padding: 1rem;
            border-left: 3px solid var(--accent-blue);
        }

        .log-time {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .connection-status {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-connected { background: var(--success); }
        .status-disconnected { background: var(--danger); animation: none; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .node-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: var(--text-primary);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .node-tooltip.visible {
            display: block;
        }

        .zoom-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: row;
            gap: 0.5rem;
            z-index: 100;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: var(--accent-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
        }

        .zoom-level {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            font-size: 0.85rem;
            text-align: center;
            color: var(--text-secondary);
            min-width: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tooltip-title {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: var(--accent-light);
        }

        .tooltip-id {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-family: monospace;
            margin-bottom: 0.5rem;
        }

        .tooltip-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        #graph-canvas {
            cursor: default;
        }

        #graph-canvas.hovering:not(.dragging) {
            cursor: grab;
        }

        #graph-canvas.dragging {
            cursor: grabbing;
        }

        .info-panel {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 320px;
            max-height: calc(100% - 2rem);
            background: rgba(0, 0, 0, 0.85);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .info-panel.visible {
            opacity: 1;
            visibility: visible;
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .info-panel-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .info-panel-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: color 0.2s ease;
        }

        .info-panel-close:hover {
            color: var(--text-primary);
        }

        .info-panel-id {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--accent-light);
            margin-bottom: 0.5rem;
        }

        .info-panel-task-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1rem;
            line-height: 1.4;
        }

        .info-panel-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .info-panel-section {
            margin-bottom: 1rem;
        }

        .info-panel-section-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .info-panel-description {
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .info-panel-description.empty {
            color: var(--text-secondary);
            font-style: italic;
        }

        .info-panel-deps {
            list-style: none;
        }

        .info-panel-deps li {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--accent-light);
            padding: 0.25rem 0;
        }

        .info-panel-deps li:before {
            content: "â†’ ";
            color: var(--text-secondary);
        }

        .info-panel-closed-reason {
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.6;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border-left: 3px solid var(--success);
        }

    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸ§­ Binnacle</h1>
            <p class="subtitle">Project State Tracker</p>
            <nav>
                <button class="nav-btn active" data-view="graph">Task Graph</button>
                <button class="nav-btn" data-view="ready">Ready Tasks</button>
                <button class="nav-btn" data-view="tests">Tests</button>
                <button class="nav-btn" data-view="log">Activity Log</button>
            </nav>
        </header>

        <main>
            <div id="graph-view" class="view active">
                <canvas id="graph-canvas"></canvas>
                <div class="node-tooltip" id="node-tooltip">
                    <div class="tooltip-title" id="tooltip-title"></div>
                    <div class="tooltip-id" id="tooltip-id"></div>
                    <div class="tooltip-meta" id="tooltip-meta"></div>
                </div>
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoom-in" title="Zoom In">+</button>
                    <div class="zoom-level" id="zoom-level">100%</div>
                    <button class="zoom-btn" id="zoom-out" title="Zoom Out">âˆ’</button>
                    <button class="zoom-btn" id="zoom-reset" title="Reset Zoom">âŸ²</button>
                </div>
                <div class="info-panel" id="info-panel">
                    <div class="info-panel-header">
                        <span class="info-panel-title">Task Details</span>
                        <button class="info-panel-close" id="info-panel-close" title="Close">&times;</button>
                    </div>
                    <div id="info-panel-id" class="info-panel-id"></div>
                    <div id="info-panel-task-title" class="info-panel-task-title"></div>
                    <div id="info-panel-meta" class="info-panel-meta"></div>
                    <div id="info-panel-description-section" class="info-panel-section">
                        <div class="info-panel-section-title">Description</div>
                        <div id="info-panel-description" class="info-panel-description"></div>
                    </div>
                    <div id="info-panel-deps-section" class="info-panel-section" style="display: none;">
                        <div class="info-panel-section-title">Depends On</div>
                        <ul id="info-panel-deps" class="info-panel-deps"></ul>
                    </div>
                    <div id="info-panel-closed-section" class="info-panel-section" style="display: none;">
                        <div class="info-panel-section-title">Closed Reason</div>
                        <div id="info-panel-closed-reason" class="info-panel-closed-reason"></div>
                    </div>
                </div>
            </div>

            <div id="ready-view" class="view">
                <div class="task-list" id="ready-list"></div>
            </div>

            <div id="tests-view" class="view">
                <div class="test-list" id="test-list"></div>
            </div>

            <div id="log-view" class="view">
                <div class="log-list" id="log-list"></div>
            </div>
        </main>

        <div class="connection-status">
            <div class="status-dot status-disconnected" id="status-dot"></div>
            <span id="status-text">Connecting...</span>
        </div>
    </div>

    <script>
        // State management
        const state = {
            currentView: 'graph',
            tasks: [],
            ready: [],
            tests: [],
            log: [],
            ws: null,
            graph: {
                nodes: [],
                edges: [],
                hoveredNode: null,
                mouseX: 0,
                mouseY: 0,
                physics: {
                    damping: 0.92,
                    gravityStrength: 0.05,
                    gravityCenter: { x: 0, y: 0 },
                    repulsionStrength: 2500,
                    springStrength: 0.08,
                    springRestingLength: 200,
                    edgeAttractionEnabled: true,
                    maxVelocity: 3
                },
                // Viewport transformation
                viewport: {
                    panX: 0,
                    panY: 0,
                    zoom: 1.0,
                    minZoom: 0.1,
                    maxZoom: 3.0
                },
                // Drag state
                draggedNode: null,
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                dragNodeStartX: 0,
                dragNodeStartY: 0,
                dragStartTime: 0,
                dragLastX: 0,
                dragLastY: 0,
                // Canvas pan state
                isPanning: false,
                panStartX: 0,
                panStartY: 0,
                panStartOffsetX: 0,
                panStartOffsetY: 0,
                // Selection state
                selectedNode: null
            }
        };

        // WebSocket connection
        function connectWebSocket() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            state.ws = new WebSocket(`${protocol}//${location.host}/ws`);

            state.ws.onopen = () => {
                updateConnectionStatus(true);
                loadData();
            };

            state.ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.type === 'reload') {
                    loadData();
                }
            };

            state.ws.onclose = () => {
                updateConnectionStatus(false);
                setTimeout(connectWebSocket, 2000);
            };

            state.ws.onerror = () => {
                updateConnectionStatus(false);
            };
        }

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('status-dot');
            const text = document.getElementById('status-text');
            dot.className = `status-dot status-${connected ? 'connected' : 'disconnected'}`;
            text.textContent = connected ? 'Connected' : 'Disconnected';
        }

        // Data loading
        async function loadData() {
            await Promise.all([
                fetch('/api/tasks').then(r => r.json()).then(data => state.tasks = data.tasks),
                fetch('/api/ready').then(r => r.json()).then(data => state.ready = data.tasks),
                fetch('/api/tests').then(r => r.json()).then(data => state.tests = data.tests),
                fetch('/api/log').then(r => r.json()).then(data => state.log = data.log)
            ]);
            renderCurrentView();
        }

        // View switching
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const view = btn.dataset.view;
                switchView(view);
            });
        });

        function switchView(view) {
            state.currentView = view;
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-view="${view}"]`).classList.add('active');
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(`${view}-view`).classList.add('active');
            renderCurrentView();
        }

        // Rendering
        function renderCurrentView() {
            switch (state.currentView) {
                case 'graph':
                    renderGraph();
                    break;
                case 'ready':
                    renderReady();
                    break;
                case 'tests':
                    renderTests();
                    break;
                case 'log':
                    renderLog();
                    break;
            }
        }

        function renderGraph() {
            // This will be implemented with spring physics
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            if (state.tasks.length === 0) {
                renderEmptyState(ctx, 'No tasks yet');
                return;
            }

            // Build graph data structure
            buildGraphData();

            // Add mouse event listeners
            setupGraphMouseHandlers(canvas);

            // Initialize zoom display
            updateZoomDisplay();

            // Start animation loop
            requestAnimationFrame(animateGraph);
        }

        function setupGraphMouseHandlers(canvas) {
            // Remove old listeners to avoid duplicates
            const newCanvas = canvas.cloneNode(true);
            canvas.parentNode.replaceChild(newCanvas, canvas);
            const finalCanvas = document.getElementById('graph-canvas');

            finalCanvas.addEventListener('mousemove', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Handle canvas panning
                if (state.graph.isPanning) {
                    const dx = mouseX - state.graph.panStartX;
                    const dy = mouseY - state.graph.panStartY;
                    const zoom = state.graph.viewport.zoom;

                    // Update pan offset (inversely proportional to zoom)
                    state.graph.viewport.panX = state.graph.panStartOffsetX + dx / zoom;
                    state.graph.viewport.panY = state.graph.panStartOffsetY + dy / zoom;
                    return;
                }

                const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                if (state.graph.isDragging && state.graph.draggedNode) {
                    // Update dragged node position in world coordinates
                    const currentWorld = screenToWorld(mouseX, mouseY, finalCanvas);
                    const startWorld = screenToWorld(state.graph.dragStartX, state.graph.dragStartY, finalCanvas);
                    const dx = currentWorld.x - startWorld.x;
                    const dy = currentWorld.y - startWorld.y;
                    const node = state.graph.draggedNode;

                    node.x = state.graph.dragNodeStartX + dx;
                    node.y = state.graph.dragNodeStartY + dy;

                    // No boundary clamping for infinite canvas

                    // Track for momentum calculation
                    state.graph.dragLastX = mouseX;
                    state.graph.dragLastY = mouseY;

                    // Update tooltip position
                    updateTooltip(node, e.clientX, e.clientY);
                } else {
                    // Normal hover behavior - use world coordinates
                    state.graph.mouseX = worldPos.x;
                    state.graph.mouseY = worldPos.y;

                    // Find hovered node using world coordinates
                    const hoveredNode = state.graph.nodes.find(node => {
                        const dx = worldPos.x - node.x;
                        const dy = worldPos.y - node.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= node.radius;
                    });

                    if (hoveredNode !== state.graph.hoveredNode) {
                        state.graph.hoveredNode = hoveredNode;
                        updateTooltip(hoveredNode, e.clientX, e.clientY);
                        finalCanvas.classList.toggle('hovering', !!hoveredNode);
                    }
                }
            });

            finalCanvas.addEventListener('mouseleave', () => {
                // End any active drag
                if (state.graph.isDragging && state.graph.draggedNode) {
                    // Apply gentle stop (no momentum on mouse leave)
                    state.graph.draggedNode.vx = 0;
                    state.graph.draggedNode.vy = 0;
                    state.graph.isDragging = false;
                    state.graph.draggedNode = null;
                }

                // End any active pan
                if (state.graph.isPanning) {
                    state.graph.isPanning = false;
                    finalCanvas.style.cursor = 'default';
                }

                state.graph.hoveredNode = null;
                updateTooltip(null);
                finalCanvas.classList.remove('hovering', 'dragging');
            });

            finalCanvas.addEventListener('mousedown', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Middle mouse or Shift+Left mouse = always canvas pan
                if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                    state.graph.isPanning = true;
                    state.graph.panStartX = mouseX;
                    state.graph.panStartY = mouseY;
                    state.graph.panStartOffsetX = state.graph.viewport.panX;
                    state.graph.panStartOffsetY = state.graph.viewport.panY;
                    finalCanvas.style.cursor = 'grabbing';
                    e.preventDefault();
                    return;
                }

                // Left mouse button = node drag or canvas pan
                if (e.button === 0) {
                    const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                    // Find node under mouse using world coordinates
                    const node = state.graph.nodes.find(n => {
                        const dx = worldPos.x - n.x;
                        const dy = worldPos.y - n.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= n.radius;
                    });

                    if (node) {
                        // Node found - drag the node
                        state.graph.draggedNode = node;
                        state.graph.isDragging = true;
                        state.graph.dragStartX = mouseX;
                        state.graph.dragStartY = mouseY;
                        state.graph.dragNodeStartX = node.x;
                        state.graph.dragNodeStartY = node.y;
                        state.graph.dragStartTime = Date.now();
                        state.graph.dragLastX = mouseX;
                        state.graph.dragLastY = mouseY;
                        finalCanvas.classList.add('dragging');
                        e.preventDefault();
                    } else {
                        // No node found - pan the canvas
                        state.graph.isPanning = true;
                        state.graph.panStartX = mouseX;
                        state.graph.panStartY = mouseY;
                        state.graph.panStartOffsetX = state.graph.viewport.panX;
                        state.graph.panStartOffsetY = state.graph.viewport.panY;
                        finalCanvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                }
            });

            finalCanvas.addEventListener('mouseup', (e) => {
                // End canvas panning
                if (state.graph.isPanning) {
                    state.graph.isPanning = false;
                    finalCanvas.style.cursor = 'default';
                }

                // End node dragging
                if (state.graph.isDragging && state.graph.draggedNode) {
                    const rect = finalCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    // Calculate momentum from recent drag motion in screen space
                    // Velocity is in world units per frame, so scale by zoom
                    const zoom = state.graph.viewport.zoom;
                    const velocityX = (mouseX - state.graph.dragLastX) * 2.5 / zoom;
                    const velocityY = (mouseY - state.graph.dragLastY) * 2.5 / zoom;

                    state.graph.draggedNode.vx = velocityX;
                    state.graph.draggedNode.vy = velocityY;

                    // Clear drag state
                    state.graph.isDragging = false;
                    state.graph.draggedNode = null;
                    finalCanvas.classList.remove('dragging');

                    // Update hover state (mouse may still be over a node)
                    const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);
                    const hoveredNode = state.graph.nodes.find(n => {
                        const dx = worldPos.x - n.x;
                        const dy = worldPos.y - n.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= n.radius;
                    });
                    state.graph.hoveredNode = hoveredNode;
                    updateTooltip(hoveredNode, e.clientX, e.clientY);
                    finalCanvas.classList.toggle('hovering', !!hoveredNode);
                }
            });

            finalCanvas.addEventListener('dblclick', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                // Find node under mouse using world coordinates
                const node = state.graph.nodes.find(n => {
                    const dx = worldPos.x - n.x;
                    const dy = worldPos.y - n.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance <= n.radius;
                });

                if (node) {
                    // Toggle selection
                    if (state.graph.selectedNode === node) {
                        state.graph.selectedNode = null;
                    } else {
                        state.graph.selectedNode = node;
                    }
                } else {
                    // Click on empty space deselects
                    state.graph.selectedNode = null;
                }

                // Update info panel with current selection
                updateInfoPanel(state.graph.selectedNode);

                e.preventDefault();
            });

            // Mouse wheel zoom
            finalCanvas.addEventListener('wheel', (e) => {
                e.preventDefault();

                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
                zoomCanvas(zoomDelta, mouseX, mouseY);
            }, { passive: false });
        }

        // Zoom button controls
        document.getElementById('zoom-in').addEventListener('click', () => {
            zoomCanvas(1.2);
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            zoomCanvas(0.8);
        });

        document.getElementById('zoom-reset').addEventListener('click', () => {
            state.graph.viewport.zoom = 1.0;
            state.graph.viewport.panX = 0;
            state.graph.viewport.panY = 0;
            updateZoomDisplay();
        });

        function zoomCanvas(zoomDelta, centerX, centerY) {
            const canvas = document.getElementById('graph-canvas');
            if (!centerX || !centerY) {
                // Default to canvas center
                centerX = canvas.width / 2;
                centerY = canvas.height / 2;
            }

            // World point under cursor before zoom
            const worldBefore = screenToWorld(centerX, centerY, canvas);

            // Update zoom
            const oldZoom = state.graph.viewport.zoom;
            state.graph.viewport.zoom = Math.max(
                state.graph.viewport.minZoom,
                Math.min(state.graph.viewport.maxZoom, oldZoom * zoomDelta)
            );

            // World point under cursor after zoom
            const worldAfter = screenToWorld(centerX, centerY, canvas);

            // Adjust pan to keep point stationary
            state.graph.viewport.panX += worldBefore.x - worldAfter.x;
            state.graph.viewport.panY += worldBefore.y - worldAfter.y;

            // Update zoom level display
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            const zoomLevelEl = document.getElementById('zoom-level');
            if (zoomLevelEl) {
                const percent = Math.round(state.graph.viewport.zoom * 100);
                zoomLevelEl.textContent = `${percent}%`;
            }
        }

        function updateTooltip(node, mouseX, mouseY) {
            const tooltip = document.getElementById('node-tooltip');
            const titleEl = document.getElementById('tooltip-title');
            const idEl = document.getElementById('tooltip-id');
            const metaEl = document.getElementById('tooltip-meta');

            if (!node) {
                tooltip.classList.remove('visible');
                return;
            }

            // Find full task data
            const task = state.tasks.find(t => t.id === node.id);
            if (!task) return;

            // Update tooltip content
            titleEl.textContent = task.title;
            idEl.textContent = task.id;

            // Build metadata badges
            metaEl.innerHTML = `
                <span class="badge badge-priority-${task.priority}">P${task.priority}</span>
                <span class="badge badge-status-${task.status}">${task.status}</span>
                ${task.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
            `;

            // Position tooltip
            const offset = 15;
            tooltip.style.left = `${mouseX + offset}px`;
            tooltip.style.top = `${mouseY + offset}px`;

            // Adjust if tooltip goes off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (tooltipRect.right > viewportWidth) {
                tooltip.style.left = `${mouseX - tooltipRect.width - offset}px`;
            }
            if (tooltipRect.bottom > viewportHeight) {
                tooltip.style.top = `${mouseY - tooltipRect.height - offset}px`;
            }

            tooltip.classList.add('visible');
        }

        function updateInfoPanel(node) {
            const panel = document.getElementById('info-panel');
            const idEl = document.getElementById('info-panel-id');
            const titleEl = document.getElementById('info-panel-task-title');
            const metaEl = document.getElementById('info-panel-meta');
            const descEl = document.getElementById('info-panel-description');
            const descSection = document.getElementById('info-panel-description-section');
            const depsSection = document.getElementById('info-panel-deps-section');
            const depsList = document.getElementById('info-panel-deps');
            const closedSection = document.getElementById('info-panel-closed-section');
            const closedReason = document.getElementById('info-panel-closed-reason');

            if (!node) {
                panel.classList.remove('visible');
                return;
            }

            // Find full task data
            const task = state.tasks.find(t => t.id === node.id);
            if (!task) return;

            // Update panel content
            idEl.textContent = task.id;
            titleEl.textContent = task.title;

            // Build metadata badges
            metaEl.innerHTML = `
                <span class="badge badge-priority-${task.priority}">P${task.priority}</span>
                <span class="badge badge-status-${task.status}">${task.status}</span>
                ${task.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
            `;

            // Description
            if (task.description) {
                descEl.textContent = task.description;
                descEl.classList.remove('empty');
                descSection.style.display = 'block';
            } else {
                descEl.textContent = 'No description provided';
                descEl.classList.add('empty');
                descSection.style.display = 'block';
            }

            // Dependencies
            if (task.depends_on && task.depends_on.length > 0) {
                depsList.innerHTML = task.depends_on.map(depId => `<li>${escapeHtml(depId)}</li>`).join('');
                depsSection.style.display = 'block';
            } else {
                depsSection.style.display = 'none';
            }

            // Closed reason
            if (task.status === 'done' && task.closed_reason) {
                closedReason.textContent = task.closed_reason;
                closedSection.style.display = 'block';
            } else {
                closedSection.style.display = 'none';
            }

            // Show panel
            panel.classList.add('visible');
        }

        // Info panel close button
        document.getElementById('info-panel-close').addEventListener('click', () => {
            state.graph.selectedNode = null;
            updateInfoPanel(null);
        });

        // Coordinate transformation functions
        function screenToWorld(screenX, screenY, canvas) {
            const { panX, panY, zoom } = state.graph.viewport;
            return {
                x: (screenX - canvas.width / 2) / zoom - panX,
                y: (screenY - canvas.height / 2) / zoom - panY
            };
        }

        function worldToScreen(worldX, worldY, canvas) {
            const { panX, panY, zoom } = state.graph.viewport;
            return {
                x: (worldX + panX) * zoom + canvas.width / 2,
                y: (worldY + panY) * zoom + canvas.height / 2
            };
        }

        function buildGraphData() {
            // Build a map of existing node positions to preserve them on reload
            const existingNodes = new Map();
            state.graph.nodes.forEach(node => {
                existingNodes.set(node.id, { x: node.x, y: node.y });
            });

            // Convert tasks to nodes - preserve positions or place in circular layout
            state.graph.nodes = state.tasks.map((task, index) => {
                const existing = existingNodes.get(task.id);

                if (existing) {
                    // Preserve existing position, but reset velocity to prevent oscillation
                    return {
                        id: task.id,
                        title: task.title,
                        status: task.status,
                        priority: task.priority,
                        x: existing.x,
                        y: existing.y,
                        vx: 0,
                        vy: 0,
                        radius: 30
                    };
                } else {
                    // New node - place in circular layout in world space
                    const totalNodes = state.tasks.length;
                    const angle = (index / totalNodes) * 2 * Math.PI;
                    const radius = 300; // Initial radius in world units

                    return {
                        id: task.id,
                        title: task.title,
                        status: task.status,
                        priority: task.priority,
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius,
                        vx: 0,
                        vy: 0,
                        radius: 30  // Node radius in world units
                    };
                }
            });

            // Build edges from dependencies
            state.graph.edges = [];
            state.tasks.forEach(task => {
                if (task.depends_on && task.depends_on.length > 0) {
                    task.depends_on.forEach(depId => {
                        state.graph.edges.push({
                            from: task.id,
                            to: depId
                        });
                    });
                }
            });
        }

        function animateGraph() {
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');
            const { nodes, edges, physics } = state.graph;

            // Clear canvas
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Apply forces (circular gravity system)
            applyCircularGravity(nodes, physics);
            applyRepulsionForces(nodes, physics);
            applyEdgeAttraction(nodes, edges, physics);
            updatePositions(nodes, physics, canvas);

            // Draw edges
            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--border-color');
            ctx.lineWidth = 2 * state.graph.viewport.zoom;
            edges.forEach(edge => {
                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                if (fromNode && toNode) {
                    drawArrow(ctx, fromNode.x, fromNode.y, toNode.x, toNode.y, canvas);
                }
            });

            // Draw nodes
            nodes.forEach(node => {
                drawNode(ctx, node, canvas);
            });

            if (state.currentView === 'graph') {
                requestAnimationFrame(animateGraph);
            }
        }

        function applyCircularGravity(nodes, physics) {
            const draggedNode = state.graph.draggedNode;
            const { gravityCenter, gravityStrength } = physics;

            nodes.forEach(node => {
                // Don't apply forces to dragged nodes
                if (node === draggedNode) return;

                const dx = gravityCenter.x - node.x;
                const dy = gravityCenter.y - node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    const force = gravityStrength;
                    node.vx += (dx / distance) * force;
                    node.vy += (dy / distance) * force;
                }
            });
        }

        function applyEdgeAttraction(nodes, edges, physics) {
            if (!physics.edgeAttractionEnabled) return;

            const draggedNode = state.graph.draggedNode;
            const { springStrength, springRestingLength } = physics;

            edges.forEach(edge => {
                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                if (!fromNode || !toNode) return;

                // Don't apply to dragged nodes
                if (fromNode === draggedNode && toNode === draggedNode) return;

                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance === 0) return;

                // Bidirectional spring force: applies when compressed OR extended
                // Force increases linearly with deviation from resting length
                const deviation = distance - springRestingLength;
                const force = springStrength * deviation;

                // Spring pulls toward resting length:
                // - If compressed (distance < resting): deviation is negative, pushes apart
                // - If extended (distance > resting): deviation is positive, pulls together
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;

                if (fromNode !== draggedNode) {
                    fromNode.vx += fx;
                    fromNode.vy += fy;
                }
                if (toNode !== draggedNode) {
                    toNode.vx -= fx;
                    toNode.vy -= fy;
                }
            });
        }

        function applyRepulsionForces(nodes, physics) {
            const draggedNode = state.graph.draggedNode;

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const n1 = nodes[i];
                    const n2 = nodes[j];
                    const dx = n2.x - n1.x;
                    const dy = n2.y - n1.y;
                    const distanceSq = dx * dx + dy * dy;
                    if (distanceSq === 0) continue;

                    const force = physics.repulsionStrength / distanceSq;
                    const distance = Math.sqrt(distanceSq);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;

                    // Don't apply forces to dragged nodes
                    if (n1 !== draggedNode) {
                        n1.vx -= fx;
                        n1.vy -= fy;
                    }
                    if (n2 !== draggedNode) {
                        n2.vx += fx;
                        n2.vy += fy;
                    }
                }
            }
        }

        function updatePositions(nodes, physics, canvas) {
            const draggedNode = state.graph.draggedNode;
            const { damping, maxVelocity } = physics;

            nodes.forEach(node => {
                // Freeze dragged node
                if (node === draggedNode) {
                    node.vx = 0;
                    node.vy = 0;
                    return;
                }

                // Apply damping
                node.vx *= damping;
                node.vy *= damping;

                // Cap velocity to prevent extreme speeds
                const speed = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
                if (speed > maxVelocity) {
                    node.vx = (node.vx / speed) * maxVelocity;
                    node.vy = (node.vy / speed) * maxVelocity;
                }

                // Update position (NO BOUNDARY CLAMPING for infinite canvas)
                node.x += node.vx;
                node.y += node.vy;
            });
        }

        function drawNode(ctx, node, canvas) {
            const isHovered = node === state.graph.hoveredNode;
            const isDragging = node === state.graph.draggedNode;
            const isSelected = node === state.graph.selectedNode;

            // Transform world coordinates to screen coordinates
            const screenPos = worldToScreen(node.x, node.y, canvas);
            const zoom = state.graph.viewport.zoom;
            const radius = node.radius * zoom;

            // Node colors based on status
            const colors = {
                'pending': '#5bc0de',
                'in_progress': '#f0ad4e',
                'blocked': '#d9534f',
                'done': '#5cb85c'
            };
            const color = colors[node.status] || '#4a90e2';

            // Draw selection highlight (persistent)
            if (isSelected) {
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, radius + 10 * zoom, 0, Math.PI * 2);
                ctx.strokeStyle = '#f0ad4e';
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.fillStyle = 'rgba(240, 173, 78, 0.15)';
                ctx.fill();
            }

            // Draw drag highlight (active)
            if (isDragging) {
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, radius + 8 * zoom, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(74, 144, 226, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            // Draw hover highlight
            else if (isHovered) {
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, radius + 8 * zoom, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(74, 144, 226, 0.2)';
                ctx.fill();
                ctx.strokeStyle = '#6aa8f0';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // Draw circle
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = (isHovered || isDragging) ? '#ffffff' : '#e8edf3';
            ctx.lineWidth = (isHovered || isDragging) ? 3 : 2;
            ctx.stroke();

            // Draw text
            ctx.fillStyle = '#1a2332';
            const fontSize = 12 * Math.max(0.8, Math.min(1.5, zoom));
            ctx.font = (isHovered || isDragging) ? `bold ${fontSize}px sans-serif` : `${fontSize}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const text = node.id;
            ctx.fillText(text, screenPos.x, screenPos.y);
        }

        function drawArrow(ctx, x1, y1, x2, y2, canvas) {
            // Transform world coordinates to screen coordinates
            const p1 = worldToScreen(x1, y1, canvas);
            const p2 = worldToScreen(x2, y2, canvas);

            const headLength = 10 * state.graph.viewport.zoom;
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const angle = Math.atan2(dy, dx);

            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();

            // Arrow head
            ctx.beginPath();
            ctx.moveTo(p2.x, p2.y);
            ctx.lineTo(
                p2.x - headLength * Math.cos(angle - Math.PI / 6),
                p2.y - headLength * Math.sin(angle - Math.PI / 6)
            );
            ctx.lineTo(
                p2.x - headLength * Math.cos(angle + Math.PI / 6),
                p2.y - headLength * Math.sin(angle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fillStyle = ctx.strokeStyle;
            ctx.fill();
        }

        function renderReady() {
            const list = document.getElementById('ready-list');
            if (state.ready.length === 0) {
                list.innerHTML = '<div class="empty-state">No ready tasks</div>';
                return;
            }
            list.innerHTML = state.ready.map(task => `
                <div class="card">
                    <div class="card-title">${escapeHtml(task.title)}</div>
                    <div class="card-meta">
                        <span class="badge badge-priority-${task.priority}">P${task.priority}</span>
                        <span class="badge" style="background: var(--bg-tertiary)">${task.id}</span>
                        ${task.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
                    </div>
                </div>
            `).join('');
        }

        function renderTests() {
            const list = document.getElementById('test-list');
            if (state.tests.length === 0) {
                list.innerHTML = '<div class="empty-state">No tests configured</div>';
                return;
            }
            list.innerHTML = state.tests.map(test => `
                <div class="card">
                    <div class="card-title">${escapeHtml(test.name)}</div>
                    <div class="card-meta">
                        <span class="badge" style="background: var(--bg-tertiary)">${test.id}</span>
                        <span class="badge ${test.last_status === 'passed' ? 'badge-status-done' : 'badge-status-blocked'}">
                            ${test.last_status || 'Not run'}
                        </span>
                    </div>
                </div>
            `).join('');
        }

        function renderLog() {
            const list = document.getElementById('log-list');
            if (state.log.length === 0) {
                list.innerHTML = '<div class="empty-state">No activity yet</div>';
                return;
            }
            list.innerHTML = state.log.slice(0, 50).map(entry => `
                <div class="card log-entry">
                    <div class="log-time">${new Date(entry.timestamp).toLocaleString()}</div>
                    <div class="card-title">${escapeHtml(entry.action || entry.message)}</div>
                </div>
            `).join('');
        }

        function renderEmptyState(ctx, message) {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(message, ctx.canvas.width / 2, ctx.canvas.height / 2);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize
        connectWebSocket();
    </script>
</body>
</html>
