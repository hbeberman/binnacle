<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binnacle - Project State Tracker</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ§­</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a2332;
            --bg-secondary: #243447;
            --bg-tertiary: #2d4059;
            --text-primary: #e8edf3;
            --text-secondary: #b8c5d6;
            --accent-blue: #4a90e2;
            --accent-light: #6aa8f0;
            --border-color: #3a4d66;
            --success: #5cb85c;
            --warning: #f0ad4e;
            --danger: #d9534f;
            --info: #5bc0de;
            /* Edge type colors */
            --edge-blocking: #e85d5d;
            --edge-informational: #7a8fa3;
            --edge-fixes: #5cb85c;
            --edge-hierarchy: #9b6ed8;
            --edge-default: #3a4d66;
            /* Node type colors - bugs (reddish) */
            --bug-pending: #e07878;
            --bug-in-progress: #d95050;
            --bug-blocked: #b33a3a;
            --bug-done: #8fbc8f;
            /* Node type colors - ideas (deeper purple) */
            --idea-pending: #8b5fc9;
            --idea-in-progress: #7a4db8;
            --idea-blocked: #5c3a8a;
            --idea-done: #8fbc8f;
            /* Node type colors - queue (teal/cyan) */
            --queue-color: #20b2aa;
            --queue-color-light: #40d0c8;
            /* Node type colors - agents (bright cyan/electric blue) */
            --agent-active: #00d4ff;
            --agent-idle: #6bb3c9;
            --agent-stale: #4a6670;
            /* Edge type colors - queued */
            --edge-queued: #20b2aa;
            /* Edge type colors - agent working_on */
            --edge-agent: #00d4ff;
            /* Edge type colors - agent worked_on (grey, like a dead/historical link) */
            --edge-agent-past: #6b7a8a;
            /* Node type colors - docs (by doc_type) */
            --doc-prd: #4a90e2;          /* Blue for PRDs */
            --doc-note: #e8b84a;         /* Gold for Notes */
            --doc-handoff: #e87d4a;      /* Orange for Handoffs */
            /* Edge type colors - pinned (solid green, important connections) */
            --edge-pinned: #5cb85c;
            /* Overlay backgrounds */
            --overlay-bg: rgba(0, 0, 0, 0.85);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            border-bottom: 2px solid var(--border-color);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .header-left {
            flex: 1;
        }

        .active-task-pane {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            min-width: 280px;
            max-width: 400px;
            margin-left: 1rem;
            transition: all 0.3s ease;
        }

        .active-task-pane.empty {
            opacity: 0.5;
        }

        .active-task-pane-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .active-task-pane-header .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--warning);
            animation: pulse 2s ease-in-out infinite;
        }

        .active-task-pane.empty .indicator {
            background: var(--text-secondary);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .active-task-id {
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--accent-light);
            margin-bottom: 0.25rem;
        }

        .active-task-title {
            font-size: 0.95rem;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .active-task-meta {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .active-task-meta .badge {
            font-size: 0.75rem;
            padding: 0.15rem 0.5rem;
        }

        /* Available work counter */
        .available-work-pane {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin-left: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 120px;
        }

        .available-work-pane-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.25rem;
        }

        .available-work-count {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-light);
            line-height: 1;
        }

        .available-work-pane.has-work .available-work-count {
            color: var(--success);
        }

        .available-work-pane.no-work .available-work-count {
            color: var(--text-secondary);
            opacity: 0.5;
        }

        .available-work-breakdown {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Emoji count badges for type breakdowns */
        .emoji-count-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.2rem;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            font-size: 0.75rem;
            font-weight: 500;
            white-space: nowrap;
        }

        .emoji-count-badge .emoji {
            font-size: 0.85rem;
        }

        .emoji-count-badge .count {
            color: var(--text-primary);
            font-weight: 600;
        }

        .emoji-count-badge.type-task {
            border-color: var(--info);
        }

        .emoji-count-badge.type-bug {
            border-color: var(--danger);
        }

        .emoji-count-badge.type-idea {
            border-color: var(--idea-pending);
        }

        /* Recently completed pane */
        .recently-completed-pane {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            min-width: 280px;
            max-width: 400px;
            margin-left: 1rem;
            transition: all 0.3s ease;
        }

        .recently-completed-pane.empty {
            opacity: 0.5;
        }

        .recently-completed-pane-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .recently-completed-pane-header .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
        }

        .recently-completed-pane.empty .indicator {
            background: var(--text-secondary);
        }

        .recently-completed-list {
            max-height: 120px;
            overflow-y: auto;
        }

        .recently-completed-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--border-color);
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .recently-completed-item:last-child {
            border-bottom: none;
        }

        .recently-completed-item.fading {
            opacity: 0.5;
        }

        .recently-completed-id {
            font-family: monospace;
            font-size: 0.8rem;
            color: var(--accent-light);
            flex-shrink: 0;
        }

        .recently-completed-title {
            font-size: 0.85rem;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .recently-completed-ago {
            font-size: 0.7rem;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .recently-completed-empty {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--accent-light);
        }

        .subtitle {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        nav {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
        }

        .nav-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-light);
        }

        main {
            flex: 1;
            overflow: auto;
            padding: 2rem;
        }

        .view {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .view.active {
            display: block;
        }

        #graph-view {
            position: relative;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #graph-canvas {
            width: 100%;
            height: calc(100vh - 200px);
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .task-list, .test-list, .log-list, .agents-list {
            display: grid;
            gap: 1rem;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            border-color: var(--accent-blue);
        }

        .card-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
            overflow-wrap: break-word;
            word-break: break-word;
        }

        .card-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.75rem;
        }

        .card-description {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            line-height: 1.4;
            overflow-wrap: break-word;
            word-break: break-word;
        }

        /* Card header with queue toggle */
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 0.75rem;
        }

        .card-header .card-title {
            flex: 1;
            min-width: 0;
        }

        /* Compact queue toggle for task cards */
        .card-queue-toggle {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
            flex-shrink: 0;
        }

        .card-queue-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--text-secondary);
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .card-queue-toggle.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .card-queue-toggle.active::after {
            transform: translateX(14px);
            background: white;
        }

        .card-queue-toggle:hover {
            border-color: #22c55e;
        }

        .card-queue-toggle:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Card actions container for buttons */
        .card-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-shrink: 0;
        }

        /* Jump to node button */
        .card-jump-btn {
            width: 28px;
            height: 28px;
            border-radius: 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .card-jump-btn:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        /* Blocked card styling */
        .card-blocked {
            border-color: var(--danger);
            opacity: 0.8;
        }

        .blocked-banner {
            background: var(--danger);
            color: white;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 4px 4px 0 0;
            margin: -0.75rem -0.75rem 0.5rem -0.75rem;
            text-align: center;
        }

        .blocked-reason {
            font-size: 0.7rem;
            font-weight: 400;
            font-style: italic;
            opacity: 0.9;
            margin-top: 0.15rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .card-closed {
            border-color: var(--success);
            opacity: 0.7;
        }

        .closed-banner {
            background: var(--success);
            color: white;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 4px 4px 0 0;
            margin: -0.75rem -0.75rem 0.5rem -0.75rem;
            text-align: center;
        }

        /* Left sidebar (hover to expand) */
        .agents-sidebar {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 44px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            z-index: 100;
            transition: width 0.2s ease;
            overflow: hidden;
        }

        .agents-sidebar:hover,
        .agents-sidebar.expanded {
            width: 240px;
        }

        .agents-sidebar-header {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            min-height: 44px;
        }

        .agents-sidebar-icon {
            font-size: 1.4rem;
            flex-shrink: 0;
            width: 20px;
            text-align: center;
        }

        .agents-sidebar-title {
            font-weight: 600;
            font-size: 0.9rem;
            margin-left: 0.75rem;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .agents-sidebar:hover .agents-sidebar-title,
        .agents-sidebar.expanded .agents-sidebar-title {
            opacity: 1;
        }

        .agents-sidebar-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 0.5rem;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .agents-sidebar:hover .agents-sidebar-content,
        .agents-sidebar.expanded .agents-sidebar-content {
            opacity: 1;
        }

        .agents-sidebar-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        /* Sidebar sections */
        .sidebar-section {
            margin-bottom: 1rem;
        }

        .sidebar-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            padding: 0 0.25rem;
        }

        /* Sidebar filter buttons */
        .sidebar-filter-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .agents-sidebar-item {
            padding: 0.5rem;
            border-radius: 6px;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .agents-sidebar-item:hover {
            border-color: var(--agent-active);
            background: var(--bg-tertiary);
        }

        .agents-sidebar-item.active {
            border-color: var(--agent-active);
        }

        .agents-sidebar-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .agents-sidebar-item-name {
            font-weight: 600;
            font-size: 0.85rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .agents-sidebar-item-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .agents-sidebar-item-status.active { background: var(--agent-active); }
        .agents-sidebar-item-status.idle { background: var(--agent-idle); }
        .agents-sidebar-item-status.stale { background: var(--agent-stale); }

        .agents-sidebar-item-task {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .agents-sidebar-empty {
            padding: 1rem;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .badge {
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .badge-priority-0 { background: var(--danger); color: white; }
        .badge-priority-1 { background: var(--warning); color: white; }
        .badge-priority-2 { background: var(--info); color: white; }
        .badge-priority-3 { background: var(--success); color: white; }

        .badge-status-pending { background: var(--info); color: white; }
        .badge-status-in_progress { background: var(--warning); color: white; }
        .badge-status-blocked { background: var(--danger); color: white; }
        .badge-status-done { background: var(--success); color: white; }

        /* Agent status badges */
        .badge-agent-Active { 
            background: var(--success); 
            color: white;
            animation: agent-pulse 2s ease-in-out infinite;
        }
        .badge-agent-Idle { background: var(--warning); color: white; }
        .badge-agent-Stale { 
            background: var(--danger); 
            color: white;
            opacity: 0.7;
        }

        @keyframes agent-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(92, 184, 92, 0.5); }
            50% { box-shadow: 0 0 8px 4px rgba(92, 184, 92, 0.3); }
        }

        .badge-tag {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        /* Agent card styles */
        .agent-card {
            position: relative;
        }

        .agent-card .agent-pid {
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .agent-card .agent-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-light);
        }

        .agent-card .agent-purpose {
            font-size: 0.9rem;
            color: var(--text-primary);
            margin-top: 0.25rem;
            font-style: italic;
        }

        .agent-card .agent-purpose.agent-type-label {
            color: var(--text-secondary);
            font-style: normal;
            font-size: 0.85rem;
            text-transform: capitalize;
        }

        .agent-card .agent-tasks {
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .agent-card .agent-tasks .no-tasks {
            color: var(--text-muted);
            font-style: italic;
        }

        .agent-card .agent-tasks .task-id {
            font-family: monospace;
            color: var(--accent-blue);
            cursor: pointer;
        }

        .agent-card .agent-tasks .task-id:hover {
            text-decoration: underline;
        }

        .agent-card .agent-stats {
            display: flex;
            gap: 1rem;
            margin-top: 0.75rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .agent-card .agent-stats span {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .log-entry {
            padding: 1rem;
            border-left: 3px solid var(--accent-blue);
        }
        
        .log-entry.log-error {
            border-left-color: var(--status-bug);
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .log-time {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .log-user {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .log-details {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
            font-style: italic;
        }
        
        .log-error-msg {
            font-size: 0.85rem;
            color: var(--status-bug);
            margin-top: 0.5rem;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .modal-content h3 {
            margin: 0 0 1rem 0;
            color: var(--danger);
        }

        .modal-body {
            margin-bottom: 1.5rem;
        }

        .modal-body p {
            margin: 0 0 1rem 0;
            color: var(--text-secondary);
        }

        .modal-agent-info {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 1rem;
        }

        .modal-agent-info .agent-name {
            font-weight: 600;
            color: var(--accent-light);
        }

        .modal-agent-info .agent-detail {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        .modal-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.2s ease;
        }

        .modal-btn-cancel {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .modal-btn-cancel:hover {
            background: var(--bg-primary);
        }

        .modal-btn-danger {
            background: var(--danger);
            color: white;
        }

        .modal-btn-danger:hover {
            background: #c9302c;
        }

        .modal-btn-primary {
            background: var(--accent);
            color: white;
        }

        .modal-btn-primary:hover {
            background: var(--accent-light);
        }

        /* Agent Detail Modal */
        .agent-detail-modal .modal-content {
            max-width: 500px;
        }

        .agent-detail-modal .modal-content h3 {
            color: var(--accent);
            margin-bottom: 1.25rem;
        }

        .agent-detail-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .agent-detail-icon {
            width: 48px;
            height: 48px;
            background: var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .agent-detail-title {
            flex: 1;
        }

        .agent-detail-title .agent-name {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .agent-detail-title .agent-pid {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .agent-detail-section {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .agent-detail-section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-tertiary);
            margin-bottom: 0.5rem;
        }

        .agent-detail-purpose {
            color: var(--text-primary);
            line-height: 1.5;
        }

        .agent-detail-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .agent-detail-stat {
            text-align: center;
        }

        .agent-detail-stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--accent);
        }

        .agent-detail-stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .agent-detail-tasks {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .agent-detail-task-id {
            background: var(--bg-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
            color: var(--accent-light);
            font-family: monospace;
        }

        .agent-detail-timestamp {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        /* Terminate button in agent card */
        .agent-card .terminate-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: transparent;
            border: 1px solid var(--danger);
            color: var(--danger);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.7;
        }

        .agent-card .terminate-btn:hover {
            background: var(--danger);
            color: white;
            opacity: 1;
        }

        /* Agent card clickable task links */
        .agent-card .task-link {
            font-family: monospace;
            color: var(--accent-light);
            cursor: pointer;
            text-decoration: none;
            transition: color 0.15s ease;
        }

        .agent-card .task-link:hover {
            color: var(--accent);
            text-decoration: underline;
        }

        /* Focus on Graph button */
        .agent-card .focus-btn {
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s ease;
            margin-top: 0.5rem;
        }

        .agent-card .focus-btn:hover {
            background: var(--accent);
            color: white;
        }

        /* Agent Activity Section */
        .agents-activity-section {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }

        .agents-activity-section h3 {
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .agents-activity-log {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .activity-entry {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.75rem 1rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .activity-entry.activity-error {
            border-color: var(--status-bug);
        }

        .activity-entry .activity-time {
            font-size: 0.8rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }
        
        .activity-entry .activity-status {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .activity-entry .activity-agent {
            font-size: 0.85rem;
            color: var(--accent-light);
            font-weight: 500;
        }

        .activity-entry .activity-action {
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        
        .activity-entry .activity-details {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-style: italic;
            flex-basis: 100%;
            padding-left: 3.5rem;
        }

        .connection-status {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-connected { background: var(--success); }
        .status-disconnected { background: var(--danger); animation: none; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .node-tooltip {
            position: fixed;
            background: var(--overlay-bg);
            color: var(--text-primary);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .node-tooltip.visible {
            display: block;
        }

        .graph-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 0.5rem;
            z-index: 100;
            align-items: center;
            justify-content: flex-end;
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            max-width: calc(100vw - 250px);
        }

        .zoom-buttons {
            display: flex;
            flex-direction: row;
            gap: 0.5rem;
            align-items: center;
            flex-shrink: 0;
        }

        .graph-search {
            height: 32px;
            width: 180px;
            padding: 0 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .graph-search::placeholder {
            color: var(--text-secondary);
        }

        .graph-search:focus {
            outline: none;
            border-color: var(--accent-light);
            box-shadow: 0 0 0 2px rgba(106, 168, 240, 0.2);
        }

        /* View search bar (for Tasks, Bugs, Ideas views) */
        .view-search-container {
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
        }

        .view-search {
            height: 36px;
            width: 100%;
            max-width: 400px;
            padding: 0 0.75rem 0 2.25rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .view-search::placeholder {
            color: var(--text-secondary);
        }

        .view-search:focus {
            outline: none;
            border-color: var(--accent-light);
            box-shadow: 0 0 0 2px rgba(106, 168, 240, 0.2);
        }

        .view-search-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 400px;
        }

        .view-search-icon {
            position: absolute;
            left: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-secondary);
            font-size: 0.9rem;
            pointer-events: none;
        }

        /* Include closed toggle (for Tasks, Bugs, Ideas views) */
        .include-closed-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-left: 0.75rem;
        }

        .include-closed-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .include-closed-switch {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .include-closed-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            transition: transform 0.2s ease;
        }

        .include-closed-switch.active {
            background: var(--accent-blue);
            border-color: var(--accent-light);
        }

        .include-closed-switch.active::after {
            transform: translateX(14px);
        }

        /* Doc type filter */
        .doc-type-filter,
        .node-type-filter {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-left: 0.75rem;
        }

        .filter-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .type-filter-select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.75rem;
            padding: 0.25rem 0.5rem;
            cursor: pointer;
        }

        .type-filter-select:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        /* Auto-follow toggle */
        .auto-follow-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-right: 0.25rem;
            padding-right: 0.5rem;
            border-right: 1px solid var(--border-color);
        }

        .auto-follow-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .auto-follow-switch {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .auto-follow-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            transition: transform 0.2s ease;
        }

        .auto-follow-switch.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .auto-follow-switch.active::after {
            transform: translateX(14px);
        }

        /* Agent selector dropdown */
        .agent-selector {
            font-size: 0.7rem;
            padding: 0.15rem 0.25rem;
            border-radius: 4px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            cursor: pointer;
            max-width: 100px;
            text-overflow: ellipsis;
        }

        .agent-selector:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .agent-selector option {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        /* Hide completed toggle */
        .hide-completed-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-right: 0.25rem;
            padding-right: 0.5rem;
            border-right: 1px solid var(--border-color);
        }

        .hide-completed-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .hide-completed-switch {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .hide-completed-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            transition: transform 0.2s ease;
        }

        .hide-completed-switch.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .hide-completed-switch.active::after {
            transform: translateX(14px);
        }

        /* Chain length filter */
        .chain-length-filter {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-right: 0.25rem;
            padding-right: 0.5rem;
            border-right: 1px solid var(--border-color);
        }

        .chain-length-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .chain-length-slider {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-tertiary);
            border-radius: 2px;
            cursor: pointer;
        }

        .chain-length-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .chain-length-slider::-webkit-slider-thumb:hover {
            background: var(--accent-light);
        }

        .chain-length-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            border: none;
            transition: background 0.2s ease;
        }

        .chain-length-slider::-moz-range-thumb:hover {
            background: var(--accent-light);
        }

        .chain-length-value {
            font-size: 0.75rem;
            font-family: monospace;
            color: var(--text-primary);
            min-width: 1.5rem;
            text-align: center;
        }

        .chain-length-filter.active .chain-length-label {
            color: var(--accent-light);
        }

        /* Node filter buttons (in sidebar) */
        .node-filter-btn {
            padding: 0.35rem 0.5rem;
            font-size: 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            width: 100%;
            text-align: left;
        }

        .node-filter-btn:hover {
            border-color: var(--accent-blue);
        }

        .node-filter-btn.active {
            background: #3a7bc8;
            border-color: var(--accent-light);
            color: white;
        }

        .node-filter-btn .count {
            font-weight: 600;
        }

        .node-filter-row {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            width: 100%;
        }

        .node-filter-row .node-filter-btn {
            flex: 1;
        }

        .node-visibility-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 0.85rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
        }

        .node-visibility-btn:hover {
            border-color: var(--accent-blue);
            opacity: 0.8;
        }

        .node-visibility-btn.active {
            background: var(--info);
            border-color: var(--info);
            color: white;
            opacity: 1;
        }

        .node-filter-all {
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0.25rem;
            padding-bottom: 0.5rem;
        }

        /* Edge filter buttons (in sidebar) */
        .edge-filter-btn {
            padding: 0.35rem 0.5rem;
            font-size: 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            width: 100%;
        }

        .edge-filter-btn:hover {
            border-color: var(--accent-blue);
        }

        .edge-filter-btn.active {
            background: #3a7bc8;  /* Darker blue than --accent-blue for better contrast */
            border-color: var(--accent-light);
            color: white;
        }

        .edge-filter-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .edge-filter-all {
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0.25rem;
            padding-bottom: 0.5rem;
        }

        .edge-filter-row {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            width: 100%;
        }

        .edge-filter-row .edge-filter-btn {
            flex: 1;
        }

        .edge-spring-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 0.85rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
        }

        .edge-spring-btn:hover {
            border-color: var(--accent-blue);
            opacity: 0.8;
        }

        .edge-spring-btn.active {
            background: var(--success);
            border-color: var(--success);
            color: white;
            opacity: 1;
        }

        .edge-spring-btn[disabled] {
            opacity: 0.2;
            cursor: not-allowed;
        }

        .edge-visibility-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 0.85rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
        }

        .edge-visibility-btn:hover {
            border-color: var(--accent-blue);
            opacity: 0.8;
        }

        .edge-visibility-btn.active {
            background: var(--info);
            border-color: var(--info);
            color: white;
            opacity: 1;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: var(--accent-blue);
        }

        .zoom-level {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.35rem 0.5rem;
            font-size: 0.8rem;
            text-align: center;
            color: var(--text-secondary);
            min-width: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Fullscreen/maximize mode for graph */
        #graph-view.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9999;
            background: var(--bg-primary);
        }

        #graph-view.fullscreen #graph-canvas {
            height: 100vh;
            border-radius: 0;
            border: none;
        }

        #graph-view.fullscreen .agents-sidebar {
            top: 0;
            height: 100vh;
        }

        #graph-view.fullscreen .graph-controls {
            top: 1rem;
        }

        .maximize-btn {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 0.5rem;
        }

        .maximize-btn:hover {
            background: var(--accent-blue);
        }

        .tooltip-title {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: var(--accent-light);
        }

        .tooltip-id {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-family: monospace;
            margin-bottom: 0.5rem;
        }

        .tooltip-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        /* Edge tooltip styles */
        .edge-tooltip {
            position: fixed;
            background: var(--overlay-bg);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            pointer-events: none;
            z-index: 1000;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
            font-size: 0.9rem;
        }

        .edge-tooltip.visible {
            display: block;
        }

        .edge-tooltip-type {
            font-weight: 600;
            margin-bottom: 0.4rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .edge-tooltip-type .edge-color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .edge-tooltip-ids {
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.4rem;
        }

        .edge-tooltip-reason {
            font-style: italic;
            color: var(--text-secondary);
            margin-top: 0.4rem;
            padding-top: 0.4rem;
            border-top: 1px solid var(--border-color);
        }

        .edge-tooltip-date {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 0.3rem;
        }

        #graph-canvas {
            cursor: default;
        }

        #graph-canvas.hovering:not(.dragging) {
            cursor: grab;
        }

        #graph-canvas.dragging {
            cursor: grabbing;
        }

        .info-panel {
            position: absolute;
            top: 4rem;  /* Below graph-controls */
            right: 1rem;
            width: 320px;
            max-height: calc(100% - 5rem);
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 99;  /* Below graph-controls */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .info-panel.visible {
            opacity: 1;
            visibility: visible;
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .info-panel-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .info-panel-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: color 0.2s ease;
        }

        .info-panel-close:hover {
            color: var(--text-primary);
        }

        .info-panel-id {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--accent-light);
            margin-bottom: 0.5rem;
        }

        .info-panel-task-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }

        .info-panel-short-name-row {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .info-panel-label {
            font-weight: 500;
            margin-right: 0.5rem;
        }

        .info-panel-short-name {
            color: var(--accent-light);
        }

        .info-panel-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .info-panel-section {
            margin-bottom: 1rem;
        }

        .info-panel-section-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .info-panel-description {
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .info-panel-description.empty {
            color: var(--text-secondary);
            font-style: italic;
        }

        .info-panel-deps {
            list-style: none;
        }

        .info-panel-deps li {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--accent-light);
            padding: 0.25rem 0;
        }

        .info-panel-deps li:before {
            content: "â†’ ";
            color: var(--text-secondary);
        }

        .info-panel-closed-reason {
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.6;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border-left: 3px solid var(--success);
        }

        /* Clickable node links in info panel */
        .info-panel-node-link {
            font-family: monospace;
            color: var(--accent-light);
            cursor: pointer;
            text-decoration: none;
            transition: color 0.15s ease;
        }

        .info-panel-node-link:hover {
            color: var(--accent);
            text-decoration: underline;
        }

        /* Relationships list */
        .info-panel-relationships {
            list-style: none;
        }

        .info-panel-relationships li {
            font-size: 0.9rem;
            color: var(--text-primary);
            padding: 0.35rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-panel-edge-type {
            font-size: 0.75rem;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .info-panel-edge-direction {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Timestamps */
        .info-panel-timestamps {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .info-panel-timestamps dt {
            display: inline;
            font-weight: 500;
        }

        .info-panel-timestamps dd {
            display: inline;
            margin-left: 0.25rem;
            margin-right: 1rem;
        }

        /* Queue toggle in info panel */
        .info-panel-queue-section {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-panel-queue-label {
            font-size: 0.9rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-panel-queue-label::before {
            content: 'ðŸ“‹';
        }

        .queue-toggle-switch {
            width: 40px;
            height: 22px;
            border-radius: 11px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .queue-toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--text-secondary);
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .queue-toggle-switch.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .queue-toggle-switch.active::after {
            transform: translateX(18px);
            background: white;
        }

        .queue-toggle-switch:hover {
            border-color: var(--accent-light);
        }

        .queue-toggle-switch:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Edge Info Panel */
        .edge-info-panel {
            position: absolute;
            top: 4rem;
            right: 1rem;
            width: 320px;
            max-height: calc(100% - 5rem);
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 99;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .edge-info-panel.visible {
            opacity: 1;
            visibility: visible;
        }

        .edge-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .edge-info-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .edge-info-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: color 0.2s ease;
        }

        .edge-info-close:hover {
            color: var(--text-primary);
        }

        .edge-info-type {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
        }

        .edge-info-type .edge-color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .edge-info-connection {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--accent-light);
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
        }

        .edge-info-node {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .edge-info-node-id {
            color: var(--accent-light);
            font-weight: 500;
        }

        .edge-info-node-title {
            font-family: inherit;
            font-size: 0.85rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .edge-info-arrow {
            text-align: center;
            color: var(--text-muted);
            font-size: 1.2rem;
            margin: 0.5rem 0;
        }

        .edge-info-section {
            margin-top: 1rem;
        }

        .edge-info-section-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .edge-info-reason {
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.6;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-style: italic;
        }

        .edge-info-date {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 0.75rem;
        }

        /* Toast Notification System */
        .toast-container {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            pointer-events: none;
        }

        .toast {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            padding-right: 2.5rem;
            min-width: 280px;
            max-width: 450px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            pointer-events: auto;
            animation: toastSlideIn 0.3s ease;
            position: relative;
        }

        .toast.toast-exit {
            animation: toastSlideOut 0.3s ease forwards;
        }

        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes toastSlideOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        .toast-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
            font-size: 0.9rem;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .toast-close {
            position: absolute;
            top: 50%;
            right: 0.5rem;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            line-height: 1;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .toast-close:hover {
            opacity: 1;
        }

        /* Toast type-specific styles with colored tints */
        .toast-success {
            border-left: 4px solid var(--success);
            background: linear-gradient(90deg, rgba(92, 184, 92, 0.15), var(--bg-secondary) 30%);
        }

        .toast-success .toast-icon {
            color: var(--success);
        }

        .toast-error {
            border-left: 4px solid var(--danger);
            background: linear-gradient(90deg, rgba(217, 83, 79, 0.15), var(--bg-secondary) 30%);
        }

        .toast-error .toast-icon {
            color: var(--danger);
        }

        .toast-warning {
            border-left: 4px solid var(--warning);
            background: linear-gradient(90deg, rgba(240, 173, 78, 0.15), var(--bg-secondary) 30%);
        }

        .toast-warning .toast-icon {
            color: var(--warning);
        }

        .toast-info {
            border-left: 4px solid var(--info);
            background: linear-gradient(90deg, rgba(91, 192, 222, 0.15), var(--bg-secondary) 30%);
        }

        .toast-info .toast-icon {
            color: var(--info);
        }

        /* Responsive layout for graph overlays */
        @media (max-width: 1200px) {
            .graph-controls {
                max-width: calc(100vw - 300px);
            }
        }

        @media (max-width: 900px) {
            .graph-controls {
                max-width: calc(100vw - 200px);
            }
            .graph-search {
                width: 140px;
            }
        }

        @media (max-width: 700px) {
            .graph-controls {
                max-width: calc(100vw - 2rem);
                flex-direction: column;
                align-items: stretch;
            }
            .graph-search {
                width: 100%;
            }
            .hide-completed-toggle,
            .auto-follow-toggle,
            .chain-length-filter {
                border-right: none;
                padding-right: 0;
                margin-right: 0;
                justify-content: space-between;
            }
            .chain-length-slider {
                flex: 1;
                min-width: 80px;
            }
            .zoom-buttons {
                justify-content: center;
            }
            .info-panel {
                top: auto;
                bottom: 1rem;
                left: 1rem;
                right: 1rem;
                width: auto;
                max-height: 50vh;
            }
            .agents-sidebar {
                width: 40px;
            }
            .agents-sidebar:hover,
            .agents-sidebar.expanded {
                width: 200px;
            }
        }

        /* Doc Viewer Modal Styles */
        .doc-viewer-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--overlay-bg);
            display: none;
            z-index: 1000;
            overflow: auto;
        }

        .doc-viewer-modal.visible {
            display: flex;
            justify-content: center;
            padding: 2rem;
        }

        .doc-viewer-container {
            background: var(--bg-secondary);
            border-radius: 12px;
            max-width: 900px;
            width: 100%;
            max-height: calc(100vh - 4rem);
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
        }

        .doc-viewer-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
        }

        .doc-viewer-header-content {
            flex: 1;
        }

        .doc-viewer-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .doc-viewer-title .summary-dirty-indicator {
            color: var(--warning);
            font-size: 1.2rem;
            cursor: help;
        }

        .doc-viewer-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .doc-viewer-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.5rem;
            line-height: 1;
            border-radius: 4px;
            transition: all 0.2s ease;
        }

        .doc-viewer-close:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Summary Section - Prominent */
        .doc-viewer-summary {
            background: var(--bg-tertiary);
            padding: 1.25rem 1.5rem;
            border-bottom: 2px solid var(--accent-blue);
        }

        .doc-viewer-summary-header {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent-light);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .doc-viewer-summary-content {
            color: var(--text-primary);
            line-height: 1.7;
        }

        .doc-viewer-summary-content p {
            margin: 0;
        }

        .doc-viewer-summary.dirty {
            border-color: var(--warning);
        }

        .doc-viewer-summary.dirty .doc-viewer-summary-header {
            color: var(--warning);
        }

        /* Doc Viewer Layout with Sidebar */
        .doc-viewer-body-wrapper {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .doc-viewer-main {
            flex: 1;
            overflow: auto;
            display: flex;
            flex-direction: column;
        }

        /* Version History Sidebar */
        .doc-viewer-history-sidebar {
            width: 220px;
            min-width: 220px;
            background: var(--bg-tertiary);
            border-left: 1px solid var(--border-color);
            overflow: auto;
            display: none;
        }

        .doc-viewer-history-sidebar.visible {
            display: block;
        }

        .doc-viewer-history-header {
            padding: 0.75rem 1rem;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .doc-viewer-history-list {
            padding: 0.5rem;
        }

        .doc-viewer-history-item {
            padding: 0.75rem;
            border-radius: 6px;
            cursor: pointer;
            margin-bottom: 0.25rem;
            transition: background 0.2s ease;
        }

        .doc-viewer-history-item:hover {
            background: var(--bg-secondary);
        }

        .doc-viewer-history-item.current {
            background: var(--accent-blue);
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(59, 130, 246, 0.05));
            border: 1px solid var(--accent-blue);
        }

        .doc-viewer-history-item-version {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .doc-viewer-history-item.current .doc-viewer-history-item-version::after {
            content: 'current';
            font-size: 0.65rem;
            font-weight: 500;
            color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.2);
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
        }

        .doc-viewer-history-item-date {
            font-size: 0.7rem;
            color: var(--text-tertiary);
            margin-top: 0.25rem;
        }

        .doc-viewer-history-item-editor {
            font-size: 0.7rem;
            color: var(--text-tertiary);
            margin-top: 0.125rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .doc-viewer-history-empty {
            padding: 1rem;
            color: var(--text-tertiary);
            font-size: 0.85rem;
            text-align: center;
        }

        /* Main Content */
        .doc-viewer-content {
            padding: 1.5rem;
            flex: 1;
            overflow: auto;
        }

        /* Markdown Rendering Styles */
        .doc-viewer-content h1,
        .doc-viewer-content h2,
        .doc-viewer-content h3,
        .doc-viewer-content h4,
        .doc-viewer-content h5,
        .doc-viewer-content h6 {
            color: var(--text-primary);
            margin-top: 1.5em;
            margin-bottom: 0.75em;
            font-weight: 600;
        }

        .doc-viewer-content h1 { font-size: 1.75rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.3em; }
        .doc-viewer-content h2 { font-size: 1.5rem; border-bottom: 1px solid var(--border-color); padding-bottom: 0.3em; }
        .doc-viewer-content h3 { font-size: 1.25rem; }
        .doc-viewer-content h4 { font-size: 1.1rem; }
        .doc-viewer-content h5 { font-size: 1rem; }
        .doc-viewer-content h6 { font-size: 0.9rem; color: var(--text-secondary); }

        .doc-viewer-content p {
            margin-bottom: 1em;
            line-height: 1.7;
        }

        .doc-viewer-content ul,
        .doc-viewer-content ol {
            margin-bottom: 1em;
            padding-left: 2em;
        }

        .doc-viewer-content li {
            margin-bottom: 0.25em;
        }

        .doc-viewer-content blockquote {
            border-left: 4px solid var(--accent-blue);
            padding-left: 1em;
            margin: 1em 0;
            color: var(--text-secondary);
            font-style: italic;
        }

        .doc-viewer-content a {
            color: var(--accent-light);
            text-decoration: none;
        }

        .doc-viewer-content a:hover {
            text-decoration: underline;
        }

        .doc-viewer-content hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 2em 0;
        }

        /* Inline code */
        .doc-viewer-content code {
            background: var(--bg-tertiary);
            padding: 0.2em 0.4em;
            border-radius: 4px;
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
            font-size: 0.9em;
        }

        /* Code blocks with syntax highlighting */
        .doc-viewer-content pre {
            background: #1e2a3a;
            border-radius: 8px;
            padding: 1rem;
            overflow-x: auto;
            margin: 1em 0;
            border: 1px solid var(--border-color);
        }

        .doc-viewer-content pre code {
            background: transparent;
            padding: 0;
            font-size: 0.875rem;
            line-height: 1.5;
        }

        /* Syntax highlighting colors */
        .doc-viewer-content pre .keyword { color: #c792ea; }
        .doc-viewer-content pre .string { color: #c3e88d; }
        .doc-viewer-content pre .number { color: #f78c6c; }
        .doc-viewer-content pre .comment { color: #546e7a; font-style: italic; }
        .doc-viewer-content pre .function { color: #82aaff; }
        .doc-viewer-content pre .type { color: #ffcb6b; }
        .doc-viewer-content pre .operator { color: #89ddff; }
        .doc-viewer-content pre .punctuation { color: #89ddff; }

        /* Language label for code blocks */
        .doc-viewer-content pre[data-lang]::before {
            content: attr(data-lang);
            display: block;
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        /* Tables */
        .doc-viewer-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 1em 0;
        }

        .doc-viewer-content th,
        .doc-viewer-content td {
            border: 1px solid var(--border-color);
            padding: 0.5em 0.75em;
            text-align: left;
        }

        .doc-viewer-content th {
            background: var(--bg-tertiary);
            font-weight: 600;
        }

        .doc-viewer-content tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }

        /* Task checkboxes */
        .doc-viewer-content .task-list-item {
            list-style: none;
            margin-left: -1.5em;
        }

        .doc-viewer-content .task-list-item input[type="checkbox"] {
            margin-right: 0.5em;
        }

        /* Clickable doc cards in nodes list */
        .card[data-doc-id] {
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .card[data-doc-id]:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        /* Loading state */
        .doc-viewer-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: var(--text-secondary);
        }

        .doc-viewer-loading::before {
            content: '';
            width: 24px;
            height: 24px;
            border: 3px solid var(--border-color);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 0.75rem;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

    </style>
</head>
<body>
    <!-- Toast notification container -->
    <div class="toast-container" id="toast-container"></div>

    <div class="container">
        <header>
            <div class="header-left">
                <h1>ðŸ§­ Binnacle</h1>
                <p class="subtitle">Project State Tracker</p>
                <nav>
                    <button class="nav-btn active" data-view="graph">Graph</button>
                    <button class="nav-btn" data-view="nodes">Nodes</button>
                    <button class="nav-btn" data-view="agents">Agents</button>
                    <button class="nav-btn" data-view="log">Activity Log</button>
                </nav>
            </div>
            <div class="available-work-pane no-work" id="available-work-pane">
                <div class="available-work-pane-header">
                    <span>Available Work</span>
                </div>
                <div class="available-work-count" id="available-work-count">0</div>
                <div class="available-work-breakdown" id="available-work-breakdown"></div>
            </div>
            <div class="active-task-pane empty" id="active-task-pane">
                <div class="active-task-pane-header">
                    <span class="indicator"></span>
                    <span>Active Task</span>
                </div>
                <div class="active-task-id" id="active-task-id">No active task</div>
                <div class="active-task-title" id="active-task-title"></div>
                <div class="active-task-meta" id="active-task-meta"></div>
            </div>
            <div class="recently-completed-pane empty" id="recently-completed-pane">
                <div class="recently-completed-pane-header">
                    <span class="indicator"></span>
                    <span>Recently Completed</span>
                </div>
                <div class="recently-completed-list" id="recently-completed-list">
                    <div class="recently-completed-empty">No recent completions</div>
                </div>
            </div>
        </header>

        <main>
            <div id="graph-view" class="view active">
                <div class="agents-sidebar" id="agents-sidebar">
                    <div class="agents-sidebar-header">
                        <span class="agents-sidebar-icon">ðŸ¤–</span>
                        <span class="agents-sidebar-title">Sidebar</span>
                    </div>
                    <div class="agents-sidebar-content" id="agents-sidebar-content">
                        <!-- Agents section -->
                        <div class="sidebar-section" id="agents-section">
                            <div class="sidebar-section-title">Agents</div>
                            <div class="agents-sidebar-list" id="agents-sidebar-list"></div>
                        </div>
                        <!-- Node filters section -->
                        <div class="sidebar-section">
                            <div class="sidebar-section-title">Nodes</div>
                            <div class="sidebar-filter-group" id="sidebar-node-filters">
                                <!-- Node type filter buttons will be populated dynamically -->
                            </div>
                        </div>
                        <!-- Edge filters section -->
                        <div class="sidebar-section">
                            <div class="sidebar-section-title">Edges</div>
                            <div class="sidebar-filter-group" id="sidebar-edge-filters">
                                <!-- Edge type filter buttons will be populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>
                <canvas id="graph-canvas"></canvas>
                <div class="node-tooltip" id="node-tooltip">
                    <div class="tooltip-title" id="tooltip-title"></div>
                    <div class="tooltip-id" id="tooltip-id"></div>
                    <div class="tooltip-meta" id="tooltip-meta"></div>
                </div>
                <div class="edge-tooltip" id="edge-tooltip">
                    <div class="edge-tooltip-type" id="edge-tooltip-type"></div>
                    <div class="edge-tooltip-ids" id="edge-tooltip-ids"></div>
                    <div class="edge-tooltip-reason" id="edge-tooltip-reason"></div>
                    <div class="edge-tooltip-date" id="edge-tooltip-date"></div>
                </div>
                <div class="graph-controls">
                    <input class="graph-search" id="graph-search" type="text" placeholder="Search nodesâ€¦" autocomplete="off" spellcheck="false" />
                    <div class="chain-length-filter" id="chain-length-filter">
                        <span class="chain-length-label">Chain â‰¥</span>
                        <input type="range" class="chain-length-slider" id="chain-length-slider" min="1" max="5" value="1" title="Filter nodes by minimum chain length" />
                        <span class="chain-length-value" id="chain-length-value">1</span>
                    </div>
                    <div class="hide-completed-toggle">
                        <span class="hide-completed-label">Hide completed</span>
                        <button class="hide-completed-switch" id="hide-completed-switch" title="Hide completed nodes (except in active chains)"></button>
                    </div>
                    <div class="auto-follow-toggle">
                        <span class="auto-follow-label">Follow</span>
                        <select class="agent-selector" id="agent-selector" title="Select target to follow">
                            <option value="">None</option>
                        </select>
                        <button class="auto-follow-switch" id="auto-follow-switch" title="Auto-focus on selected target"></button>
                    </div>
                    <div class="zoom-buttons">
                        <button class="zoom-btn" id="zoom-in" title="Zoom In">+</button>
                        <div class="zoom-level" id="zoom-level">100%</div>
                        <button class="zoom-btn" id="zoom-out" title="Zoom Out">âˆ’</button>
                        <button class="zoom-btn" id="zoom-reset" title="Reset Zoom">âŸ²</button>
                        <button class="maximize-btn" id="maximize-btn" title="Fullscreen (Esc to exit)">â›¶</button>
                    </div>
                </div>
                <div class="info-panel" id="info-panel">
                    <div class="info-panel-header">
                        <span class="info-panel-title" id="info-panel-type-title">Task Details</span>
                        <button class="info-panel-close" id="info-panel-close" title="Close">&times;</button>
                    </div>
                    <div id="info-panel-id" class="info-panel-id"></div>
                    <div id="info-panel-task-title" class="info-panel-task-title"></div>
                    <div id="info-panel-short-name-row" class="info-panel-short-name-row" style="display: none;">
                        <span class="info-panel-label">Display Name:</span>
                        <span id="info-panel-short-name" class="info-panel-short-name"></span>
                    </div>
                    <div id="info-panel-meta" class="info-panel-meta"></div>
                    <div id="info-panel-queue-section" class="info-panel-queue-section" style="display: none;">
                        <span class="info-panel-queue-label">In Queue</span>
                        <button id="queue-toggle-btn" class="queue-toggle-switch" title="Toggle queue membership"></button>
                    </div>
                    <div id="info-panel-description-section" class="info-panel-section">
                        <div class="info-panel-section-title">Description</div>
                        <div id="info-panel-description" class="info-panel-description"></div>
                    </div>
                    <div id="info-panel-deps-section" class="info-panel-section" style="display: none;">
                        <div class="info-panel-section-title">Depends On</div>
                        <ul id="info-panel-deps" class="info-panel-deps"></ul>
                    </div>
                    <div id="info-panel-relationships-section" class="info-panel-section" style="display: none;">
                        <div class="info-panel-section-title">Relationships</div>
                        <ul id="info-panel-relationships" class="info-panel-relationships"></ul>
                    </div>
                    <div id="info-panel-closed-section" class="info-panel-section" style="display: none;">
                        <div class="info-panel-section-title">Closed Reason</div>
                        <div id="info-panel-closed-reason" class="info-panel-closed-reason"></div>
                    </div>
                    <div id="info-panel-timestamps-section" class="info-panel-section" style="display: none;">
                        <div class="info-panel-section-title">Timestamps</div>
                        <dl id="info-panel-timestamps" class="info-panel-timestamps"></dl>
                    </div>
                </div>
                <div class="edge-info-panel" id="edge-info-panel">
                    <div class="edge-info-header">
                        <span class="edge-info-title">Edge Details</span>
                        <button class="edge-info-close" id="edge-info-close" title="Close">&times;</button>
                    </div>
                    <div class="edge-info-type" id="edge-info-type">
                        <span class="edge-color-indicator" id="edge-info-color"></span>
                        <span id="edge-info-type-name"></span>
                    </div>
                    <div class="edge-info-connection">
                        <div class="edge-info-node">
                            <span class="edge-info-node-id" id="edge-info-source-id"></span>
                            <span class="edge-info-node-title" id="edge-info-source-title"></span>
                        </div>
                        <div class="edge-info-arrow">â†“</div>
                        <div class="edge-info-node">
                            <span class="edge-info-node-id" id="edge-info-target-id"></span>
                            <span class="edge-info-node-title" id="edge-info-target-title"></span>
                        </div>
                    </div>
                    <div id="edge-info-reason-section" class="edge-info-section" style="display: none;">
                        <div class="edge-info-section-title">Reason</div>
                        <div id="edge-info-reason" class="edge-info-reason"></div>
                    </div>
                    <div class="edge-info-date" id="edge-info-date"></div>
                </div>
            </div>

            <div id="nodes-view" class="view">
                <div class="view-search-container">
                    <div class="view-search-wrapper">
                        <span class="view-search-icon">ðŸ”</span>
                        <input class="view-search" id="nodes-search" type="text" placeholder="Search nodesâ€¦" autocomplete="off" spellcheck="false" />
                    </div>
                    <div class="node-type-filter">
                        <label class="filter-label">Type:</label>
                        <select id="nodes-type-filter" class="type-filter-select">
                            <option value="">All</option>
                            <option value="task">Tasks</option>
                            <option value="bug">Bugs</option>
                            <option value="idea">Ideas</option>
                            <option value="test">Tests</option>
                            <option value="doc">Docs</option>
                        </select>
                    </div>
                    <div class="node-type-filter">
                        <label class="filter-label">Tag:</label>
                        <select id="nodes-tag-filter" class="type-filter-select">
                            <option value="">All</option>
                        </select>
                    </div>
                    <div class="include-closed-toggle">
                        <span class="include-closed-label">Include closed</span>
                        <button class="include-closed-switch" id="nodes-include-closed" title="Include closed/done nodes"></button>
                    </div>
                </div>
                <div class="task-list" id="nodes-list"></div>
            </div>

            <div id="agents-view" class="view">
                <div class="agents-list" id="agents-list"></div>
                <div class="agents-activity-section">
                    <h3>Recent Agent Activity</h3>
                    <div class="agents-activity-log" id="agents-activity-log"></div>
                </div>
            </div>

            <div id="log-view" class="view">
                <div class="log-list" id="log-list"></div>
            </div>
        </main>

        <div class="connection-status">
            <div class="status-dot status-disconnected" id="status-dot"></div>
            <span id="status-text">Connecting...</span>
        </div>

        <!-- Agent Termination Confirmation Modal -->
        <div id="terminate-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <h3>Terminate Agent?</h3>
                <div class="modal-body">
                    <p>Are you sure you want to terminate this agent?</p>
                    <div class="modal-agent-info" id="modal-agent-info"></div>
                </div>
                <div class="modal-actions">
                    <button class="modal-btn modal-btn-cancel" onclick="closeTerminateModal()">Cancel</button>
                    <button class="modal-btn modal-btn-danger" id="confirm-terminate-btn">Terminate</button>
                </div>
            </div>
        </div>

        <!-- Agent Detail Modal (shown on graph node double-click) -->
        <div id="agent-detail-modal" class="modal-overlay agent-detail-modal" style="display: none;">
            <div class="modal-content">
                <h3>ðŸ¤– Agent Details</h3>
                <div class="modal-body">
                    <div class="agent-detail-header">
                        <div class="agent-detail-icon">ðŸ¤–</div>
                        <div class="agent-detail-title">
                            <div class="agent-name" id="agent-modal-name"></div>
                            <div class="agent-pid" id="agent-modal-pid"></div>
                        </div>
                        <span class="badge" id="agent-modal-status-badge"></span>
                    </div>

                    <div class="agent-detail-section" id="agent-modal-purpose-section">
                        <div class="agent-detail-section-title">Purpose</div>
                        <div class="agent-detail-purpose" id="agent-modal-purpose"></div>
                    </div>

                    <div class="agent-detail-section">
                        <div class="agent-detail-section-title">Statistics</div>
                        <div class="agent-detail-grid">
                            <div class="agent-detail-stat">
                                <div class="agent-detail-stat-value" id="agent-modal-command-count">0</div>
                                <div class="agent-detail-stat-label">Commands</div>
                            </div>
                            <div class="agent-detail-stat">
                                <div class="agent-detail-stat-value" id="agent-modal-task-count">0</div>
                                <div class="agent-detail-stat-label">Tasks</div>
                            </div>
                        </div>
                    </div>

                    <div class="agent-detail-section" id="agent-modal-tasks-section" style="display: none;">
                        <div class="agent-detail-section-title">Working On</div>
                        <div class="agent-detail-tasks" id="agent-modal-tasks"></div>
                    </div>

                    <div class="agent-detail-section">
                        <div class="agent-detail-section-title">Timeline</div>
                        <div class="agent-detail-timestamp" id="agent-modal-started"></div>
                        <div class="agent-detail-timestamp" id="agent-modal-last-activity"></div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="modal-btn modal-btn-cancel" onclick="closeAgentDetailModal()">Close</button>
                    <button class="modal-btn modal-btn-danger" id="agent-modal-terminate-btn">Terminate</button>
                </div>
            </div>
        </div>

        <!-- Doc Viewer Modal -->
        <div id="doc-viewer-modal" class="doc-viewer-modal">
            <div class="doc-viewer-container">
                <div class="doc-viewer-header">
                    <div class="doc-viewer-header-content">
                        <div class="doc-viewer-title">
                            <span id="doc-viewer-title-text"></span>
                            <span id="doc-viewer-dirty-indicator" class="summary-dirty-indicator" title="Summary needs update" style="display: none;">âš ï¸</span>
                        </div>
                        <div class="doc-viewer-meta" id="doc-viewer-meta"></div>
                    </div>
                    <button class="doc-viewer-close" onclick="closeDocViewer()" title="Close">&times;</button>
                </div>
                <div class="doc-viewer-body-wrapper">
                    <div class="doc-viewer-main">
                        <div class="doc-viewer-summary" id="doc-viewer-summary">
                            <div class="doc-viewer-summary-header">
                                <span>ðŸ“‹</span> Summary
                            </div>
                            <div class="doc-viewer-summary-content" id="doc-viewer-summary-content"></div>
                        </div>
                        <div class="doc-viewer-content" id="doc-viewer-content"></div>
                    </div>
                    <div class="doc-viewer-history-sidebar" id="doc-viewer-history-sidebar">
                        <div class="doc-viewer-history-header">
                            <span>ðŸ“œ</span> Versions
                        </div>
                        <div class="doc-viewer-history-list" id="doc-viewer-history-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Toast Notification System
        const TOAST_ICONS = {
            success: 'âœ“',
            error: 'âœ•',
            warning: 'âš ',
            info: 'â„¹'
        };

        // Track recent toasts to prevent duplicates
        const recentToasts = new Map();  // message -> timestamp
        const TOAST_DEDUP_MS = 2000;  // Ignore duplicate messages within 2 seconds

        /**
         * Show a toast notification
         * @param {string} message - The message to display
         * @param {string} type - Toast type: 'success', 'error', 'warning', 'info' (default: 'info')
         * @param {number} duration - Auto-dismiss duration in ms (default: 5000, use 0 for no auto-dismiss)
         * @returns {HTMLElement|null} The toast element (can be used to dismiss manually), or null if deduplicated
         */
        function showToast(message, type = 'info', duration = 5000) {
            // Deduplicate: skip if same message shown recently
            const now = Date.now();
            const lastShown = recentToasts.get(message);
            if (lastShown && (now - lastShown) < TOAST_DEDUP_MS) {
                return null;  // Skip duplicate
            }
            recentToasts.set(message, now);
            
            // Clean up old entries periodically (keep map from growing)
            if (recentToasts.size > 50) {
                for (const [msg, timestamp] of recentToasts) {
                    if (now - timestamp > TOAST_DEDUP_MS * 2) {
                        recentToasts.delete(msg);
                    }
                }
            }

            const container = document.getElementById('toast-container');
            
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            
            const icon = document.createElement('span');
            icon.className = 'toast-icon';
            icon.textContent = TOAST_ICONS[type] || TOAST_ICONS.info;
            
            const msg = document.createElement('span');
            msg.className = 'toast-message';
            msg.textContent = message;
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'toast-close';
            closeBtn.innerHTML = '&times;';
            closeBtn.title = 'Dismiss';
            closeBtn.onclick = () => dismissToast(toast);
            
            toast.appendChild(icon);
            toast.appendChild(msg);
            toast.appendChild(closeBtn);
            
            container.appendChild(toast);
            
            // Auto-dismiss if duration > 0
            if (duration > 0) {
                toast._timeout = setTimeout(() => dismissToast(toast), duration);
            }
            
            return toast;
        }

        /**
         * Dismiss a toast notification
         * @param {HTMLElement} toast - The toast element to dismiss
         */
        function dismissToast(toast) {
            if (!toast || !toast.parentNode) return;
            
            // Clear any pending auto-dismiss
            if (toast._timeout) {
                clearTimeout(toast._timeout);
            }
            
            // Add exit animation
            toast.classList.add('toast-exit');
            
            // Remove after animation completes
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }

        // Edge type definitions with display names and default visibility
        const EDGE_TYPES = {
            depends_on: { name: 'Depends', category: 'blocking', defaultVisible: true },
            blocks: { name: 'Blocks', category: 'blocking', defaultVisible: true },
            related_to: { name: 'Related', category: 'informational', defaultVisible: false },
            duplicates: { name: 'Duplicates', category: 'informational', defaultVisible: false },
            fixes: { name: 'Fixes', category: 'fixes', defaultVisible: false },
            caused_by: { name: 'Caused By', category: 'fixes', defaultVisible: false },
            supersedes: { name: 'Supersedes', category: 'informational', defaultVisible: false },
            pinned: { name: 'Pinned', category: 'pinned', defaultVisible: true },
            parent_of: { name: 'Parent', category: 'hierarchy', defaultVisible: false },
            child_of: { name: 'Child', category: 'hierarchy', defaultVisible: false },
            tests: { name: 'Tests', category: 'fixes', defaultVisible: false },
            queued: { name: 'Queued', category: 'queued', defaultVisible: true },
            working_on: { name: 'Working On', category: 'agent', defaultVisible: true },
            worked_on: { name: 'Worked On', category: 'agent', defaultVisible: false }
        };

        // Node types for visibility filtering
        const NODE_TYPES = {
            task: { name: 'Tasks', emoji: 'ðŸ“‹', defaultVisible: true },
            bug: { name: 'Bugs', emoji: 'ðŸ›', defaultVisible: true },
            idea: { name: 'Ideas', emoji: 'ðŸ’­', defaultVisible: true },
            milestone: { name: 'Milestones', emoji: 'ðŸ', defaultVisible: true },
            queue: { name: 'Queue', emoji: 'â¬¡', defaultVisible: true },
            agent: { name: 'Agents', emoji: 'ðŸ¤–', defaultVisible: true },
            doc: { name: 'Docs', emoji: 'ðŸ“„', defaultVisible: true }
        };

        // Load node type filter state from localStorage
        function loadNodeTypeFilters() {
            const saved = localStorage.getItem('binnacle_node_type_filters');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    // Fall back to defaults
                }
            }
            // Default: all node types visible
            const defaults = {};
            for (const [type, info] of Object.entries(NODE_TYPES)) {
                defaults[type] = info.defaultVisible;
            }
            return defaults;
        }

        // Save node type filter state to localStorage
        function saveNodeTypeFilters(filters) {
            localStorage.setItem('binnacle_node_type_filters', JSON.stringify(filters));
        }

        // Load edge filter state from localStorage
        function loadEdgeFilters() {
            const saved = localStorage.getItem('binnacle_edge_filters');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    // Fall back to defaults
                }
            }
            // Default: only blocking edges visible
            const defaults = {};
            for (const [type, info] of Object.entries(EDGE_TYPES)) {
                defaults[type] = info.defaultVisible;
            }
            return defaults;
        }

        // Save edge filter state to localStorage
        function saveEdgeFilters(filters) {
            localStorage.setItem('binnacle_edge_filters', JSON.stringify(filters));
        }

        // Load edge spring (physics) state from localStorage
        function loadEdgeSpringFilters() {
            const saved = localStorage.getItem('binnacle_edge_spring_filters');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    // Fall back to defaults
                }
            }
            // Default: all edge types have springiness enabled
            const defaults = {};
            for (const type of Object.keys(EDGE_TYPES)) {
                defaults[type] = true;
            }
            return defaults;
        }

        // Save edge spring (physics) state to localStorage
        function saveEdgeSpringFilters(filters) {
            localStorage.setItem('binnacle_edge_spring_filters', JSON.stringify(filters));
        }

        // State management
        const state = {
            currentView: 'graph',
            tasks: [],
            ready: [],
            ideas: [],
            tests: [],
            docs: [],
            log: [],
            agents: [],
            edges: [], // Raw edges from API
            edgeFilters: loadEdgeFilters(), // Which edge types are visible
            edgeSpringFilters: loadEdgeSpringFilters(), // Which edge types have spring physics
            nodeTypeFilters: loadNodeTypeFilters(), // Which node types are visible
            ws: null,
            graph: {
                nodes: [],
                edges: [],
                hoveredNode: null,
                hoveredEdge: null,
                mouseX: 0,
                mouseY: 0,
                physics: {
                    damping: 0.92,
                    gravityStrength: 0.05,
                    gravityCenter: { x: 0, y: 0 },
                    repulsionStrength: 2500,
                    springStrength: 0.08,
                    springRestingLength: 200,
                    edgeAttractionEnabled: true,
                    maxVelocity: 3
                },
                // Viewport transformation
                viewport: {
                    panX: 0,
                    panY: 0,
                    zoom: 1.0,
                    minZoom: 0.1,
                    maxZoom: 3.0
                },
                // Drag state
                draggedNode: null,
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                dragNodeStartX: 0,
                dragNodeStartY: 0,
                dragStartTime: 0,
                dragLastX: 0,
                dragLastY: 0,
                // Canvas pan state
                isPanning: false,
                panStartX: 0,
                panStartY: 0,
                panStartOffsetX: 0,
                panStartOffsetY: 0,
                // Selection state
                selectedNode: null,
                selectedEdge: null,
                // Camera pan animation state
                followAnimation: null,  // { startPanX, startPanY, targetPanX, targetPanY, startZoom, targetZoom, startTime, duration }
                // Auto-follow state
                autoFollow: true,  // Whether auto-follow is enabled
                followTargetId: 'auto',  // Target to follow: 'auto', 'active-task', 'queue', or agent ID (e.g., 'bna-xxxx')
                followingNodeId: null,  // ID of node currently being followed (for continuous tracking)
                lastFocusSwitchTime: 0,  // Timestamp of last focus switch (for 10-second delay)
                // Stat highlight filter state (null = no filter active)
                highlightFilter: null,  // e.g., 'bugs', 'blocked', 'ready', 'ideas', 'milestones'
                // Hide completed nodes filter
                hideCompleted: true,  // When true, hide completed nodes except those in active chains
                // Chain length filter (1 = no filter, 2+ = only show nodes in chains of at least that length)
                minChainLength: 1,
                // Search filter
                searchQuery: '',
                // Cached visibility for hit-testing (null until first frame)
                visibleNodes: null,
                visibleNodeIds: null,
                // Animation time for continuous effects (ms)
                animationTime: 0,
                // Animation stability tracking (for performance optimization)
                isAnimating: false,
                stableFrameCount: 0,
                STABLE_THRESHOLD: 0.01,  // Velocity threshold for "stable" detection
                STABLE_FRAMES_REQUIRED: 30  // Number of consecutive stable frames before stopping
            }
        };

        // View search state
        const viewSearch = {
            nodes: ''
        };

        // Include closed state (for searching through completed items)
        const includeClosed = {
            nodes: false
        };

        // Node type filter for consolidated nodes view
        let nodesTypeFilter = '';
        
        // Node tag filter for consolidated nodes view
        let nodesTagFilter = '';

        // WebSocket connection
        let pendingReload = null;
        const RELOAD_DEBOUNCE_MS = 100;  // Client-side debounce as backup
        let wasConnected = false;  // Track connection state for toast notifications
        let disconnectToast = null;  // Track active disconnect toast
        let initialLoadComplete = false;  // Track if we've done the initial data load
        let initialLoadInProgress = false;  // Prevent reload processing during initial load
        const shownClosedToasts = new Set();  // Track task IDs that have shown "closed" notification

        function connectWebSocket() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            state.ws = new WebSocket(`${protocol}//${location.host}/ws`);

            state.ws.onopen = async () => {
                updateConnectionStatus(true);
                // Show reconnection toast only if we were previously connected
                if (wasConnected) {
                    // Dismiss any active disconnect toast
                    if (disconnectToast) {
                        dismissToast(disconnectToast);
                        disconnectToast = null;
                    }
                    showToast('Connection restored', 'success', 3000);
                }
                const isInitialLoad = !wasConnected;
                wasConnected = true;
                // Mark initial load in progress to prevent reload messages from racing
                initialLoadInProgress = true;
                await loadData();
                initialLoadInProgress = false;
                // On initial page load, snap to active task if auto-follow is enabled
                if (isInitialLoad && state.graph.autoFollow) {
                    snapToActiveTask();
                }
            };

            state.ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.type === 'reload') {
                    // Skip reload processing if initial load is still in progress
                    // This prevents race conditions where stale state is compared
                    if (initialLoadInProgress) return;
                    // Debounce rapid reload messages
                    if (pendingReload) clearTimeout(pendingReload);
                    pendingReload = setTimeout(async () => {
                        pendingReload = null;
                        // Save previous statuses for auto-follow detection
                        const prevStatuses = {};
                        const prevTitles = {};
                        if (state.tasks) {
                            state.tasks.forEach(t => {
                                prevStatuses[t.id] = t.status;
                                prevTitles[t.id] = t.title;
                            });
                        }
                        
                        await loadData();
                        
                        // When auto-follow is enabled and we have a selected target,
                        // re-center on the target node if it has moved
                        if (state.graph.autoFollow && state.graph.followTargetId) {
                            // Find the target node based on followTargetId
                            let targetNode = null;
                            if (state.graph.followTargetId === 'auto') {
                                // Auto mode: follow the agent with the most recent activity
                                // But only switch focus if 10 seconds have passed since last switch
                                const FOCUS_SWITCH_DELAY_MS = 10000;
                                const mostRecentAgent = findMostRecentlyActiveAgent();
                                if (mostRecentAgent) {
                                    const now = Date.now();
                                    const timeSinceLastSwitch = now - state.graph.lastFocusSwitchTime;
                                    
                                    if (state.graph.followingNodeId !== mostRecentAgent.id) {
                                        // Different agent is most active - check if we can switch
                                        if (timeSinceLastSwitch >= FOCUS_SWITCH_DELAY_MS || !state.graph.followingNodeId) {
                                            // Enough time has passed, or no current focus - switch
                                            targetNode = mostRecentAgent;
                                            state.graph.lastFocusSwitchTime = now;
                                        } else {
                                            // Keep following current agent (delay not met)
                                            targetNode = state.tasks?.find(t => t.id === state.graph.followingNodeId && t.type === 'agent');
                                        }
                                    } else {
                                        // Same agent - keep following
                                        targetNode = mostRecentAgent;
                                    }
                                }
                            } else if (state.graph.followTargetId === 'active-task') {
                                targetNode = state.tasks?.find(t => 
                                    (t.type === 'task' || t.type === 'bug') && t.status === 'in_progress'
                                );
                            } else if (state.graph.followTargetId === 'queue') {
                                targetNode = state.tasks?.find(t => t.type === 'queue');
                            } else {
                                targetNode = state.tasks?.find(t => t.id === state.graph.followTargetId && t.type === 'agent');
                            }
                            
                            if (targetNode && state.graph.followingNodeId !== targetNode.id) {
                                // Target exists but we weren't following it - start following
                                state.graph.followingNodeId = targetNode.id;
                                panToNode(targetNode.id, true);
                            } else if (targetNode) {
                                // Target is being followed - re-pan to keep it centered
                                panToNode(targetNode.id, false);  // Don't zoom, just pan
                            }
                        }
                        
                        // Task completion detection: show toast when task is closed (1 minute timeout)
                        // Track shown notifications by task ID to prevent duplicates across reloads
                        if (state.tasks) {
                            for (const task of state.tasks) {
                                const prevStatus = prevStatuses[task.id];
                                if (task.status === 'done' && prevStatus && prevStatus !== 'done') {
                                    // Task just transitioned to done - show toast only if not shown before
                                    if (!shownClosedToasts.has(task.id)) {
                                        shownClosedToasts.add(task.id);
                                        showToast(`âœ… Task closed: ${task.id} - ${task.title}`, 'success', 60000);
                                    }
                                } else if (task.status !== 'done' && prevStatus === 'done') {
                                    // Task was reopened - allow showing closed toast again if it closes
                                    shownClosedToasts.delete(task.id);
                                }
                            }
                        }
                        
                        // New task/bug detection: show auto-dismissing toast for new additions
                        // Only show if we've done the initial load (skip first population)
                        if (state.tasks && initialLoadComplete) {
                            for (const task of state.tasks) {
                                // Check if this is a new item (not in previous state)
                                if (prevStatuses[task.id] === undefined) {
                                    if (task.type === 'bug') {
                                        showToast(`ðŸ› Bug added: ${task.id} - ${task.title}`, 'warning', 5000);
                                    } else if (task.type === 'task') {
                                        showToast(`ðŸ“‹ Task added: ${task.id} - ${task.title}`, 'info', 5000);
                                    }
                                }
                            }
                        }
                        initialLoadComplete = true;
                    }, RELOAD_DEBOUNCE_MS);
                }
            };

            state.ws.onclose = () => {
                updateConnectionStatus(false);
                // Show disconnect toast if we were connected (and don't have one already)
                if (wasConnected && !disconnectToast) {
                    disconnectToast = showToast('Connection lost, reconnecting...', 'warning', 0);
                }
                setTimeout(connectWebSocket, 2000);
            };

            state.ws.onerror = () => {
                updateConnectionStatus(false);
            };
        }

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('status-dot');
            const text = document.getElementById('status-text');
            dot.className = `status-dot status-${connected ? 'connected' : 'disconnected'}`;
            text.textContent = connected ? 'Connected' : 'Disconnected';
        }

        // Data loading
        async function loadData() {
            // Load all data in parallel
            const [configData, tasksData, bugsData, ideasData, readyData, testsData, docsData, logData, edgesData, agentsData, queueData] = await Promise.all([
                fetch('/api/config').then(r => r.json()),
                fetch('/api/tasks').then(r => r.json()),
                fetch('/api/bugs').then(r => r.json()),
                fetch('/api/ideas').then(r => r.json()),
                fetch('/api/ready').then(r => r.json()),
                fetch('/api/tests').then(r => r.json()),
                fetch('/api/docs').then(r => r.json()),
                fetch('/api/log').then(r => r.json()),
                fetch('/api/edges').then(r => r.json()),
                fetch('/api/agents').then(r => r.json()),
                fetch('/api/queue').then(r => r.json())
            ]);
            
            // Update the document title with project name
            if (configData.project_name) {
                document.title = `${configData.project_name} - Binnacle`;
            }
            
            // Merge tasks, bugs, and ideas into unified tasks array for graph
            // Normalize bugs and ideas to have task-like fields for consistent rendering
            const normalizedBugs = (bugsData.bugs || []).map(bug => ({
                ...bug,
                type: 'bug',
                priority: bug.priority ?? 2,  // Default P2 if not set
                short_name: bug.short_name || null
            }));
            const normalizedIdeas = (ideasData.ideas || []).map(idea => ({
                ...idea,
                type: 'idea',
                priority: 4,  // Ideas are low priority by default
                short_name: idea.short_name || null,
                depends_on: idea.depends_on || []
            }));
            // Normalize queue to have node-like fields for graph rendering
            const normalizedQueue = queueData.queue ? [{
                ...queueData.queue,
                type: 'queue',
                status: 'active',  // Queues don't have status, use 'active' for rendering
                priority: 0,
                short_name: queueData.queue.title || null,
                depends_on: []
            }] : [];
            
            // Normalize agents to have node-like fields for graph rendering
            // Only show worker agents in the graph (filter out planner and buddy agents)
            const workerAgents = (agentsData.agents || []).filter(agent => agent.agent_type === 'worker');
            const normalizedAgents = workerAgents.map(agent => ({
                // Use proper binnacle ID (bna-xxxx) if available, fall back to PID-based ID for backwards compat
                id: agent.id || `agent-${agent.pid}`,
                title: agent.name,
                short_name: agent.purpose || agent.name,
                type: 'agent',
                status: agent.status,  // active, idle, stale
                priority: 0,  // Agents are high priority for visibility
                depends_on: [],
                // Keep original agent data for reference
                _agent: agent
            }));
            
            // Normalize docs to have node-like fields for graph rendering
            const normalizedDocs = (docsData.docs || []).map(doc => ({
                ...doc,
                type: 'doc',
                status: 'active',  // Docs don't have status, use 'active' for rendering
                priority: 3,  // Lower priority for layout
                short_name: doc.short_name || doc.title,
                depends_on: doc.supersedes ? [doc.supersedes] : []  // Version chain as dependency
            }));
            
            state.tasks = [...(tasksData.tasks || []), ...normalizedBugs, ...normalizedIdeas, ...normalizedQueue, ...normalizedAgents, ...normalizedDocs];
            state.ready = readyData.tasks || [];
            state.ideas = ideasData.ideas || [];
            state.tests = testsData.tests || [];
            state.docs = docsData.docs || [];
            state.log = logData.log || [];
            
            // Build agent-to-task edges ("working_on" edge type)
            // Only include edges from worker agents (same filter as node rendering)
            // Note: These edges should also exist in the main edges data now that working_on is a proper edge type
            // but we still build them here for backwards compatibility with agents without proper binnacle IDs
            const agentEdges = workerAgents
                .filter(agent => !agent.id)  // Only for agents without binnacle IDs
                .flatMap(agent => 
                    (agent.tasks || []).map(taskId => ({
                        source: `agent-${agent.pid}`,
                        target: taskId,
                        edge_type: 'working_on'
                    }))
                );
            
            // Build supersedes edges from docs (version chain)
            const docEdges = normalizedDocs
                .filter(doc => doc.supersedes)
                .map(doc => ({
                    source: doc.id,
                    target: doc.supersedes,
                    edge_type: 'supersedes'
                }));
            
            state.edges = [...(edgesData.edges || []), ...agentEdges, ...docEdges];
            state.agents = agentsData.agents || [];
            
            updateFollowSelector();
            updateStatsOverlay();
            updateActiveTaskPane();
            updateAvailableWorkPane();
            updateRecentlyCompletedPane();
            renderCurrentView();
        }

        function updateStatsOverlay() {
            // Stats are no longer displayed in filter dropdown - node type filters handle visibility
            // Just trigger update of active task pane and recently completed
        }
        
        function updateActiveTaskPane() {
            const pane = document.getElementById('active-task-pane');
            const idEl = document.getElementById('active-task-id');
            const titleEl = document.getElementById('active-task-title');
            const metaEl = document.getElementById('active-task-meta');
            
            // Find first in_progress task
            const activeTask = state.tasks.find(t => t.status === 'in_progress');
            
            if (activeTask) {
                pane.classList.remove('empty');
                idEl.textContent = activeTask.id;
                titleEl.textContent = activeTask.title || 'Untitled task';
                titleEl.title = activeTask.title || '';  // Full title on hover
                
                // Build meta badges
                let metaHtml = '';
                if (activeTask.priority !== undefined) {
                    metaHtml += `<span class="badge badge-priority-${activeTask.priority}">P${activeTask.priority}</span>`;
                }
                if (activeTask.tags && activeTask.tags.length > 0) {
                    activeTask.tags.slice(0, 2).forEach(tag => {
                        metaHtml += `<span class="badge badge-tag">${tag}</span>`;
                    });
                }
                metaEl.innerHTML = metaHtml;
            } else {
                pane.classList.add('empty');
                idEl.textContent = 'No active task';
                titleEl.textContent = '';
                titleEl.title = '';
                metaEl.innerHTML = '';
            }
        }
        
        /**
         * Create an emoji count badge element.
         * @param {string} emoji - The emoji to display
         * @param {number} count - The count to display
         * @param {string} type - The type for styling ('task', 'bug', 'idea')
         * @param {string} label - Accessible label for the badge
         * @returns {HTMLElement} The badge element
         */
        function createEmojiCountBadge(emoji, count, type, label) {
            const badge = document.createElement('span');
            badge.className = `emoji-count-badge type-${type}`;
            badge.title = label;
            badge.innerHTML = `<span class="emoji">${emoji}</span><span class="count">${count}</span>`;
            return badge;
        }

        /**
         * Update the available work counter in the header.
         * Shows total count of claimable items: ready tasks + open bugs + open ideas.
         */
        function updateAvailableWorkPane() {
            const pane = document.getElementById('available-work-pane');
            const countEl = document.getElementById('available-work-count');
            const breakdownEl = document.getElementById('available-work-breakdown');
            
            // Count ready tasks (pending tasks with no blockers, excluding bugs and ideas)
            const readyTasks = (state.ready || []).filter(t => t.type !== 'bug' && t.type !== 'idea');
            const readyTaskCount = readyTasks.length;
            
            // Count open bugs (not done, not cancelled)
            const openBugs = (state.tasks || []).filter(t => 
                t.type === 'bug' && 
                t.status !== 'done' && 
                t.status !== 'cancelled'
            );
            const openBugCount = openBugs.length;
            
            // Count open ideas (seed or germinating)
            const openIdeas = (state.ideas || []).filter(idea => 
                idea.status === 'seed' || idea.status === 'germinating'
            );
            const openIdeaCount = openIdeas.length;
            
            const totalCount = readyTaskCount + openBugCount + openIdeaCount;
            
            countEl.textContent = totalCount;
            
            // Update styling based on whether there's work
            pane.classList.remove('has-work', 'no-work');
            pane.classList.add(totalCount > 0 ? 'has-work' : 'no-work');
            
            // Show breakdown using emoji badges
            breakdownEl.innerHTML = '';
            if (readyTaskCount > 0) {
                breakdownEl.appendChild(createEmojiCountBadge('ðŸ“‹', readyTaskCount, 'task', `${readyTaskCount} ready task${readyTaskCount !== 1 ? 's' : ''}`));
            }
            if (openBugCount > 0) {
                breakdownEl.appendChild(createEmojiCountBadge('ðŸ›', openBugCount, 'bug', `${openBugCount} open bug${openBugCount !== 1 ? 's' : ''}`));
            }
            if (openIdeaCount > 0) {
                breakdownEl.appendChild(createEmojiCountBadge('ðŸ’­', openIdeaCount, 'idea', `${openIdeaCount} open idea${openIdeaCount !== 1 ? 's' : ''}`));
            }
        }
        
        /**
         * Update the recently completed pane in the header.
         * Shows tasks/bugs/ideas completed within the configurable time window.
         */
        function updateRecentlyCompletedPane() {
            const pane = document.getElementById('recently-completed-pane');
            const list = document.getElementById('recently-completed-list');
            
            const now = Date.now();
            
            // Find all items that were closed recently (within the pane window)
            const recentlyCompleted = state.tasks
                .filter(item => {
                    // Must have a closed_at timestamp
                    if (!item.closed_at) return false;
                    // Must be in a completed state
                    if (item.status !== 'done' && item.status !== 'cancelled' && item.status !== 'discarded') return false;
                    // Must be within the time window
                    const closedTime = new Date(item.closed_at).getTime();
                    const age = now - closedTime;
                    return age < RECENTLY_COMPLETED_PANE_WINDOW_MS;
                })
                // Sort by most recently closed first
                .sort((a, b) => new Date(b.closed_at).getTime() - new Date(a.closed_at).getTime())
                // Limit to 5 items to keep the pane compact
                .slice(0, 5);
            
            if (recentlyCompleted.length === 0) {
                pane.classList.add('empty');
                list.innerHTML = '<div class="recently-completed-empty">No recent completions</div>';
                return;
            }
            
            pane.classList.remove('empty');
            
            // Build the list HTML
            list.innerHTML = recentlyCompleted.map(item => {
                const closedTime = new Date(item.closed_at).getTime();
                const age = now - closedTime;
                const ago = formatTimeAgo(age);
                
                // Determine if the item is fading (older than half the window)
                const isFading = age > RECENTLY_COMPLETED_PANE_WINDOW_MS / 2;
                
                // Get display title (use short_name if available, fall back to title)
                const title = item.short_name || item.title || 'Untitled';
                
                // Get type icon
                let icon = '';
                if (item.type === 'bug') icon = 'ðŸ› ';
                else if (item.type === 'idea') icon = 'ðŸ’­ ';
                
                return `
                    <div class="recently-completed-item${isFading ? ' fading' : ''}" title="${title}">
                        <span class="recently-completed-id">${item.id}</span>
                        <span class="recently-completed-title">${icon}${escapeHtml(title)}</span>
                        <span class="recently-completed-ago">${ago}</span>
                    </div>
                `;
            }).join('');
        }
        
        /**
         * Format a time duration in ms to a human-readable "X ago" string.
         */
        function formatTimeAgo(ms) {
            const seconds = Math.floor(ms / 1000);
            if (seconds < 60) return `${seconds}s ago`;
            
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m ago`;
            
            const hours = Math.floor(minutes / 60);
            return `${hours}h ago`;
        }
        
        /**
         * Escape HTML special characters to prevent XSS.
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Initialize node type visibility filters (with eye icons like edge filters)
        function initializeNodeTypeFilters() {
            const container = document.getElementById('sidebar-node-filters');
            if (!container) return;
            
            // Create filter buttons for each node type
            container.innerHTML = '';
            
            // Add "All" toggle button first
            const allBtn = document.createElement('button');
            allBtn.className = 'node-filter-btn node-filter-all';
            allBtn.textContent = 'All';
            allBtn.title = 'Toggle all node types';
            
            const updateAllBtnState = () => {
                const allActive = Object.keys(NODE_TYPES).every(type => state.nodeTypeFilters[type]);
                allBtn.classList.toggle('active', allActive);
            };
            
            allBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const allActive = Object.keys(NODE_TYPES).every(type => state.nodeTypeFilters[type]);
                const newState = !allActive;
                
                for (const type of Object.keys(NODE_TYPES)) {
                    state.nodeTypeFilters[type] = newState;
                }
                
                // Update all visibility button states
                container.querySelectorAll('.node-visibility-btn').forEach(visBtn => {
                    const type = visBtn.dataset.nodeType;
                    if (type) {
                        visBtn.classList.toggle('active', newState);
                        visBtn.title = newState 
                            ? `Hide ${NODE_TYPES[type].name}`
                            : `Show ${NODE_TYPES[type].name}`;
                    }
                });
                updateAllBtnState();
                saveNodeTypeFilters(state.nodeTypeFilters);
                startAnimation();  // Restart animation to apply filter
            });
            
            container.appendChild(allBtn);
            
            for (const [type, info] of Object.entries(NODE_TYPES)) {
                // Create row container: [eye visibility] [emoji label]
                const row = document.createElement('div');
                row.className = 'node-filter-row';
                
                // Create eye visibility button
                const visBtn = document.createElement('button');
                visBtn.className = 'node-visibility-btn' + (state.nodeTypeFilters[type] ? ' active' : '');
                visBtn.dataset.nodeType = type;
                visBtn.innerHTML = 'ðŸ‘';
                visBtn.title = state.nodeTypeFilters[type] 
                    ? `Hide ${info.name}`
                    : `Show ${info.name}`;
                
                // Create label button
                const btn = document.createElement('button');
                btn.className = 'node-filter-btn' + (state.nodeTypeFilters[type] ? ' active' : '');
                btn.dataset.nodeType = type;
                btn.innerHTML = `${info.emoji} ${info.name}`;
                btn.title = `Toggle ${info.name} visibility`;
                
                // Eye button: toggle visibility
                visBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    state.nodeTypeFilters[type] = !state.nodeTypeFilters[type];
                    visBtn.classList.toggle('active', state.nodeTypeFilters[type]);
                    btn.classList.toggle('active', state.nodeTypeFilters[type]);
                    visBtn.title = state.nodeTypeFilters[type] 
                        ? `Hide ${info.name}`
                        : `Show ${info.name}`;
                    updateAllBtnState();
                    saveNodeTypeFilters(state.nodeTypeFilters);
                    startAnimation();
                });
                
                // Label button: also toggles visibility
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    state.nodeTypeFilters[type] = !state.nodeTypeFilters[type];
                    visBtn.classList.toggle('active', state.nodeTypeFilters[type]);
                    btn.classList.toggle('active', state.nodeTypeFilters[type]);
                    visBtn.title = state.nodeTypeFilters[type] 
                        ? `Hide ${info.name}`
                        : `Show ${info.name}`;
                    updateAllBtnState();
                    saveNodeTypeFilters(state.nodeTypeFilters);
                    startAnimation();
                });
                
                row.appendChild(visBtn);
                row.appendChild(btn);
                container.appendChild(row);
            }
            
            updateAllBtnState();
        }
        
        // Legacy function name for compatibility
        function initializeStatFilters() {
            initializeNodeTypeFilters();
        }
        
        // Toggle stat filter on/off (kept for highlight filter compatibility)
        function toggleStatFilter(filterName) {
            if (state.graph.highlightFilter === filterName) {
                // Clear filter if clicking same one
                state.graph.highlightFilter = null;
            } else {
                // Set new filter
                state.graph.highlightFilter = filterName;
            }
            updateStatFilterHighlights();
            startAnimation();  // Restart animation to apply highlight filter
        }
        
        // Update visual state of stat filter buttons
        function updateStatFilterHighlights() {
            // No longer needed - node type filters handle visibility directly
        }
        
        // Check if a node matches the current highlight filter (deprecated - kept for compatibility)
        function nodeMatchesFilter(node) {
            // With node type filters, all visible nodes match
            return true;
        }

        // View switching
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const view = btn.dataset.view;
                switchView(view);
            });
        });

        function switchView(view) {
            state.currentView = view;
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-view="${view}"]`).classList.add('active');
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(`${view}-view`).classList.add('active');
            renderCurrentView();
        }

        // Rendering
        function renderCurrentView() {
            switch (state.currentView) {
                case 'graph':
                    renderGraph();
                    renderAgentsSidebar();  // Update agents sidebar on graph view
                    break;
                case 'nodes':
                    syncTypeFilterDropdown();  // Sync type filter dropdown with JS variable
                    updateTagFilterDropdown();  // Update tag dropdown when switching to nodes view
                    renderNodes();
                    break;
                case 'agents':
                    renderAgents();
                    break;
                case 'log':
                    renderLog();
                    break;
            }
        }

        function renderGraph() {
            // This will be implemented with spring physics
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            if (state.tasks.length === 0) {
                renderEmptyState(ctx, 'No tasks yet');
                return;
            }

            // Build graph data structure
            buildGraphData();

            // Add mouse event listeners
            setupGraphMouseHandlers(canvas);

            // Initialize zoom display
            updateZoomDisplay();

            // Start animation loop
            startAnimation();
        }

        function setupGraphMouseHandlers(canvas) {
            // Remove old listeners to avoid duplicates
            const newCanvas = canvas.cloneNode(true);
            canvas.parentNode.replaceChild(newCanvas, canvas);
            const finalCanvas = document.getElementById('graph-canvas');

            finalCanvas.addEventListener('mousemove', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Handle canvas panning
                if (state.graph.isPanning) {
                    const dx = mouseX - state.graph.panStartX;
                    const dy = mouseY - state.graph.panStartY;
                    const zoom = state.graph.viewport.zoom;

                    // Update pan offset (inversely proportional to zoom)
                    state.graph.viewport.panX = state.graph.panStartOffsetX + dx / zoom;
                    state.graph.viewport.panY = state.graph.panStartOffsetY + dy / zoom;
                    return;
                }

                const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                if (state.graph.isDragging && state.graph.draggedNode) {
                    // Update dragged node position in world coordinates
                    const currentWorld = screenToWorld(mouseX, mouseY, finalCanvas);
                    const startWorld = screenToWorld(state.graph.dragStartX, state.graph.dragStartY, finalCanvas);
                    const dx = currentWorld.x - startWorld.x;
                    const dy = currentWorld.y - startWorld.y;
                    const node = state.graph.draggedNode;

                    node.x = state.graph.dragNodeStartX + dx;
                    node.y = state.graph.dragNodeStartY + dy;

                    // No boundary clamping for infinite canvas

                    // Track for momentum calculation
                    state.graph.dragLastX = mouseX;
                    state.graph.dragLastY = mouseY;

                    // Update tooltip position
                    updateTooltip(node, e.clientX, e.clientY);
                } else {
                    // Normal hover behavior - use world coordinates
                    state.graph.mouseX = worldPos.x;
                    state.graph.mouseY = worldPos.y;

                    // Find hovered node using world coordinates
                    const hoveredNode = state.graph.nodes.find(node => {
                        const dx = worldPos.x - node.x;
                        const dy = worldPos.y - node.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= node.radius;
                    });

                    if (hoveredNode !== state.graph.hoveredNode) {
                        state.graph.hoveredNode = hoveredNode;
                        updateTooltip(hoveredNode, e.clientX, e.clientY);
                        finalCanvas.classList.toggle('hovering', !!hoveredNode);
                        // Hide edge tooltip when showing node tooltip
                        if (hoveredNode) {
                            state.graph.hoveredEdge = null;
                            updateEdgeTooltip(null);
                        }
                    }

                    // Check for edge hover only if not hovering over a node
                    if (!hoveredNode) {
                        const hoveredEdge = findHoveredEdge(worldPos.x, worldPos.y);
                        if (hoveredEdge !== state.graph.hoveredEdge) {
                            state.graph.hoveredEdge = hoveredEdge;
                            updateEdgeTooltip(hoveredEdge, e.clientX, e.clientY);
                        } else if (hoveredEdge) {
                            // Update position while still hovering same edge
                            updateEdgeTooltip(hoveredEdge, e.clientX, e.clientY);
                        }
                    }
                }
            });

            finalCanvas.addEventListener('mouseleave', () => {
                // End any active drag
                if (state.graph.isDragging && state.graph.draggedNode) {
                    // Apply gentle stop (no momentum on mouse leave)
                    state.graph.draggedNode.vx = 0;
                    state.graph.draggedNode.vy = 0;
                    state.graph.isDragging = false;
                    state.graph.draggedNode = null;
                }

                // End any active pan
                if (state.graph.isPanning) {
                    state.graph.isPanning = false;
                    finalCanvas.style.cursor = 'default';
                }

                state.graph.hoveredNode = null;
                state.graph.hoveredEdge = null;
                updateTooltip(null);
                updateEdgeTooltip(null);
                finalCanvas.classList.remove('hovering', 'dragging');
            });

            finalCanvas.addEventListener('mousedown', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Middle mouse or Shift+Left mouse = always canvas pan
                // But not while auto-follow animation is active
                if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                    if (state.graph.followAnimation && state.graph.autoFollow) {
                        return; // Block panning during auto-follow
                    }
                    cancelPanAnimation();  // Cancel any ongoing camera animation
                    state.graph.isPanning = true;
                    state.graph.panStartX = mouseX;
                    state.graph.panStartY = mouseY;
                    state.graph.panStartOffsetX = state.graph.viewport.panX;
                    state.graph.panStartOffsetY = state.graph.viewport.panY;
                    finalCanvas.style.cursor = 'grabbing';
                    startAnimation();  // Restart animation on interaction
                    e.preventDefault();
                    return;
                }

                // Left mouse button = node drag or canvas pan
                if (e.button === 0) {
                    const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                    // Find node under mouse using world coordinates (visible nodes only)
                    const nodesForHitTest = state.graph.visibleNodes ?? state.graph.nodes;
                    const node = nodesForHitTest.find(n => {
                        const dx = worldPos.x - n.x;
                        const dy = worldPos.y - n.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= n.radius;
                    });

                    if (node) {
                        // Node found - drag the node
                        state.graph.draggedNode = node;
                        state.graph.isDragging = true;
                        state.graph.dragStartX = mouseX;
                        state.graph.dragStartY = mouseY;
                        state.graph.dragNodeStartX = node.x;
                        state.graph.dragNodeStartY = node.y;
                        state.graph.dragStartTime = Date.now();
                        state.graph.dragLastX = mouseX;
                        state.graph.dragLastY = mouseY;
                        finalCanvas.classList.add('dragging');
                        startAnimation();  // Restart animation on drag
                        e.preventDefault();
                    } else {
                        // No node found - pan the canvas (but not during auto-follow animation)
                        if (state.graph.followAnimation && state.graph.autoFollow) {
                            return; // Block panning during auto-follow animation
                        }
                        // User is manually panning - stop following the node
                        state.graph.followingNodeId = null;
                        cancelPanAnimation();  // Cancel any ongoing camera animation
                        state.graph.isPanning = true;
                        state.graph.panStartX = mouseX;
                        state.graph.panStartY = mouseY;
                        state.graph.panStartOffsetX = state.graph.viewport.panX;
                        state.graph.panStartOffsetY = state.graph.viewport.panY;
                        finalCanvas.style.cursor = 'grabbing';
                        startAnimation();  // Restart animation on pan
                        e.preventDefault();
                    }
                }
            });

            finalCanvas.addEventListener('mouseup', (e) => {
                // End canvas panning
                if (state.graph.isPanning) {
                    state.graph.isPanning = false;
                    finalCanvas.style.cursor = 'default';
                }

                // End node dragging
                if (state.graph.isDragging && state.graph.draggedNode) {
                    const rect = finalCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                    // Check if dropped on a queue node (drag-to-queue)
                    const draggedNode = state.graph.draggedNode;
                    const nodesForHitTest = state.graph.visibleNodes ?? state.graph.nodes;
                    const dropTarget = nodesForHitTest.find(n => {
                        if (n.id === draggedNode.id) return false;  // Skip self
                        const dx = worldPos.x - n.x;
                        const dy = worldPos.y - n.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= n.radius;
                    });

                    // If dropped on a queue and the dragged node is task/bug, add to queue
                    if (dropTarget && dropTarget.type === 'queue') {
                        const canBeQueued = ['task', 'bug'].includes(draggedNode.type);
                        const alreadyQueued = isNodeQueued(draggedNode.id);
                        
                        if (canBeQueued && !alreadyQueued) {
                            // Add queued link via API
                            fetch('/api/edges', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    source: draggedNode.id,
                                    target: dropTarget.id,
                                    edge_type: 'queued'
                                })
                            })
                            .then(r => r.json())
                            .then(result => {
                                if (result.success) {
                                    console.log(`Added ${draggedNode.id} to queue`);
                                    // The WebSocket will notify us of the change
                                } else {
                                    console.error('Failed to add to queue:', result.error);
                                }
                            })
                            .catch(err => console.error('Failed to add to queue:', err));
                        }
                    }

                    // Calculate momentum from recent drag motion in screen space
                    // Velocity is in world units per frame, so scale by zoom
                    const zoom = state.graph.viewport.zoom;
                    const velocityX = (mouseX - state.graph.dragLastX) * 2.5 / zoom;
                    const velocityY = (mouseY - state.graph.dragLastY) * 2.5 / zoom;

                    state.graph.draggedNode.vx = velocityX;
                    state.graph.draggedNode.vy = velocityY;

                    // Clear drag state
                    state.graph.isDragging = false;
                    state.graph.draggedNode = null;
                    finalCanvas.classList.remove('dragging');

                    // Update hover state (mouse may still be over a node)
                    const hoveredNode = nodesForHitTest.find(n => {
                        const dx = worldPos.x - n.x;
                        const dy = worldPos.y - n.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= n.radius;
                    });
                    state.graph.hoveredNode = hoveredNode;
                    updateTooltip(hoveredNode, e.clientX, e.clientY);
                    finalCanvas.classList.toggle('hovering', !!hoveredNode);
                }
            });

            finalCanvas.addEventListener('dblclick', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                // Find node under mouse using world coordinates (visible nodes only)
                const nodesForHitTest = state.graph.visibleNodes ?? state.graph.nodes;
                const node = nodesForHitTest.find(n => {
                    const dx = worldPos.x - n.x;
                    const dy = worldPos.y - n.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance <= n.radius;
                });

                if (node) {
                    // Check if it's an agent node - show detail modal
                    if (node.type === 'agent' && node._agent) {
                        showAgentDetailModal(node._agent);
                        e.preventDefault();
                        return;
                    }
                    
                    // Toggle selection for non-agent nodes
                    if (state.graph.selectedNode === node) {
                        state.graph.selectedNode = null;
                    } else {
                        state.graph.selectedNode = node;
                    }
                    // Hide edge info panel when selecting a node
                    state.graph.selectedEdge = null;
                    updateEdgeInfoPanel(null);
                    // Update info panel with current selection
                    updateInfoPanel(state.graph.selectedNode);
                } else {
                    // Check for edge under mouse
                    const edge = findHoveredEdge(worldPos.x, worldPos.y);
                    if (edge) {
                        // Show edge info panel
                        updateEdgeInfoPanel(edge);
                    } else {
                        // Click on empty space deselects everything
                        state.graph.selectedNode = null;
                        state.graph.selectedEdge = null;
                        updateInfoPanel(null);
                        updateEdgeInfoPanel(null);
                    }
                }

                e.preventDefault();
            });

            // Mouse wheel zoom
            finalCanvas.addEventListener('wheel', (e) => {
                e.preventDefault();

                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
                zoomCanvas(zoomDelta, mouseX, mouseY);
            }, { passive: false });
        }

        // Zoom button controls
        document.getElementById('zoom-in').addEventListener('click', () => {
            zoomCanvas(1.2);
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            zoomCanvas(0.8);
        });

        document.getElementById('zoom-reset').addEventListener('click', () => {
            state.graph.viewport.zoom = 1.0;
            state.graph.viewport.panX = 0;
            state.graph.viewport.panY = 0;
            updateZoomDisplay();
            startAnimation();  // Restart animation to redraw
        });

        // Maximize/fullscreen toggle
        document.getElementById('maximize-btn').addEventListener('click', () => {
            toggleGraphFullscreen();
        });

        function toggleGraphFullscreen() {
            const graphView = document.getElementById('graph-view');
            const maximizeBtn = document.getElementById('maximize-btn');
            const isFullscreen = graphView.classList.toggle('fullscreen');
            
            // Update button icon and title
            maximizeBtn.textContent = isFullscreen ? 'â›¶' : 'â›¶';
            maximizeBtn.title = isFullscreen ? 'Exit Fullscreen (Esc)' : 'Fullscreen (Esc to exit)';
            
            // Resize canvas to fit new dimensions
            const canvas = document.getElementById('graph-canvas');
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            
            startAnimation();  // Restart animation to redraw
        }

        // Escape key to exit fullscreen
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const graphView = document.getElementById('graph-view');
                if (graphView.classList.contains('fullscreen')) {
                    toggleGraphFullscreen();
                }
            }
        });

        // Auto-follow toggle and agent selector
        document.getElementById('auto-follow-switch').addEventListener('click', () => {
            state.graph.autoFollow = !state.graph.autoFollow;
            updateAutoFollowDisplay();
            // When enabling auto-follow, immediately snap to selected target
            if (state.graph.autoFollow && state.graph.followTargetId) {
                snapToFollowTarget();
            } else if (!state.graph.autoFollow) {
                // When disabling auto-follow, stop tracking
                state.graph.followingNodeId = null;
            }
        });

        document.getElementById('agent-selector').addEventListener('change', (e) => {
            state.graph.followTargetId = e.target.value || 'auto';
            // Reset focus switch time when user manually selects a target
            state.graph.lastFocusSwitchTime = Date.now();
            // If auto-follow is enabled and we selected a target, snap to it
            if (state.graph.autoFollow && state.graph.followTargetId) {
                snapToFollowTarget();
            } else {
                state.graph.followingNodeId = null;
            }
        });

        function updateAutoFollowDisplay() {
            const switchEl = document.getElementById('auto-follow-switch');
            if (state.graph.autoFollow) {
                switchEl.classList.add('active');
            } else {
                switchEl.classList.remove('active');
            }
        }

        function updateFollowSelector() {
            const selector = document.getElementById('agent-selector');
            const workerAgents = (state.agents || []).filter(a => a.agent_type === 'worker');
            const queueNode = state.tasks?.find(t => t.type === 'queue');
            const hasActiveTask = state.tasks?.some(t => 
                (t.type === 'task' || t.type === 'bug') && t.status === 'in_progress'
            );
            
            // Remember current selection
            const currentValue = selector.value;
            
            // Clear and repopulate options - start with 'Auto' (default)
            selector.innerHTML = '<option value="auto">Auto</option>';
            
            // Add "Active Task" option
            const activeOption = document.createElement('option');
            activeOption.value = 'active-task';
            activeOption.textContent = 'Active Task';
            if (!hasActiveTask) {
                activeOption.disabled = true;
                activeOption.textContent = 'Active Task (none)';
            }
            if (currentValue === 'active-task' || state.graph.followTargetId === 'active-task') {
                activeOption.selected = true;
            }
            selector.appendChild(activeOption);
            
            // Add "Queue" option
            if (queueNode) {
                const queueOption = document.createElement('option');
                queueOption.value = 'queue';
                queueOption.textContent = 'Queue';
                if (currentValue === 'queue' || state.graph.followTargetId === 'queue') {
                    queueOption.selected = true;
                }
                selector.appendChild(queueOption);
            }
            
            // Add agents if any exist
            if (workerAgents.length > 0) {
                // Add separator
                const separator = document.createElement('option');
                separator.disabled = true;
                separator.textContent = 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
                selector.appendChild(separator);
                
                workerAgents.forEach(agent => {
                    const agentId = agent.id || `agent-${agent.pid}`;
                    const option = document.createElement('option');
                    option.value = agentId;
                    option.textContent = agent.name || `Agent ${agent.pid}`;
                    if (agentId === currentValue || agentId === state.graph.followTargetId) {
                        option.selected = true;
                    }
                    selector.appendChild(option);
                });
            }
            
            // If currently followed target is an agent that's gone, revert to 'auto'
            if (state.graph.followTargetId && 
                state.graph.followTargetId !== 'auto' &&
                state.graph.followTargetId !== 'active-task' && 
                state.graph.followTargetId !== 'queue') {
                const agentStillExists = workerAgents.some(a => 
                    (a.id || `agent-${a.pid}`) === state.graph.followTargetId
                );
                if (!agentStillExists) {
                    // Agent died - revert to auto mode
                    state.graph.followTargetId = 'auto';
                    state.graph.followingNodeId = null;
                    selector.value = 'auto';
                }
            }
            
            // Ensure auto is selected if that's the current target
            if (state.graph.followTargetId === 'auto' || currentValue === 'auto') {
                selector.value = 'auto';
            }
        }

        // Hide completed toggle
        document.getElementById('hide-completed-switch').addEventListener('click', () => {
            state.graph.hideCompleted = !state.graph.hideCompleted;
            updateHideCompletedDisplay();
            startAnimation();  // Restart animation to apply filter
        });

        function updateHideCompletedDisplay() {
            const switchEl = document.getElementById('hide-completed-switch');
            if (state.graph.hideCompleted) {
                switchEl.classList.add('active');
            } else {
                switchEl.classList.remove('active');
            }
        }

        // Chain length filter
        const chainLengthSlider = document.getElementById('chain-length-slider');
        const chainLengthValue = document.getElementById('chain-length-value');
        const chainLengthFilter = document.getElementById('chain-length-filter');

        // Load saved chain length filter from localStorage
        function loadChainLengthFilter() {
            const saved = localStorage.getItem('binnacle_chain_length_filter');
            if (saved) {
                const value = parseInt(saved, 10);
                if (!isNaN(value) && value >= 1 && value <= 5) {
                    return value;
                }
            }
            return 1;
        }

        // Save chain length filter to localStorage
        function saveChainLengthFilter(value) {
            localStorage.setItem('binnacle_chain_length_filter', value.toString());
        }

        // Initialize chain length filter from saved state
        state.graph.minChainLength = loadChainLengthFilter();
        chainLengthSlider.value = state.graph.minChainLength;
        chainLengthValue.textContent = state.graph.minChainLength >= 5 ? '5+' : state.graph.minChainLength;
        updateChainLengthDisplay();

        chainLengthSlider.addEventListener('input', () => {
            const value = parseInt(chainLengthSlider.value, 10);
            state.graph.minChainLength = value;
            chainLengthValue.textContent = value >= 5 ? '5+' : value;
            saveChainLengthFilter(value);
            updateChainLengthDisplay();
            startAnimation();  // Restart animation to apply filter
        });

        function updateChainLengthDisplay() {
            if (state.graph.minChainLength > 1) {
                chainLengthFilter.classList.add('active');
            } else {
                chainLengthFilter.classList.remove('active');
            }
        }

        function normalizeSearchQuery(query) {
            return (query || '').trim().toLowerCase();
        }

        function nodeMatchesSearch(node, normalizedQuery) {
            if (!normalizedQuery) return true;
            const haystack = `${node.id} ${(node.title || '')} ${(node.short_name || '')}`.toLowerCase();
            return haystack.includes(normalizedQuery);
        }

        function setGraphSearchQuery(query) {
            state.graph.searchQuery = query;
            // Note: We no longer need to clear selection/hover here since
            // non-matching nodes are now dimmed rather than hidden.
            // The visibleNodeIds check only applies to hideCompleted filtering.
            startAnimation();  // Restart animation to apply search filter
        }

        function initializeGraphSearch() {
            const input = document.getElementById('graph-search');
            if (!input) return;

            input.addEventListener('input', () => {
                setGraphSearchQuery(input.value);
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    input.value = '';
                    setGraphSearchQuery('');
                    e.preventDefault();
                }
            });
        }

        // Initialize view search bar for consolidated Nodes view
        function initializeViewSearch() {
            const input = document.getElementById('nodes-search');
            const toggle = document.getElementById('nodes-include-closed');
            const typeFilter = document.getElementById('nodes-type-filter');

            if (input) {
                input.addEventListener('input', () => {
                    viewSearch.nodes = input.value.toLowerCase();
                    renderNodes();
                });

                input.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        input.value = '';
                        viewSearch.nodes = '';
                        renderNodes();
                        e.preventDefault();
                    }
                });
            }

            if (toggle) {
                toggle.addEventListener('click', () => {
                    includeClosed.nodes = !includeClosed.nodes;
                    toggle.classList.toggle('active', includeClosed.nodes);
                    renderNodes();
                });
            }

            if (typeFilter) {
                typeFilter.addEventListener('change', () => {
                    nodesTypeFilter = typeFilter.value;
                    renderNodes();
                });
            }
            
            const tagFilter = document.getElementById('nodes-tag-filter');
            if (tagFilter) {
                tagFilter.addEventListener('change', () => {
                    nodesTagFilter = tagFilter.value;
                    renderNodes();
                });
            }
        }

        // Check if an item matches the view search query
        function itemMatchesViewSearch(item, query) {
            if (!query) return true;
            const haystack = [
                item.id || '',
                item.title || '',
                item.short_name || '',
                item.description || ''
            ].join(' ').toLowerCase();
            return haystack.includes(query);
        }
        
        // Sync type filter dropdown with JS variable (ensures DOM and state match)
        function syncTypeFilterDropdown() {
            const typeFilter = document.getElementById('nodes-type-filter');
            if (!typeFilter) return;
            
            // Sync dropdown DOM value with JS variable
            if (typeFilter.value !== nodesTypeFilter) {
                typeFilter.value = nodesTypeFilter;
            }
        }
        
        // Populate tag filter dropdown with unique tags from all nodes
        function updateTagFilterDropdown() {
            const tagFilter = document.getElementById('nodes-tag-filter');
            if (!tagFilter) return;
            
            // Collect all unique tags from all node types
            const tags = new Set();
            
            (state.tasks || []).forEach(t => {
                (t.tags || []).forEach(tag => tags.add(tag));
            });
            (state.ideas || []).forEach(idea => {
                (idea.tags || []).forEach(tag => tags.add(tag));
            });
            (state.tests || []).forEach(test => {
                (test.tags || []).forEach(tag => tags.add(tag));
            });
            (state.docs || []).forEach(doc => {
                (doc.tags || []).forEach(tag => tags.add(tag));
            });
            
            // Sort tags alphabetically
            const sortedTags = [...tags].sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
            
            // Preserve current selection
            const currentValue = tagFilter.value;
            
            // Rebuild options
            tagFilter.innerHTML = '<option value="">All</option>';
            sortedTags.forEach(tag => {
                const option = document.createElement('option');
                option.value = tag;
                option.textContent = tag;
                tagFilter.appendChild(option);
            });
            
            // Restore selection if still valid
            if (sortedTags.includes(currentValue)) {
                tagFilter.value = currentValue;
            } else {
                tagFilter.value = '';
                nodesTagFilter = '';
            }
        }

        // Find and pan to the first active agent or in_progress task, zooming to 100%
        // (Legacy function for initial page load - now uses snapToFollowTarget when available)
        function snapToActiveTask() {
            // If we have a selected target to follow, use that instead
            if (state.graph.followTargetId) {
                snapToFollowTarget();
                return;
            }
            
            if (!state.tasks) return;
            
            // Fallback: follow the active task (in_progress), not agent nodes
            const activeTask = state.tasks.find(t => t.status === 'in_progress' && t.type !== 'agent');
            if (activeTask) {
                state.graph.followingNodeId = activeTask.id;
                panToNode(activeTask.id, true);  // Zoom to 100%
            } else {
                state.graph.followingNodeId = null;
            }
        }

        // Snap camera to the currently followed target (active task, queue, auto, or agent)
        function snapToFollowTarget() {
            if (!state.graph.followTargetId || !state.tasks) return;
            
            let targetNode = null;
            
            if (state.graph.followTargetId === 'auto') {
                // Auto mode: follow the agent with the most recent activity
                targetNode = findMostRecentlyActiveAgent();
            } else if (state.graph.followTargetId === 'active-task') {
                // Find the first in_progress task or bug
                targetNode = state.tasks.find(t => 
                    (t.type === 'task' || t.type === 'bug') && t.status === 'in_progress'
                );
            } else if (state.graph.followTargetId === 'queue') {
                // Find the queue node
                targetNode = state.tasks.find(t => t.type === 'queue');
            } else {
                // Find the agent node by ID
                targetNode = state.tasks.find(t => t.id === state.graph.followTargetId && t.type === 'agent');
            }
            
            if (targetNode) {
                state.graph.followingNodeId = targetNode.id;
                panToNode(targetNode.id, true);  // Zoom to 100%
            } else {
                state.graph.followingNodeId = null;
            }
        }
        
        // Find the agent with the most recent activity (for auto-follow mode)
        function findMostRecentlyActiveAgent() {
            const workerAgents = (state.agents || []).filter(a => a.agent_type === 'worker');
            if (workerAgents.length === 0) return null;
            
            // Sort by last_activity_at descending, pick the most recent
            const sortedAgents = [...workerAgents].sort((a, b) => {
                const aTime = a.last_activity_at ? new Date(a.last_activity_at).getTime() : 0;
                const bTime = b.last_activity_at ? new Date(b.last_activity_at).getTime() : 0;
                return bTime - aTime;
            });
            
            const mostRecentAgent = sortedAgents[0];
            if (!mostRecentAgent) return null;
            
            const agentId = mostRecentAgent.id || `agent-${mostRecentAgent.pid}`;
            return state.tasks.find(t => t.id === agentId && t.type === 'agent');
        }

        function zoomCanvas(zoomDelta, centerX, centerY) {
            const canvas = document.getElementById('graph-canvas');
            if (!centerX || !centerY) {
                // Default to canvas center
                centerX = canvas.width / 2;
                centerY = canvas.height / 2;
            }

            // World point under cursor before zoom
            const worldBefore = screenToWorld(centerX, centerY, canvas);

            // Update zoom
            const oldZoom = state.graph.viewport.zoom;
            state.graph.viewport.zoom = Math.max(
                state.graph.viewport.minZoom,
                Math.min(state.graph.viewport.maxZoom, oldZoom * zoomDelta)
            );

            // World point under cursor after zoom
            const worldAfter = screenToWorld(centerX, centerY, canvas);

            // Adjust pan to keep point stationary
            state.graph.viewport.panX += worldBefore.x - worldAfter.x;
            state.graph.viewport.panY += worldBefore.y - worldAfter.y;

            // Update zoom level display
            updateZoomDisplay();
            
            // Restart animation to redraw with new zoom level
            startAnimation();
        }

        function updateZoomDisplay() {
            const zoomLevelEl = document.getElementById('zoom-level');
            if (zoomLevelEl) {
                const percent = Math.round(state.graph.viewport.zoom * 100);
                zoomLevelEl.textContent = `${percent}%`;
            }
        }

        // Ease-in-out-cubic easing function
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Calculate adaptive pan duration based on distance
        function getPanDuration(distance) {
            // Doubled durations for smoother animation
            if (distance < 300) return 600;
            if (distance <= 800) return 1000;
            return 1600;
        }

        // Pan camera smoothly to center on a world position
        function panToWorldPosition(targetX, targetY, targetZoom = null) {
            const canvas = document.getElementById('graph-canvas');
            const { viewport } = state.graph;

            // Target pan values to center the position on screen
            // worldToScreen: screenX = (worldX + panX) * zoom + canvas.width / 2
            // To center targetX, we need: canvas.width / 2 = (targetX + panX) * zoom + canvas.width / 2
            // => 0 = (targetX + panX) * zoom
            // => panX = -targetX
            const targetPanX = -targetX;
            const targetPanY = -targetY;

            // Calculate distance in screen pixels for duration
            const startPanX = viewport.panX;
            const startPanY = viewport.panY;
            const startZoom = viewport.zoom;
            const dx = (targetPanX - startPanX) * viewport.zoom;
            const dy = (targetPanY - startPanY) * viewport.zoom;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Calculate zoom change for duration consideration
            const zoomChange = targetZoom !== null ? Math.abs(targetZoom - startZoom) : 0;

            // Skip animation if already centered (within 1 pixel) and no zoom change
            if (distance < 1 && zoomChange < 0.01) return;

            // Use longer duration if there's significant zoom change
            const baseDuration = getPanDuration(distance);
            const duration = zoomChange > 0.1 ? Math.max(baseDuration, 800) : baseDuration;

            // Start the animation
            state.graph.followAnimation = {
                startPanX,
                startPanY,
                targetPanX,
                targetPanY,
                startZoom,
                targetZoom: targetZoom !== null ? targetZoom : startZoom,
                startTime: performance.now(),
                duration
            };
            
            // Restart animation loop to run the camera animation
            startAnimation();
        }

        // Pan camera smoothly to center on a node by ID, optionally zooming to 100%
        function panToNode(nodeId, zoomTo100 = false) {
            const node = state.graph.nodes.find(n => n.id === nodeId);
            if (node) {
                panToWorldPosition(node.x, node.y, zoomTo100 ? 1.0 : null);
            }
        }

        // Cancel any ongoing pan animation
        function cancelPanAnimation() {
            state.graph.followAnimation = null;
        }

        // Update pan animation (called from animateGraph)
        function updatePanAnimation() {
            const anim = state.graph.followAnimation;
            if (!anim) return;

            const now = performance.now();
            const elapsed = now - anim.startTime;
            const progress = Math.min(elapsed / anim.duration, 1);
            const easedProgress = easeInOutCubic(progress);

            // Interpolate pan values
            state.graph.viewport.panX = anim.startPanX + (anim.targetPanX - anim.startPanX) * easedProgress;
            state.graph.viewport.panY = anim.startPanY + (anim.targetPanY - anim.startPanY) * easedProgress;

            // Interpolate zoom if target differs from start
            if (anim.targetZoom !== anim.startZoom) {
                state.graph.viewport.zoom = anim.startZoom + (anim.targetZoom - anim.startZoom) * easedProgress;
                updateZoomDisplay();
            }

            // Animation complete
            if (progress >= 1) {
                state.graph.followAnimation = null;
            }
        }

        // Continuous follow: keep viewport centered on followed node as it moves
        function updateContinuousFollow(canvas) {
            // Skip if auto-follow is disabled or no node is being followed
            if (!state.graph.autoFollow || !state.graph.followingNodeId) return;
            
            // Skip if an animation is in progress (let it complete)
            if (state.graph.followAnimation) return;
            
            // Skip if user is panning or dragging
            if (state.graph.isPanning || state.graph.draggedNode) return;
            
            // Find the followed node
            const node = state.graph.nodes.find(n => n.id === state.graph.followingNodeId);
            if (!node) {
                // Node no longer exists, clear following
                state.graph.followingNodeId = null;
                return;
            }
            
            // Calculate target pan to center the node
            const targetPanX = -node.x;
            const targetPanY = -node.y;
            
            // Calculate distance to target
            const dx = targetPanX - state.graph.viewport.panX;
            const dy = targetPanY - state.graph.viewport.panY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Snap to exact center if very close (prevents perpetual drift)
            if (distance < 0.5) {
                state.graph.viewport.panX = targetPanX;
                state.graph.viewport.panY = targetPanY;
                return;
            }
            
            // Smoothly interpolate toward target (soft follow)
            // Use higher smoothing (0.15) for responsive tracking while still being smooth
            const smoothing = 0.15;
            state.graph.viewport.panX += dx * smoothing;
            state.graph.viewport.panY += dy * smoothing;
        }

        function updateTooltip(node, mouseX, mouseY) {
            const tooltip = document.getElementById('node-tooltip');
            const titleEl = document.getElementById('tooltip-title');
            const idEl = document.getElementById('tooltip-id');
            const metaEl = document.getElementById('tooltip-meta');

            if (!node) {
                tooltip.classList.remove('visible');
                return;
            }

            // Find full task data
            const task = state.tasks.find(t => t.id === node.id);
            if (!task) return;

            // Update tooltip content - show short_name if available, otherwise title
            titleEl.textContent = task.short_name || task.title;
            idEl.textContent = task.id;

            // Build metadata badges
            metaEl.innerHTML = `
                <span class="badge badge-priority-${task.priority}">P${task.priority}</span>
                <span class="badge badge-status-${task.status}">${task.status}</span>
                ${task.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
            `;

            // Position tooltip
            const offset = 15;
            tooltip.style.left = `${mouseX + offset}px`;
            tooltip.style.top = `${mouseY + offset}px`;

            // Adjust if tooltip goes off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (tooltipRect.right > viewportWidth) {
                tooltip.style.left = `${mouseX - tooltipRect.width - offset}px`;
            }
            if (tooltipRect.bottom > viewportHeight) {
                tooltip.style.top = `${mouseY - tooltipRect.height - offset}px`;
            }

            tooltip.classList.add('visible');
        }

        // Edge tooltip functions
        function getEdgeTypeName(edgeType) {
            const names = {
                'depends_on': 'Depends On',
                'blocks': 'Blocks',
                'related_to': 'Related To',
                'caused_by': 'Caused By',
                'duplicates': 'Duplicates',
                'supersedes': 'Supersedes',
                'pinned': 'Pinned',
                'fixes': 'Fixes',
                'tests': 'Tests',
                'parent_of': 'Parent Of',
                'child_of': 'Child Of',
                'queued': 'Queued',
                'working_on': 'Working On',
                'worked_on': 'Worked On'
            };
            return names[edgeType] || edgeType;
        }

        function distanceToEdge(px, py, edge) {
            // Get node positions
            const fromNode = state.graph.nodes.find(n => n.id === edge.from);
            const toNode = state.graph.nodes.find(n => n.id === edge.to);
            if (!fromNode || !toNode) return Infinity;

            // Calculate edge endpoints (at node boundaries, not centers)
            const dx = toNode.x - fromNode.x;
            const dy = toNode.y - fromNode.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < fromNode.radius + toNode.radius) return Infinity;

            const angle = Math.atan2(dy, dx);
            const x1 = fromNode.x + Math.cos(angle) * fromNode.radius;
            const y1 = fromNode.y + Math.sin(angle) * fromNode.radius;
            const x2 = toNode.x - Math.cos(angle) * toNode.radius;
            const y2 = toNode.y - Math.sin(angle) * toNode.radius;

            // Calculate distance from point to line segment
            const lineDx = x2 - x1;
            const lineDy = y2 - y1;
            const lineLen = Math.sqrt(lineDx * lineDx + lineDy * lineDy);
            if (lineLen === 0) return Infinity;

            // Project point onto line, clamped to segment
            const t = Math.max(0, Math.min(1, ((px - x1) * lineDx + (py - y1) * lineDy) / (lineLen * lineLen)));
            const projX = x1 + t * lineDx;
            const projY = y1 + t * lineDy;

            return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
        }

        function findHoveredEdge(worldX, worldY, threshold = 8) {
            // Adjust threshold for zoom level
            const adjustedThreshold = threshold / state.graph.viewport.zoom;
            
            let closestEdge = null;
            let closestDistance = adjustedThreshold;

            for (const edge of state.graph.edges) {
                // Skip edges that are filtered out
                if (!state.edgeFilters[edge.edge_type]) continue;

                // Skip edges where either endpoint is hidden
                if (state.graph.visibleNodeIds) {
                    if (!state.graph.visibleNodeIds.has(edge.from) || !state.graph.visibleNodeIds.has(edge.to)) {
                        continue;
                    }
                }
                
                const distance = distanceToEdge(worldX, worldY, edge);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestEdge = edge;
                }
            }

            return closestEdge;
        }

        function updateEdgeTooltip(edge, mouseX, mouseY) {
            const tooltip = document.getElementById('edge-tooltip');
            const typeEl = document.getElementById('edge-tooltip-type');
            const idsEl = document.getElementById('edge-tooltip-ids');
            const reasonEl = document.getElementById('edge-tooltip-reason');
            const dateEl = document.getElementById('edge-tooltip-date');

            if (!edge) {
                tooltip.classList.remove('visible');
                return;
            }

            // Get the full edge data from state.edges (API data with created_at)
            const fullEdge = state.edges.find(e => 
                e.source === edge.from && e.target === edge.to && e.edge_type === edge.edge_type
            );

            // Get edge style for color
            const style = getEdgeStyle(edge.edge_type);
            
            // Update tooltip content
            typeEl.innerHTML = `
                <span class="edge-color-dot" style="background-color: ${style.color}"></span>
                ${getEdgeTypeName(edge.edge_type)}${edge.bidirectional ? ' (bidirectional)' : ''}
            `;
            idsEl.textContent = `${edge.from} â†’ ${edge.to}`;

            // Show/hide reason
            if (edge.reason) {
                reasonEl.textContent = `"${edge.reason}"`;
                reasonEl.style.display = 'block';
            } else {
                reasonEl.style.display = 'none';
            }

            // Show created date if available
            if (fullEdge && fullEdge.created_at) {
                const date = new Date(fullEdge.created_at);
                dateEl.textContent = `Created: ${date.toLocaleDateString()}`;
                dateEl.style.display = 'block';
            } else {
                dateEl.style.display = 'none';
            }

            // Position tooltip
            const offset = 15;
            tooltip.style.left = `${mouseX + offset}px`;
            tooltip.style.top = `${mouseY + offset}px`;

            // Adjust if tooltip goes off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (tooltipRect.right > viewportWidth) {
                tooltip.style.left = `${mouseX - tooltipRect.width - offset}px`;
            }
            if (tooltipRect.bottom > viewportHeight) {
                tooltip.style.top = `${mouseY - tooltipRect.height - offset}px`;
            }

            tooltip.classList.add('visible');
        }

        function updateInfoPanel(node) {
            const panel = document.getElementById('info-panel');
            const idEl = document.getElementById('info-panel-id');
            const titleEl = document.getElementById('info-panel-task-title');
            const metaEl = document.getElementById('info-panel-meta');
            const descEl = document.getElementById('info-panel-description');
            const descSection = document.getElementById('info-panel-description-section');
            const depsSection = document.getElementById('info-panel-deps-section');
            const depsList = document.getElementById('info-panel-deps');
            const closedSection = document.getElementById('info-panel-closed-section');
            const closedReason = document.getElementById('info-panel-closed-reason');
            const typeTitleEl = document.getElementById('info-panel-type-title');
            const relationshipsSection = document.getElementById('info-panel-relationships-section');
            const relationshipsList = document.getElementById('info-panel-relationships');
            const timestampsSection = document.getElementById('info-panel-timestamps-section');
            const timestampsList = document.getElementById('info-panel-timestamps');

            if (!node) {
                panel.classList.remove('visible');
                return;
            }

            // Find full task data
            const task = state.tasks.find(t => t.id === node.id);
            if (!task) return;

            // Update header title based on node type
            const typeLabels = {
                'task': 'Task Details',
                'bug': 'Bug Details',
                'idea': 'Idea Details',
                'milestone': 'Milestone Details',
                'queue': 'Queue Details',
                'agent': 'Agent Details'
            };
            typeTitleEl.textContent = typeLabels[task.type] || 'Task Details';

            // Update panel content
            idEl.textContent = task.id;
            titleEl.textContent = task.title;

            // Show short_name if set (after title)
            const shortNameEl = document.getElementById('info-panel-short-name');
            const shortNameRow = document.getElementById('info-panel-short-name-row');
            if (task.short_name) {
                shortNameEl.textContent = task.short_name;
                shortNameRow.style.display = 'block';
            } else {
                shortNameRow.style.display = 'none';
            }

            // Build metadata badges
            metaEl.innerHTML = `
                <span class="badge badge-priority-${task.priority}">P${task.priority}</span>
                <span class="badge badge-status-${task.status}">${task.status}</span>
                ${task.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
            `;

            // Description
            if (task.description) {
                descEl.textContent = task.description;
                descEl.classList.remove('empty');
                descSection.style.display = 'block';
            } else {
                descEl.textContent = 'No description provided';
                descEl.classList.add('empty');
                descSection.style.display = 'block';
            }

            // Dependencies - now clickable
            if (task.depends_on && task.depends_on.length > 0) {
                depsList.innerHTML = task.depends_on.map(depId => {
                    const depTask = state.tasks.find(t => t.id === depId);
                    const depTitle = depTask ? ` â€” ${escapeHtml(depTask.title)}` : '';
                    return `<li><span class="info-panel-node-link" data-node-id="${escapeHtml(depId)}">${escapeHtml(depId)}</span>${depTitle}</li>`;
                }).join('');
                depsSection.style.display = 'block';
            } else {
                depsSection.style.display = 'none';
            }

            // Relationships - show all edges connected to this node (excluding depends_on which are shown above)
            const nodeEdges = (state.edges || []).filter(edge => 
                (edge.source === task.id || edge.target === task.id) && edge.edge_type !== 'depends_on'
            );
            if (nodeEdges.length > 0) {
                relationshipsList.innerHTML = nodeEdges.map(edge => {
                    const isOutbound = edge.source === task.id;
                    const relatedId = isOutbound ? edge.target : edge.source;
                    const relatedTask = state.tasks.find(t => t.id === relatedId);
                    const relatedTitle = relatedTask ? escapeHtml(relatedTask.title) : '';
                    const direction = isOutbound ? 'â†’' : 'â†';
                    const edgeTypeName = EDGE_TYPES[edge.edge_type]?.name || edge.edge_type;
                    return `<li>
                        <span class="info-panel-edge-type">${escapeHtml(edgeTypeName)}</span>
                        <span class="info-panel-edge-direction">${direction}</span>
                        <span class="info-panel-node-link" data-node-id="${escapeHtml(relatedId)}">${escapeHtml(relatedId)}</span>
                        ${relatedTitle ? `<span style="color: var(--text-secondary)">â€” ${relatedTitle}</span>` : ''}
                    </li>`;
                }).join('');
                relationshipsSection.style.display = 'block';
            } else {
                relationshipsSection.style.display = 'none';
            }

            // Closed reason
            if (task.status === 'done' && task.closed_reason) {
                closedReason.textContent = task.closed_reason;
                closedSection.style.display = 'block';
            } else {
                closedSection.style.display = 'none';
            }

            // Timestamps
            const formatTimestamp = (ts) => {
                if (!ts) return null;
                const date = new Date(ts);
                return date.toLocaleDateString(undefined, { 
                    year: 'numeric', month: 'short', day: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });
            };
            const created = formatTimestamp(task.created_at);
            const updated = formatTimestamp(task.updated_at);
            const closed = formatTimestamp(task.closed_at);
            
            if (created || updated || closed) {
                let html = '';
                if (created) html += `<dt>Created:</dt><dd>${escapeHtml(created)}</dd>`;
                if (updated && updated !== created) html += `<dt>Updated:</dt><dd>${escapeHtml(updated)}</dd>`;
                if (closed) html += `<dt>Closed:</dt><dd>${escapeHtml(closed)}</dd>`;
                timestampsList.innerHTML = html;
                timestampsSection.style.display = 'block';
            } else {
                timestampsSection.style.display = 'none';
            }

            // Queue toggle - only show for tasks/bugs that can be queued
            const queueSection = document.getElementById('info-panel-queue-section');
            const queueToggle = document.getElementById('queue-toggle-btn');
            const canBeQueued = task.type === 'task' || task.type === 'bug' || !task.type;
            const isCompleted = task.status === 'done' || task.status === 'cancelled' || task.status === 'discarded';
            
            if (canBeQueued && !isCompleted) {
                queueSection.style.display = 'flex';
                const isQueued = isNodeQueued(task.id);
                queueToggle.classList.toggle('active', isQueued);
                queueToggle.title = isQueued ? 'Remove from queue' : 'Add to queue';
            } else {
                queueSection.style.display = 'none';
            }

            // Show panel
            panel.classList.add('visible');
        }

        // Handle clicks on node links in info panel
        document.getElementById('info-panel').addEventListener('click', (e) => {
            const link = e.target.closest('.info-panel-node-link');
            if (link) {
                const nodeId = link.dataset.nodeId;
                if (nodeId) {
                    // Disable auto-follow when user explicitly navigates to a specific node
                    state.graph.autoFollow = false;
                    updateAutoFollowDisplay();
                    // Find and select the node
                    const targetNode = state.graph.nodes.find(n => n.id === nodeId);
                    if (targetNode) {
                        state.graph.selectedNode = targetNode;
                        updateInfoPanel(targetNode);
                        panToNode(nodeId);
                    }
                }
            }
        });

        // Info panel close button
        document.getElementById('info-panel-close').addEventListener('click', () => {
            state.graph.selectedNode = null;
            updateInfoPanel(null);
        });

        // Edge info panel functions
        function updateEdgeInfoPanel(edge) {
            const panel = document.getElementById('edge-info-panel');
            
            if (!edge) {
                panel.classList.remove('visible');
                return;
            }

            // Hide node info panel when showing edge info
            document.getElementById('info-panel').classList.remove('visible');
            state.graph.selectedNode = null;

            // Get full edge data from state.edges
            const fullEdge = state.edges.find(e => 
                e.source === edge.from && e.target === edge.to && e.edge_type === edge.edge_type
            );

            // Get edge style for color
            const style = getEdgeStyle(edge.edge_type);
            
            // Update type with color indicator
            document.getElementById('edge-info-color').style.backgroundColor = style.color;
            document.getElementById('edge-info-type-name').textContent = getEdgeTypeName(edge.edge_type);

            // Find source and target task info
            const sourceTask = state.tasks.find(t => t.id === edge.from);
            const targetTask = state.tasks.find(t => t.id === edge.to);

            // Update connection info
            document.getElementById('edge-info-source-id').textContent = edge.from;
            document.getElementById('edge-info-source-title').textContent = sourceTask?.title || 'Unknown';
            document.getElementById('edge-info-target-id').textContent = edge.to;
            document.getElementById('edge-info-target-title').textContent = targetTask?.title || 'Unknown';

            // Show/hide reason section
            const reasonSection = document.getElementById('edge-info-reason-section');
            const reasonEl = document.getElementById('edge-info-reason');
            if (edge.reason || fullEdge?.reason) {
                reasonEl.textContent = edge.reason || fullEdge.reason;
                reasonSection.style.display = 'block';
            } else {
                reasonSection.style.display = 'none';
            }

            // Show created date if available
            const dateEl = document.getElementById('edge-info-date');
            if (fullEdge && fullEdge.created_at) {
                const date = new Date(fullEdge.created_at);
                dateEl.textContent = `Created: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
                dateEl.style.display = 'block';
            } else {
                dateEl.style.display = 'none';
            }

            // Show panel
            panel.classList.add('visible');
            
            // Store selected edge
            state.graph.selectedEdge = edge;
        }

        // Edge info panel close button
        document.getElementById('edge-info-close').addEventListener('click', () => {
            state.graph.selectedEdge = null;
            updateEdgeInfoPanel(null);
        });

        // Queue toggle button click handler
        document.getElementById('queue-toggle-btn').addEventListener('click', async () => {
            const selectedNode = state.graph.selectedNode;
            if (!selectedNode) return;

            const queueToggle = document.getElementById('queue-toggle-btn');
            queueToggle.disabled = true;

            try {
                const response = await fetch('/api/queue/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ node_id: selectedNode.id })
                });

                const result = await response.json();
                
                if (result.success) {
                    const isQueued = result.queued;
                    queueToggle.classList.toggle('active', isQueued);
                    queueToggle.title = isQueued ? 'Remove from queue' : 'Add to queue';
                    showToast(result.message, 'success');
                    // Refresh data to update edges and visual state
                    await loadData();
                } else {
                    showToast(result.error || 'Failed to toggle queue', 'error');
                }
            } catch (err) {
                showToast('Failed to toggle queue: ' + err.message, 'error');
            } finally {
                queueToggle.disabled = false;
            }
        });

        // Coordinate transformation functions
        function screenToWorld(screenX, screenY, canvas) {
            const { panX, panY, zoom } = state.graph.viewport;
            return {
                x: (screenX - canvas.width / 2) / zoom - panX,
                y: (screenY - canvas.height / 2) / zoom - panY
            };
        }

        function worldToScreen(worldX, worldY, canvas) {
            const { panX, panY, zoom } = state.graph.viewport;
            return {
                x: (worldX + panX) * zoom + canvas.width / 2,
                y: (worldY + panY) * zoom + canvas.height / 2
            };
        }

        /**
         * Build a set of "active" node IDs - nodes that are not in a completed state.
         * Active nodes include: pending, in_progress, blocked, reopened statuses.
         * For ideas: seed, germinating are active; promoted, discarded are not.
         */
        function buildActiveNodeSet() {
            const activeStatuses = ['pending', 'in_progress', 'blocked', 'reopened'];
            const activeIdeaStatuses = ['seed', 'germinating'];

            const activeNodes = new Set();

            state.tasks.forEach(task => {
                let isActive = false;

                if (task.type === 'idea') {
                    isActive = activeIdeaStatuses.includes(task.status);
                } else {
                    isActive = activeStatuses.includes(task.status);
                }

                if (isActive) {
                    activeNodes.add(task.id);
                }
            });

            return activeNodes;
        }

        /**
         * Check if a node is in an "active chain" - meaning it's either:
         * 1. An active node itself, OR
         * 2. Connected (transitively through edges) to an active node
         *
         * This allows completed nodes to remain visible if they're part of
         * a dependency chain with work that's still in progress.
         */
        function isInActiveChain(nodeId, activeNodes, edges) {
            // If the node itself is active, it's in an active chain
            if (activeNodes.has(nodeId)) {
                return true;
            }

            // Build adjacency list for traversal (both directions)
            const adjacency = new Map();
            edges.forEach(edge => {
                if (!adjacency.has(edge.from)) {
                    adjacency.set(edge.from, []);
                }
                if (!adjacency.has(edge.to)) {
                    adjacency.set(edge.to, []);
                }
                // Add bidirectional edges for traversal
                adjacency.get(edge.from).push(edge.to);
                adjacency.get(edge.to).push(edge.from);
            });

            // BFS to check if we can reach any active node from this node
            const visited = new Set();
            const queue = [nodeId];
            visited.add(nodeId);

            while (queue.length > 0) {
                const current = queue.shift();

                // If we reached an active node, this node is in an active chain
                if (activeNodes.has(current)) {
                    return true;
                }

                // Explore neighbors
                const neighbors = adjacency.get(current) || [];
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push(neighbor);
                    }
                }
            }

            return false;
        }

        /**
         * Calculate the length of the chain that contains a node.
         * Chain length = total number of unique nodes reachable through edges from this node
         * (including the node itself).
         */
        function getChainLength(nodeId, adjacency) {
            const visited = new Set();
            const queue = [nodeId];
            visited.add(nodeId);

            while (queue.length > 0) {
                const current = queue.shift();
                const neighbors = adjacency.get(current) || [];
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push(neighbor);
                    }
                }
            }

            return visited.size;
        }

        /**
         * Build adjacency list for chain length calculations.
         * Uses ALL edges regardless of visibility filters to correctly calculate
         * actual dependency chain lengths.
         */
        function buildChainAdjacency(edges) {
            const adjacency = new Map();

            edges.forEach(edge => {
                if (!adjacency.has(edge.from)) {
                    adjacency.set(edge.from, []);
                }
                if (!adjacency.has(edge.to)) {
                    adjacency.set(edge.to, []);
                }
                // Add bidirectional edges for traversal
                adjacency.get(edge.from).push(edge.to);
                adjacency.get(edge.to).push(edge.from);
            });

            return adjacency;
        }

        /**
         * Time window (in ms) for showing recently completed nodes before they fade out completely.
         */
        const RECENTLY_COMPLETED_WINDOW_MS = 5 * 60 * 1000; // 5 minutes

        /**
         * Time window (in ms) for the recently completed pane in the header.
         * Configurable - default is 15 minutes.
         */
        const RECENTLY_COMPLETED_PANE_WINDOW_MS = 15 * 60 * 1000; // 15 minutes

        /**
         * Check if a node was completed recently (within RECENTLY_COMPLETED_WINDOW_MS).
         * Returns the age in ms if recently completed, or null if not.
         */
        function getCompletedAge(node) {
            if (!node.closed_at) return null;
            const closedTime = new Date(node.closed_at).getTime();
            const now = Date.now();
            const age = now - closedTime;
            return age < RECENTLY_COMPLETED_WINDOW_MS ? age : null;
        }

        /**
         * Calculate opacity for a recently completed node based on age.
         * Returns 1.0 for just-completed nodes, fading to 0.3 at the 5-minute mark.
         */
        function getRecentlyCompletedOpacity(node) {
            const age = getCompletedAge(node);
            if (age === null) return 1.0;  // Not recently completed
            // Linear fade from 1.0 (age=0) to 0.3 (age=5min)
            const progress = age / RECENTLY_COMPLETED_WINDOW_MS;
            return 1.0 - (0.7 * progress);
        }

        /**
         * Filter nodes based on hideCompleted setting.
         * Returns array of nodes that should be visible.
         *
         * When hideCompleted is true:
         * - Hide nodes with status 'done' or 'cancelled'
         * - EXCEPT those in active dependency chains
         * - EXCEPT those completed within the last 5 minutes (shown with fade-out)
         */
        function getVisibleNodes(nodes) {
            // First, filter by node type visibility
            let visible = nodes.filter(node => {
                const nodeType = node.type || 'task';
                return state.nodeTypeFilters[nodeType] !== false;
            });

            if (state.graph.hideCompleted) {
                // Build active node set and prepare edges for chain detection
                const activeNodes = buildActiveNodeSet();
                const edges = state.graph.edges;

                // Filter nodes: keep if not completed, or if in active chain, or if recently completed
                visible = visible.filter(node => {
                    const isCompleted = node.status === 'done' || node.status === 'cancelled';

                    // If not completed, always show it
                    if (!isCompleted) {
                        return true;
                    }

                    // If recently completed (within 5 min), show it with fade effect
                    if (getCompletedAge(node) !== null) {
                        return true;
                    }

                    // If completed, only show if it's in an active chain
                    return isInActiveChain(node.id, activeNodes, edges);
                });
            }

            // Apply chain length filter if enabled (minChainLength > 1)
            if (state.graph.minChainLength > 1) {
                const adjacency = buildChainAdjacency(state.graph.edges);

                // Only keep nodes whose chain length meets the minimum
                visible = visible.filter(node => {
                    const chainLen = getChainLength(node.id, adjacency);
                    return chainLen >= state.graph.minChainLength;
                });
            }

            // Note: Search no longer hides nodes - non-matching nodes are dimmed instead
            // See drawNode() for dimming logic
            return visible;
        }

        function buildGraphData() {
            // Build a map of existing node positions to preserve them on reload
            const existingNodes = new Map();
            state.graph.nodes.forEach(node => {
                existingNodes.set(node.id, { x: node.x, y: node.y });
            });

            // Convert tasks to nodes - preserve positions or place in circular layout
            state.graph.nodes = state.tasks.map((task, index) => {
                const existing = existingNodes.get(task.id);

                if (existing) {
                    // Preserve existing position, but reset velocity to prevent oscillation
                    return {
                        id: task.id,
                        title: task.title,
                        short_name: task.short_name,
                        status: task.status,
                        priority: task.priority,
                        type: task.type || 'task',
                        closed_at: task.closed_at,  // Track when node was completed for fade-out
                        x: existing.x,
                        y: existing.y,
                        vx: 0,
                        vy: 0,
                        radius: 30
                    };
                } else {
                    // New node - place in circular layout in world space
                    const totalNodes = state.tasks.length;
                    const angle = (index / totalNodes) * 2 * Math.PI;
                    const radius = 300; // Initial radius in world units

                    return {
                        id: task.id,
                        title: task.title,
                        short_name: task.short_name,
                        status: task.status,
                        priority: task.priority,
                        type: task.type || 'task',
                        closed_at: task.closed_at,  // Track when node was completed for fade-out
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius,
                        vx: 0,
                        vy: 0,
                        radius: 30  // Node radius in world units
                    };
                }
            });

            // Build edges from API data with edge type metadata
            state.graph.edges = (state.edges || []).map(edge => ({
                from: edge.source,
                to: edge.target,
                edge_type: edge.edge_type,
                bidirectional: edge.bidirectional,
                reason: edge.reason
            }));
        }

        // Start or restart the animation loop (safe to call multiple times)
        function startAnimation() {
            // Reset stability counter when animation is explicitly started
            state.graph.stableFrameCount = 0;
            
            // Only start if not already animating
            if (!state.graph.isAnimating && state.currentView === 'graph') {
                state.graph.isAnimating = true;
                requestAnimationFrame(animateGraph);
            }
        }

        function animateGraph() {
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');
            const { nodes, edges, physics } = state.graph;

            // Update canvas size if window was resized
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }

            // Update animation time for continuous effects
            state.graph.animationTime = performance.now();

            // Update camera pan animation if active
            updatePanAnimation();

            // Clear canvas
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Filter nodes based on hideCompleted + search setting
            const visibleNodes = getVisibleNodes(nodes);
            const visibleNodeIds = new Set(visibleNodes.map(n => n.id));
            state.graph.visibleNodes = visibleNodes;
            state.graph.visibleNodeIds = visibleNodeIds;

            if (visibleNodes.length === 0) {
                renderEmptyState(ctx, 'No matching nodes');
                // Stop animation when no visible nodes
                state.graph.isAnimating = false;
                return;
            }

            // Apply forces (circular gravity system) - only to visible nodes
            applyCircularGravity(visibleNodes, physics);
            applyRepulsionForces(visibleNodes, physics);
            applyEdgeAttraction(visibleNodes, edges, physics);
            updatePositions(visibleNodes, edges, physics, canvas);

            // Continuous follow: track the followed node as it moves
            updateContinuousFollow(canvas);

            // Draw edges (filtered by edge type visibility and node visibility)
            edges.forEach(edge => {
                // Skip edges that are filtered out by type
                if (!state.edgeFilters[edge.edge_type]) return;

                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);

                // Skip edges where either endpoint is hidden
                if (!fromNode || !toNode || !visibleNodeIds.has(edge.from) || !visibleNodeIds.has(edge.to)) {
                    return;
                }

                const style = getEdgeStyle(edge.edge_type);
                drawArrow(ctx, fromNode.x, fromNode.y, toNode.x, toNode.y, canvas, fromNode.radius, toNode.radius, style, edge.bidirectional);
            });

            // Draw visible nodes only
            visibleNodes.forEach(node => {
                drawNode(ctx, node, canvas);
            });

            // Check for stability (all nodes have very low velocity)
            // Don't stabilize if dragging, panning, or pan animation is active
            const hasActiveInteraction = state.graph.draggedNode || 
                                          state.graph.isPanning || 
                                          state.graph.followAnimation;
            
            if (!hasActiveInteraction) {
                const isStable = visibleNodes.every(node => {
                    const speed = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
                    return speed < state.graph.STABLE_THRESHOLD;
                });
                
                if (isStable) {
                    state.graph.stableFrameCount++;
                    if (state.graph.stableFrameCount >= state.graph.STABLE_FRAMES_REQUIRED) {
                        // Graph is stable - stop animation to save CPU/GPU
                        state.graph.isAnimating = false;
                        return;
                    }
                } else {
                    state.graph.stableFrameCount = 0;
                }
            } else {
                // Reset stability counter during interactions
                state.graph.stableFrameCount = 0;
            }

            // Continue animation if still on graph view
            if (state.currentView === 'graph') {
                requestAnimationFrame(animateGraph);
            } else {
                state.graph.isAnimating = false;
            }
        }

        function applyCircularGravity(nodes, physics) {
            const draggedNode = state.graph.draggedNode;
            const { gravityCenter, gravityStrength } = physics;

            nodes.forEach(node => {
                // Don't apply forces to dragged nodes
                if (node === draggedNode) return;

                const dx = gravityCenter.x - node.x;
                const dy = gravityCenter.y - node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    // Queue nodes are HEAVY - they barely respond to gravity
                    // This makes other nodes move toward them via edge attraction
                    const gravityMultiplier = node.type === 'queue' ? 0.1 : 1.0;
                    const force = gravityStrength * gravityMultiplier;
                    node.vx += (dx / distance) * force;
                    node.vy += (dy / distance) * force;
                }
            });
        }

        function applyEdgeAttraction(nodes, edges, physics) {
            if (!physics.edgeAttractionEnabled) return;

            const draggedNode = state.graph.draggedNode;
            const { springStrength, springRestingLength } = physics;

            edges.forEach(edge => {
                // Skip edges with springiness disabled
                const edgeType = edge.edge_type;
                if (edgeType && !state.edgeSpringFilters[edgeType]) return;

                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                if (!fromNode || !toNode) return;

                // Don't apply to dragged nodes
                if (fromNode === draggedNode && toNode === draggedNode) return;

                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance === 0) return;

                // Bidirectional spring force: applies when compressed OR extended
                // Force increases linearly with deviation from resting length
                const deviation = distance - springRestingLength;
                const force = springStrength * deviation;

                // Spring pulls toward resting length:
                // - If compressed (distance < resting): deviation is negative, pushes apart
                // - If extended (distance > resting): deviation is positive, pulls together
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;

                if (fromNode !== draggedNode) {
                    fromNode.vx += fx;
                    fromNode.vy += fy;
                }
                if (toNode !== draggedNode) {
                    toNode.vx -= fx;
                    toNode.vy -= fy;
                }
            });
        }

        function applyRepulsionForces(nodes, physics) {
            const draggedNode = state.graph.draggedNode;

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const n1 = nodes[i];
                    const n2 = nodes[j];
                    const dx = n2.x - n1.x;
                    const dy = n2.y - n1.y;
                    const distanceSq = dx * dx + dy * dy;
                    if (distanceSq === 0) continue;

                    const force = physics.repulsionStrength / distanceSq;
                    const distance = Math.sqrt(distanceSq);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;

                    // Don't apply forces to dragged nodes
                    if (n1 !== draggedNode) {
                        n1.vx -= fx;
                        n1.vy -= fy;
                    }
                    if (n2 !== draggedNode) {
                        n2.vx += fx;
                        n2.vy += fy;
                    }
                }
            }
        }

        function updatePositions(nodes, edges, physics, canvas) {
            const draggedNode = state.graph.draggedNode;
            const { damping, maxVelocity } = physics;

            // Build set of nodes directly connected to dragged node for higher responsiveness
            const connectedToDragged = new Set();
            if (draggedNode) {
                edges.forEach(edge => {
                    if (edge.from === draggedNode.id) {
                        connectedToDragged.add(edge.to);
                    } else if (edge.to === draggedNode.id) {
                        connectedToDragged.add(edge.from);
                    }
                });
            }

            // Connected nodes get higher max velocity for responsiveness
            const connectedMaxVelocity = maxVelocity * 3;

            nodes.forEach(node => {
                // Freeze dragged node
                if (node === draggedNode) {
                    node.vx = 0;
                    node.vy = 0;
                    return;
                }

                // Apply damping
                node.vx *= damping;
                node.vy *= damping;

                // Cap velocity - higher limit for nodes connected to dragged node
                // Queue nodes have very low max velocity (they're heavy anchors)
                const isConnected = connectedToDragged.has(node.id);
                let velocityLimit = isConnected ? connectedMaxVelocity : maxVelocity;
                if (node.type === 'queue') {
                    velocityLimit = maxVelocity * 0.3; // Queue nodes move very slowly
                }
                const speed = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
                if (speed > velocityLimit) {
                    node.vx = (node.vx / speed) * velocityLimit;
                    node.vy = (node.vy / speed) * velocityLimit;
                }

                // Update position (NO BOUNDARY CLAMPING for infinite canvas)
                node.x += node.vx;
                node.y += node.vy;
            });
        }

        // Format node label with word wrap and truncation
        // Returns array of lines (max 2 lines, max 8 chars per line)
        // NOTE: Uses string length (UTF-16 code units), not grapheme clusters.
        // Emoji/complex Unicode may appear shorter visually than their length suggests.
        function formatNodeLabel(text, maxCharsPerLine = 8, maxLines = 2) {
            if (!text) return [];

            const maxTotal = maxCharsPerLine * maxLines;

            // If text fits on one line, return early
            if (text.length <= maxCharsPerLine) {
                return [text];
            }

            // Truncate if too long overall (with ellipsis)
            if (text.length > maxTotal) {
                text = text.substring(0, maxTotal - 1) + 'â€¦';
            }

            const lines = [];
            let remaining = text;

            while (remaining.length > 0 && lines.length < maxLines) {
                if (remaining.length <= maxCharsPerLine) {
                    lines.push(remaining);
                    break;
                }

                // Try to break at a reasonable point (space, hyphen, underscore)
                let breakPoint = maxCharsPerLine;
                for (let i = maxCharsPerLine - 1; i >= Math.floor(maxCharsPerLine / 2); i--) {
                    if (remaining[i] === ' ' || remaining[i] === '-' || remaining[i] === '_') {
                        breakPoint = i + 1;
                        break;
                    }
                }

                lines.push(remaining.substring(0, breakPoint).trim());
                remaining = remaining.substring(breakPoint).trim();
            }

            return lines;
        }

        // Draw a hexagon path centered at (cx, cy) with the given radius
        function drawHexagonPath(ctx, cx, cy, radius) {
            const sides = 6;
            const angleOffset = Math.PI / 6; // Rotate 30 degrees so flat side is at bottom
            ctx.moveTo(
                cx + radius * Math.cos(angleOffset),
                cy + radius * Math.sin(angleOffset)
            );
            for (let i = 1; i <= sides; i++) {
                const angle = angleOffset + (i * 2 * Math.PI / sides);
                ctx.lineTo(
                    cx + radius * Math.cos(angle),
                    cy + radius * Math.sin(angle)
                );
            }
            ctx.closePath();
        }

        // Draw a diamond (rhombus) path centered at (cx, cy) with the given radius
        function drawDiamondPath(ctx, cx, cy, radius) {
            ctx.moveTo(cx, cy - radius);       // Top
            ctx.lineTo(cx + radius, cy);       // Right
            ctx.lineTo(cx, cy + radius);       // Bottom
            ctx.lineTo(cx - radius, cy);       // Left
            ctx.closePath();
        }

        // Draw a square path centered at (cx, cy) with the given radius (half-side length)
        function drawSquarePath(ctx, cx, cy, radius) {
            ctx.moveTo(cx - radius, cy - radius);  // Top-left
            ctx.lineTo(cx + radius, cy - radius);  // Top-right
            ctx.lineTo(cx + radius, cy + radius);  // Bottom-right
            ctx.lineTo(cx - radius, cy + radius);  // Bottom-left
            ctx.closePath();
        }

        // Draw a cloud/bubble path centered at (cx, cy) with the given radius
        // Uses overlapping circles to create a puffy cloud shape
        function drawCloudPath(ctx, cx, cy, radius) {
            // Classic cloud shape: a main body with overlapping circular bumps
            // Draw using bezier curves for smooth transitions between bumps
            const w = radius * 1.1;  // Width scale
            const h = radius * 0.75;  // Height scale (slightly flattened)
            
            ctx.moveTo(cx - w, cy + h * 0.3);
            
            // Bottom edge (flat-ish base)
            ctx.quadraticCurveTo(cx - w * 0.5, cy + h * 0.5, cx, cy + h * 0.4);
            ctx.quadraticCurveTo(cx + w * 0.5, cy + h * 0.5, cx + w, cy + h * 0.3);
            
            // Right bump
            ctx.quadraticCurveTo(cx + w * 1.2, cy, cx + w * 0.9, cy - h * 0.3);
            
            // Top-right bump  
            ctx.quadraticCurveTo(cx + w * 0.8, cy - h * 0.8, cx + w * 0.3, cy - h * 0.7);
            
            // Top middle bump (main puffy top)
            ctx.quadraticCurveTo(cx + w * 0.1, cy - h * 1.0, cx - w * 0.2, cy - h * 0.75);
            
            // Top-left bump
            ctx.quadraticCurveTo(cx - w * 0.6, cy - h * 0.9, cx - w * 0.8, cy - h * 0.4);
            
            // Left bump (back to start)
            ctx.quadraticCurveTo(cx - w * 1.2, cy, cx - w, cy + h * 0.3);
            
            ctx.closePath();
        }

        // Draw a rounded rectangle path (document/page shape) centered at (cx, cy)
        // Slightly taller than wide to look like a document page
        function drawDocPath(ctx, cx, cy, radius) {
            const w = radius * 0.85;   // Width (narrower than height)
            const h = radius * 1.1;    // Height (taller, page-like)
            const corner = radius * 0.2;  // Corner radius
            const fold = radius * 0.25;   // Corner fold size
            
            // Start at top-left (after corner radius)
            ctx.moveTo(cx - w + corner, cy - h);
            
            // Top edge (until fold corner)
            ctx.lineTo(cx + w - fold, cy - h);
            
            // Folded corner (dog-ear effect)
            ctx.lineTo(cx + w, cy - h + fold);
            
            // Right edge
            ctx.lineTo(cx + w, cy + h - corner);
            
            // Bottom-right corner (rounded)
            ctx.quadraticCurveTo(cx + w, cy + h, cx + w - corner, cy + h);
            
            // Bottom edge
            ctx.lineTo(cx - w + corner, cy + h);
            
            // Bottom-left corner (rounded)
            ctx.quadraticCurveTo(cx - w, cy + h, cx - w, cy + h - corner);
            
            // Left edge
            ctx.lineTo(cx - w, cy - h + corner);
            
            // Top-left corner (rounded)
            ctx.quadraticCurveTo(cx - w, cy - h, cx - w + corner, cy - h);
            
            ctx.closePath();
        }

        // Check if a node is in the queue (has a 'queued' edge to a queue node)
        function isNodeQueued(nodeId) {
            // Check state.edges (API data) directly, not state.graph.edges
            // state.graph.edges is only populated when the graph view is rendered
            return (state.edges || []).some(edge => 
                edge.source === nodeId && edge.edge_type === 'queued'
            );
        }

        // Get the reason(s) why a node is blocked
        // Returns an array of reasons from depends_on edges pointing to unclosed tasks
        function getBlockingReasons(nodeId) {
            const reasons = [];
            const edges = (state.edges || []).filter(edge => 
                edge.source === nodeId && 
                (edge.edge_type === 'depends_on' || edge.edge_type === 'blocks')
            );
            
            for (const edge of edges) {
                // Find the target task to check if it's still open (blocking)
                const targetTask = state.tasks.find(t => t.id === edge.target);
                if (targetTask && targetTask.status !== 'done' && targetTask.status !== 'cancelled') {
                    if (edge.reason) {
                        reasons.push(edge.reason);
                    } else {
                        // If no explicit reason, show what it's blocked by
                        const targetTitle = targetTask.short_name || targetTask.title;
                        reasons.push(`Waiting on: ${targetTitle}`);
                    }
                }
            }
            return reasons;
        }

        function drawNode(ctx, node, canvas) {
            const isHovered = node === state.graph.hoveredNode;
            const isDragging = node === state.graph.draggedNode;
            const isSelected = node === state.graph.selectedNode;
            
            // Check if node matches current highlight filter
            const matchesFilter = nodeMatchesFilter(node);
            const highlightDimmed = state.graph.highlightFilter && !matchesFilter;
            
            // Check if node matches current search query (dim non-matching instead of hiding)
            const normalizedQuery = normalizeSearchQuery(state.graph.searchQuery);
            const matchesSearch = nodeMatchesSearch(node, normalizedQuery);
            const searchDimmed = normalizedQuery && !matchesSearch;
            
            // Node is dimmed if either filter or search doesn't match
            const isDimmed = highlightDimmed || searchDimmed;

            // Transform world coordinates to screen coordinates
            const screenPos = worldToScreen(node.x, node.y, canvas);
            const zoom = state.graph.viewport.zoom;
            const radius = node.radius * zoom;

            // Node colors based on status
            const colors = {
                'pending': '#5bc0de',
                'in_progress': '#f0ad4e',
                'blocked': '#d9534f',
                'done': '#5cb85c'
            };
            
            // Bug colors (reddish tones) - use CSS variables
            const bugColors = {
                'pending': '#e07878',      // --bug-pending
                'in_progress': '#d95050',  // --bug-in-progress
                'blocked': '#b33a3a',      // --bug-blocked
                'done': '#8fbc8f'          // --bug-done
            };
            
            // Idea colors (deeper purple) - use CSS variables
            const ideaColors = {
                'pending': '#8b5fc9',      // --idea-pending
                'in_progress': '#7a4db8',  // --idea-in-progress
                'blocked': '#5c3a8a',      // --idea-blocked
                'done': '#8fbc8f'          // --idea-done
            };
            
            // Queue color (teal) - queues don't have status, always same color
            const queueColor = '#20b2aa';  // --queue-color
            
            // Agent colors (cyan/electric blue) - based on agent status
            const agentColors = {
                'active': '#00d4ff',       // Bright cyan for active
                'idle': '#6bb3c9',         // Muted cyan for idle
                'stale': '#4a6670'         // Dark gray-blue for stale
            };
            
            // Doc colors (by doc_type) - use CSS variables
            const docColors = {
                'prd': '#4a90e2',           // --doc-prd (blue)
                'note': '#e8b84a',          // --doc-note (gold)
                'handoff': '#e87d4a'        // --doc-handoff (orange)
            };
            
            // Select color palette based on node type
            let colorPalette = colors;
            let color;
            if (node.type === 'queue') {
                color = queueColor;
            } else if (node.type === 'bug') {
                colorPalette = bugColors;
                color = colorPalette[node.status] || '#4a90e2';
            } else if (node.type === 'idea') {
                colorPalette = ideaColors;
                color = colorPalette[node.status] || '#4a90e2';
            } else if (node.type === 'agent') {
                colorPalette = agentColors;
                color = colorPalette[node.status] || '#00d4ff';
            } else if (node.type === 'doc') {
                color = docColors[node.doc_type] || '#4a90e2';
            } else {
                color = colorPalette[node.status] || '#4a90e2';
            }
            
            // Apply dimming for filtered-out nodes, and fade-out for recently completed nodes
            let opacity = 1.0;
            if (isDimmed) {
                opacity = 0.3;
            } else {
                // Apply fade-out effect for recently completed nodes (when hideCompleted is on)
                const isCompleted = node.status === 'done' || node.status === 'cancelled';
                if (state.graph.hideCompleted && isCompleted) {
                    opacity = getRecentlyCompletedOpacity(node);
                }
            }
            ctx.globalAlpha = opacity;

            // Draw selection highlight (persistent)
            if (isSelected) {
                ctx.beginPath();
                if (node.type === 'queue') {
                    drawHexagonPath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else if (node.type === 'agent') {
                    drawDiamondPath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else if (node.type === 'doc') {
                    drawDocPath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 10 * zoom, 0, Math.PI * 2);
                }
                ctx.strokeStyle = '#f0ad4e';
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.fillStyle = 'rgba(240, 173, 78, 0.15)';
                ctx.fill();
            }

            // Draw drag highlight (active)
            if (isDragging) {
                ctx.beginPath();
                if (node.type === 'queue') {
                    drawHexagonPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'agent') {
                    drawDiamondPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'doc') {
                    drawDocPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 8 * zoom, 0, Math.PI * 2);
                }
                ctx.fillStyle = 'rgba(74, 144, 226, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            // Draw hover highlight
            else if (isHovered) {
                ctx.beginPath();
                if (node.type === 'queue') {
                    drawHexagonPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'agent') {
                    drawDiamondPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'doc') {
                    drawDocPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 8 * zoom, 0, Math.PI * 2);
                }
                ctx.fillStyle = 'rgba(74, 144, 226, 0.2)';
                ctx.fill();
                ctx.strokeStyle = '#6aa8f0';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // Draw queued indicator (teal glow for tasks in the queue)
            const isQueued = node.type !== 'queue' && node.type !== 'agent' && node.type !== 'doc' && isNodeQueued(node.id);
            if (isQueued) {
                ctx.beginPath();
                if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 6 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 6 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 6 * zoom, 0, Math.PI * 2);
                }
                ctx.strokeStyle = '#20b2aa';  // --queue-color
                ctx.lineWidth = 3;
                ctx.stroke();
                // Add subtle glow effect
                ctx.beginPath();
                if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 4 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 4 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 4 * zoom, 0, Math.PI * 2);
                }
                ctx.fillStyle = 'rgba(32, 178, 170, 0.15)';  // --queue-color with transparency
                ctx.fill();
            }

            // Draw dotted yellow border for task nodes (visual distinction from bugs/ideas)
            // Only for task type nodes that are not in_progress (in_progress has animated rings)
            if (node.type === 'task' && node.status !== 'in_progress') {
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, radius + 4 * zoom, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.7)';  // Gold/yellow color
                ctx.lineWidth = 2 * zoom;
                ctx.setLineDash([4 * zoom, 4 * zoom]);  // Dotted pattern
                ctx.stroke();
                ctx.setLineDash([]);  // Reset line dash
            }

            // Draw active task indicator: counter-rotating hatched rings (Ghost in the Shell style)
            // Only for in_progress tasks/bugs/ideas (not queues/agents/docs)
            if (node.status === 'in_progress' && node.type !== 'queue' && node.type !== 'agent' && node.type !== 'doc') {
                const animTime = state.graph.animationTime;
                const rotationSpeed = 0.001; // radians per ms
                const outerRingRadius = radius + 14 * zoom;
                const innerRingRadius = radius + 8 * zoom;
                const ringWidth = 2.5 * zoom;
                const hatchCount = 12;
                const hatchLength = Math.PI / 18; // Arc length of each hatch
                
                // Outer ring - rotates clockwise
                ctx.save();
                ctx.translate(screenPos.x, screenPos.y);
                ctx.rotate(animTime * rotationSpeed);
                ctx.strokeStyle = 'rgba(240, 173, 78, 0.8)'; // Orange-amber like in_progress color
                ctx.lineWidth = ringWidth;
                ctx.lineCap = 'round';
                for (let i = 0; i < hatchCount; i++) {
                    const startAngle = (i * Math.PI * 2) / hatchCount;
                    ctx.beginPath();
                    ctx.arc(0, 0, outerRingRadius, startAngle, startAngle + hatchLength);
                    ctx.stroke();
                }
                ctx.restore();
                
                // Inner ring - rotates counter-clockwise
                ctx.save();
                ctx.translate(screenPos.x, screenPos.y);
                ctx.rotate(-animTime * rotationSpeed * 1.5); // Faster and opposite direction
                ctx.strokeStyle = 'rgba(255, 200, 100, 0.6)'; // Lighter orange-gold
                ctx.lineWidth = ringWidth * 0.8;
                ctx.lineCap = 'round';
                for (let i = 0; i < hatchCount; i++) {
                    const startAngle = (i * Math.PI * 2) / hatchCount + Math.PI / hatchCount; // Offset from outer ring
                    ctx.beginPath();
                    ctx.arc(0, 0, innerRingRadius, startAngle, startAngle + hatchLength * 0.8);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // Draw node shape (hexagon for queue, diamond for agent, square for bug, cloud for idea, doc for doc, circle for others)
            ctx.beginPath();
            if (node.type === 'queue') {
                drawHexagonPath(ctx, screenPos.x, screenPos.y, radius);
            } else if (node.type === 'agent') {
                drawDiamondPath(ctx, screenPos.x, screenPos.y, radius);
            } else if (node.type === 'bug') {
                drawSquarePath(ctx, screenPos.x, screenPos.y, radius);
            } else if (node.type === 'idea') {
                drawCloudPath(ctx, screenPos.x, screenPos.y, radius);
            } else if (node.type === 'doc') {
                drawDocPath(ctx, screenPos.x, screenPos.y, radius);
            } else {
                ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
            }
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = (isHovered || isDragging) ? '#ffffff' : '#e8edf3';
            ctx.lineWidth = (isHovered || isDragging) ? 3 : 2;
            ctx.stroke();

            // Draw text - show short_name if set, with task ID below in smaller font
            ctx.fillStyle = '#1a2332';
            const baseFontSize = 12 * Math.max(0.8, Math.min(1.5, zoom));
            const smallFontSize = baseFontSize * 0.75;
            ctx.textAlign = 'center';

            if (node.short_name) {
                // Format short_name with word wrap
                const labelLines = formatNodeLabel(node.short_name, 8, 2);
                const lineHeight = baseFontSize * 1.2;
                
                // Calculate total height for centering
                const totalLines = labelLines.length + 1; // +1 for ID below
                const totalHeight = (totalLines - 1) * lineHeight;
                const startY = screenPos.y - totalHeight / 2 + baseFontSize / 2;
                
                // Draw short_name lines
                ctx.font = (isHovered || isDragging) ? `bold ${baseFontSize}px sans-serif` : `${baseFontSize}px sans-serif`;
                ctx.textBaseline = 'middle';
                labelLines.forEach((line, i) => {
                    ctx.fillText(line, screenPos.x, startY + i * lineHeight);
                });
                
                // Draw task ID below in smaller font
                ctx.font = `${smallFontSize}px sans-serif`;
                ctx.fillStyle = 'rgba(26, 35, 50, 0.7)';
                ctx.fillText(node.id, screenPos.x, startY + labelLines.length * lineHeight);
            } else {
                // No short_name - just show task ID centered
                ctx.font = (isHovered || isDragging) ? `bold ${baseFontSize}px sans-serif` : `${baseFontSize}px sans-serif`;
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id, screenPos.x, screenPos.y);
            }
            
            // Reset globalAlpha after drawing
            ctx.globalAlpha = 1.0;
        }

        // Get edge style based on edge type
        function getEdgeStyle(edgeType) {
            const styles = getComputedStyle(document.documentElement);
            switch (edgeType) {
                case 'depends_on':
                case 'blocks':
                    return {
                        color: styles.getPropertyValue('--edge-blocking').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
                case 'related_to':
                case 'caused_by':
                case 'duplicates':
                case 'supersedes':
                    return {
                        color: styles.getPropertyValue('--edge-informational').trim(),
                        dashed: true,
                        lineWidth: 1.5
                    };
                case 'fixes':
                case 'tests':
                    return {
                        color: styles.getPropertyValue('--edge-fixes').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
                case 'parent_of':
                case 'child_of':
                    return {
                        color: styles.getPropertyValue('--edge-hierarchy').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
                case 'queued':
                    return {
                        color: styles.getPropertyValue('--edge-queued').trim(),
                        dashed: true,
                        lineWidth: 2
                    };
                case 'working_on':
                    return {
                        color: styles.getPropertyValue('--edge-agent').trim() || '#00d4ff',
                        dashed: true,  // Dotted line for active work
                        lineWidth: 3  // Thicker to stand out
                    };
                case 'worked_on':
                    return {
                        color: styles.getPropertyValue('--edge-agent-past').trim() || '#6b7a8a',
                        dashed: false,  // Solid grey line (like a dead/historical link)
                        lineWidth: 2
                    };
                case 'pinned':
                    return {
                        color: styles.getPropertyValue('--edge-pinned').trim() || '#5cb85c',
                        dashed: false,  // Solid line for important connections
                        lineWidth: 3    // Thicker to emphasize importance
                    };
                default:
                    return {
                        color: styles.getPropertyValue('--edge-default').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
            }
        }

        function drawArrow(ctx, x1, y1, x2, y2, canvas, fromRadius = 30, toRadius = 30, style = null, bidirectional = false) {
            // Calculate the angle of the line
            const dx = x2 - x1;
            const dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            const distance = Math.sqrt(dx * dx + dy * dy);

            // If nodes are overlapping, skip drawing
            if (distance < fromRadius + toRadius) return;

            // Calculate start point at edge of fromNode
            const startX = x1 + Math.cos(angle) * fromRadius;
            const startY = y1 + Math.sin(angle) * fromRadius;

            // Calculate end point at edge of toNode
            const endX = x2 - Math.cos(angle) * toRadius;
            const endY = y2 - Math.sin(angle) * toRadius;

            // Transform to screen coordinates
            const p1 = worldToScreen(startX, startY, canvas);
            const p2 = worldToScreen(endX, endY, canvas);

            // Apply style
            const defaultStyle = { color: getComputedStyle(document.documentElement).getPropertyValue('--edge-default').trim(), dashed: false, lineWidth: 2 };
            const edgeStyle = style || defaultStyle;
            ctx.strokeStyle = edgeStyle.color;
            ctx.fillStyle = edgeStyle.color;
            ctx.lineWidth = edgeStyle.lineWidth * state.graph.viewport.zoom;

            // Set dash pattern for informational edges
            if (edgeStyle.dashed) {
                ctx.setLineDash([6, 4]);
            } else {
                ctx.setLineDash([]);
            }

            // Calculate midpoint for arrow head
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;

            const headLength = 10 * state.graph.viewport.zoom;
            const screenAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

            // Draw line from start to end
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();

            // Reset dash pattern for arrow heads
            ctx.setLineDash([]);

            // Arrow head at midpoint (pointing from source to target)
            ctx.beginPath();
            ctx.moveTo(midX, midY);
            ctx.lineTo(
                midX - headLength * Math.cos(screenAngle - Math.PI / 6),
                midY - headLength * Math.sin(screenAngle - Math.PI / 6)
            );
            ctx.lineTo(
                midX - headLength * Math.cos(screenAngle + Math.PI / 6),
                midY - headLength * Math.sin(screenAngle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();

            // Draw second arrow head for bidirectional edges (pointing from target to source)
            if (bidirectional) {
                const reverseAngle = screenAngle + Math.PI;
                ctx.beginPath();
                ctx.moveTo(midX, midY);
                ctx.lineTo(
                    midX - headLength * Math.cos(reverseAngle - Math.PI / 6),
                    midY - headLength * Math.sin(reverseAngle - Math.PI / 6)
                );
                ctx.lineTo(
                    midX - headLength * Math.cos(reverseAngle + Math.PI / 6),
                    midY - headLength * Math.sin(reverseAngle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fill();
            }
        }

        // Unified render function for all node types (tasks, bugs, ideas, tests, docs)
        function renderNodes() {
            const list = document.getElementById('nodes-list');
            const searchQuery = viewSearch.nodes;
            const showClosed = includeClosed.nodes;
            const typeFilter = nodesTypeFilter;
            const readyIds = new Set((state.ready || []).map(t => t.id));
            
            // Collect all nodes from different sources
            let allNodes = [];
            
            // Tasks and Bugs (from state.tasks)
            if (!typeFilter || typeFilter === 'task' || typeFilter === 'bug') {
                (state.tasks || []).forEach(t => {
                    if (t.type === 'task' || t.type === 'bug') {
                        if (typeFilter && typeFilter !== t.type) return;
                        allNodes.push({ ...t, nodeType: t.type });
                    }
                });
            }
            
            // Ideas (from state.ideas)
            if (!typeFilter || typeFilter === 'idea') {
                (state.ideas || []).forEach(idea => {
                    allNodes.push({ ...idea, nodeType: 'idea' });
                });
            }
            
            // Tests (from state.tests)
            if (!typeFilter || typeFilter === 'test') {
                (state.tests || []).forEach(test => {
                    allNodes.push({ ...test, nodeType: 'test' });
                });
            }
            
            // Docs (from state.docs)
            if (!typeFilter || typeFilter === 'doc') {
                (state.docs || []).forEach(doc => {
                    allNodes.push({ ...doc, nodeType: 'doc' });
                });
            }
            
            // Filter by closed status
            if (!showClosed) {
                allNodes = allNodes.filter(node => {
                    if (node.nodeType === 'task' || node.nodeType === 'bug') {
                        return node.status !== 'done' && node.status !== 'cancelled';
                    } else if (node.nodeType === 'idea') {
                        return node.status === 'seed' || node.status === 'germinating';
                    }
                    // Tests and docs don't have a closed state
                    return true;
                });
            }
            
            // Apply search filter
            if (searchQuery) {
                allNodes = allNodes.filter(node => itemMatchesViewSearch(node, searchQuery));
            }
            
            // Apply tag filter
            const tagFilter = nodesTagFilter;
            if (tagFilter) {
                allNodes = allNodes.filter(node => {
                    const nodeTags = node.tags || [];
                    return nodeTags.includes(tagFilter);
                });
            }
            
            // Sort: open first, ready first, by priority, then by ID
            allNodes.sort((a, b) => {
                // Type ordering: tasks/bugs first, then ideas, then tests, then docs
                const typeOrder = { task: 0, bug: 1, idea: 2, test: 3, doc: 4 };
                if (typeOrder[a.nodeType] !== typeOrder[b.nodeType]) {
                    return typeOrder[a.nodeType] - typeOrder[b.nodeType];
                }
                
                // For tasks/bugs: open first, ready first, priority
                if (a.nodeType === 'task' || a.nodeType === 'bug') {
                    const aOpen = a.status !== 'done' && a.status !== 'cancelled';
                    const bOpen = b.status !== 'done' && b.status !== 'cancelled';
                    if (aOpen !== bOpen) return bOpen - aOpen;
                    
                    const aReady = readyIds.has(a.id);
                    const bReady = readyIds.has(b.id);
                    if (aReady !== bReady) return bReady - aReady;
                    
                    if ((a.priority ?? 2) !== (b.priority ?? 2)) {
                        return (a.priority ?? 2) - (b.priority ?? 2);
                    }
                }
                
                // For ideas: open first
                if (a.nodeType === 'idea') {
                    const aOpen = a.status === 'seed' || a.status === 'germinating';
                    const bOpen = b.status === 'seed' || b.status === 'germinating';
                    if (aOpen !== bOpen) return bOpen - aOpen;
                }
                
                return a.id.localeCompare(b.id);
            });
            
            if (allNodes.length === 0) {
                const filterDesc = typeFilter ? typeFilter + 's' : 'nodes';
                list.innerHTML = searchQuery 
                    ? `<div class="empty-state">No ${filterDesc} match your search</div>`
                    : `<div class="empty-state">No open ${filterDesc}</div>`;
                return;
            }
            
            list.innerHTML = allNodes.map(node => renderNodeCard(node, readyIds)).join('');
            
            // Attach event handlers to queue toggle buttons
            list.querySelectorAll('.card-queue-toggle').forEach(btn => {
                btn.addEventListener('click', handleCardQueueToggle);
            });
            
            // Attach event handlers to jump buttons
            list.querySelectorAll('.card-jump-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const nodeId = e.currentTarget.getAttribute('data-task-id');
                    state.graph.autoFollow = false;
                    updateAutoFollowDisplay();
                    switchView('graph');
                    panToNode(nodeId, true);
                    const graphNode = state.graph.nodes.find(n => n.id === nodeId);
                    if (graphNode) {
                        state.graph.selectedNode = graphNode;
                        showInfoPanel(graphNode);
                    }
                });
            });
        }
        
        // Render a single node card based on its type
        function renderNodeCard(node, readyIds) {
            switch (node.nodeType) {
                case 'task':
                case 'bug':
                    return renderTaskBugCard(node, readyIds);
                case 'idea':
                    return renderIdeaCard(node);
                case 'test':
                    return renderTestCard(node);
                case 'doc':
                    return renderDocCard(node);
                default:
                    return '';
            }
        }
        
        function renderTaskBugCard(node, readyIds) {
            const isQueued = isNodeQueued(node.id);
            const isReady = readyIds.has(node.id);
            const isClosed = node.status === 'done' || node.status === 'cancelled';
            const isBlocked = !isClosed && (node.status === 'blocked' || !isReady);
            const isBug = node.nodeType === 'bug';
            const blockingReasons = isBlocked ? getBlockingReasons(node.id) : [];
            const reasonText = blockingReasons.length > 0 ? blockingReasons[0] : '';
            
            return `
            <div class="card ${isBlocked ? 'card-blocked' : ''} ${isClosed ? 'card-closed' : ''}">
                ${isClosed ? `<div class="closed-banner">âœ“ ${node.status === 'done' ? (isBug ? 'Fixed' : 'Done') : 'Cancelled'}</div>` : ''}
                ${isBlocked ? `<div class="blocked-banner">ðŸš« Blocked${reasonText ? `<div class="blocked-reason" title="${escapeHtml(reasonText)}">${escapeHtml(reasonText)}</div>` : ''}</div>` : ''}
                <div class="card-header">
                    <div class="card-title">${isBug ? 'ðŸ› ' : ''}${escapeHtml(node.title)}</div>
                    <div class="card-actions">
                        <button class="card-jump-btn" data-task-id="${node.id}" title="Jump to node on graph">
                            ðŸ“
                        </button>
                        ${!isClosed ? `<button class="card-queue-toggle ${isQueued ? 'active' : ''}" 
                                data-task-id="${node.id}" 
                                title="${isQueued ? 'Remove from queue' : 'Add to queue'}">
                        </button>` : ''}
                    </div>
                </div>
                ${node.description ? `<div class="card-description">${escapeHtml(node.description)}</div>` : ''}
                <div class="card-meta">
                    <span class="badge badge-priority-${node.priority ?? 2}">P${node.priority ?? 2}</span>
                    <span class="badge" style="background: var(--bg-tertiary)">${node.id}</span>
                    ${(node.tags || []).map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
                </div>
            </div>`;
        }
        
        function renderIdeaCard(idea) {
            const isClosed = idea.status !== 'seed' && idea.status !== 'germinating';
            const statusLabel = idea.status === 'seed' ? 'ðŸŒ± Seed' 
                : idea.status === 'germinating' ? 'ðŸŒ¿ Germinating'
                : idea.status === 'promoted' ? 'ðŸš€ Promoted'
                : idea.status === 'wilted' ? 'ðŸ¥€ Wilted'
                : idea.status;
            
            return `
            <div class="card ${isClosed ? 'card-closed' : ''}">
                ${isClosed ? `<div class="closed-banner">âœ“ ${idea.status === 'promoted' ? 'Promoted' : 'Wilted'}</div>` : ''}
                <div class="card-header">
                    <div class="card-title">ðŸ’¡ ${escapeHtml(idea.title)}</div>
                    <div class="card-actions">
                        <button class="card-jump-btn" data-task-id="${idea.id}" title="Jump to node on graph">
                            ðŸ“
                        </button>
                    </div>
                </div>
                ${idea.description ? `<div class="card-description">${escapeHtml(idea.description)}</div>` : ''}
                <div class="card-meta">
                    <span class="badge" style="background: var(--idea-${idea.status === 'seed' || idea.status === 'germinating' ? idea.status : 'done'})">${statusLabel}</span>
                    <span class="badge" style="background: var(--bg-tertiary)">${idea.id}</span>
                    ${(idea.tags || []).map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
                </div>
            </div>`;
        }
        
        function renderTestCard(test) {
            return `
            <div class="card">
                <div class="card-header">
                    <div class="card-title">ðŸ§ª ${escapeHtml(test.name)}</div>
                    <div class="card-actions">
                        <button class="card-jump-btn" data-task-id="${test.id}" title="Jump to node on graph">
                            ðŸ“
                        </button>
                    </div>
                </div>
                <div class="card-meta">
                    <span class="badge" style="background: var(--bg-tertiary)">${test.id}</span>
                    <span class="badge ${test.last_status === 'passed' ? 'badge-status-done' : 'badge-status-blocked'}">
                        ${test.last_status || 'Not run'}
                    </span>
                </div>
            </div>`;
        }
        
        function renderDocCard(doc) {
            function getDocTypeLabel(docType) {
                switch (docType) {
                    case 'prd': return { label: 'ðŸ“‹ PRD', color: 'var(--accent-blue)' };
                    case 'note': return { label: 'ðŸ“ Note', color: 'var(--info)' };
                    case 'handoff': return { label: 'ðŸ”„ Handoff', color: 'var(--warning)' };
                    default: return { label: docType, color: 'var(--bg-tertiary)' };
                }
            }
            
            function countLinkedEntities(docId) {
                return state.edges.filter(e => 
                    (e.source === docId || e.target === docId) && 
                    e.edge_type === 'pinned'
                ).length;
            }
            
            const typeInfo = getDocTypeLabel(doc.doc_type);
            const linkedCount = countLinkedEntities(doc.id);
            const summaryDirty = doc.summary_dirty;
            const summaryPreview = (doc.summary || '').split('\n').filter(l => l.trim()).slice(0, 1).join('').substring(0, 200);
            
            return `
            <div class="card" data-doc-id="${escapeHtml(doc.id)}" onclick="openDocViewer('${escapeHtml(doc.id)}')">
                <div class="card-header">
                    <div class="card-title">${escapeHtml(doc.title)}${summaryDirty ? ' <span style="color: var(--warning)" title="Summary needs update">âš ï¸</span>' : ''}</div>
                    <div class="card-actions">
                        <button class="card-jump-btn" data-task-id="${doc.id}" title="Jump to node on graph" onclick="event.stopPropagation()">
                            ðŸ“
                        </button>
                    </div>
                </div>
                ${summaryPreview ? `<div class="card-description">${escapeHtml(summaryPreview)}${summaryPreview.length >= 200 ? 'â€¦' : ''}</div>` : (doc.description ? `<div class="card-description">${escapeHtml(doc.description)}</div>` : '')}
                <div class="card-meta">
                    <span class="badge" style="background: ${typeInfo.color}">${typeInfo.label}</span>
                    <span class="badge" style="background: var(--bg-tertiary)">${doc.id}</span>
                    ${linkedCount > 0 ? `<span class="badge" style="background: var(--edge-hierarchy)">ðŸ”— ${linkedCount}</span>` : ''}
                    ${(doc.tags || []).map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
                </div>
            </div>`;
        }

        async function handleCardQueueToggle(event) {
            event.stopPropagation();
            const btn = event.currentTarget;
            const taskId = btn.dataset.taskId;
            
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/queue/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ node_id: taskId })
                });

                const result = await response.json();
                
                if (result.success) {
                    const isQueued = result.queued;
                    btn.classList.toggle('active', isQueued);
                    btn.title = isQueued ? 'Remove from queue' : 'Add to queue';
                    showToast(result.message, 'success');
                    // Refresh data to update edges and visual state
                    await loadData();
                } else {
                    showToast(result.error || 'Failed to toggle queue', 'error');
                }
            } catch (err) {
                showToast('Failed to toggle queue: ' + err.message, 'error');
            } finally {
                btn.disabled = false;
            }
        }

        function renderAgents() {
            const list = document.getElementById('agents-list');
            const activityLog = document.getElementById('agents-activity-log');
            
            if (!state.agents || state.agents.length === 0) {
                list.innerHTML = '<div class="empty-state">No agents registered</div>';
                activityLog.innerHTML = '<div class="empty-state">No agent activity</div>';
                return;
            }
            list.innerHTML = state.agents.map(agent => {
                const startedAt = new Date(agent.started_at).toLocaleString();
                const lastActivity = new Date(agent.last_activity_at).toLocaleString();
                const tasksHtml = agent.tasks && agent.tasks.length > 0 
                    ? agent.tasks.map(t => `<span class="task-link" data-node-id="${escapeHtml(t)}">${escapeHtml(t)}</span>`).join(', ')
                    : '<span class="no-tasks">No active tasks</span>';
                // Store task IDs as data attribute (not HTML) for terminate modal
                const taskIds = agent.tasks && agent.tasks.length > 0 
                    ? agent.tasks.join(',') 
                    : '';
                const purposeHtml = agent.purpose 
                    ? `<div class="agent-purpose">${escapeHtml(agent.purpose)}</div>` 
                    : `<div class="agent-purpose agent-type-label">${escapeHtml(agent.agent_type || 'worker')} agent</div>`;
                const agentNodeId = `agent-${agent.name}`;
                return `
                <div class="card agent-card">
                    <button class="terminate-btn" data-pid="${agent.pid}" data-name="${escapeHtml(agent.name)}" data-tasks="${escapeHtml(taskIds)}">âœ• Terminate</button>
                    <div class="agent-name">${escapeHtml(agent.name)}</div>
                    ${purposeHtml}
                    <div class="agent-pid">PID: ${agent.pid}</div>
                    <div class="card-meta">
                        <span class="badge badge-agent-${agent.status}">${agent.status}</span>
                    </div>
                    <div class="agent-tasks">Tasks: ${tasksHtml}</div>
                    <div class="agent-stats">
                        <span>ðŸ“Š ${agent.command_count} commands</span>
                        <span>ðŸ• Started: ${startedAt}</span>
                    </div>
                    <div class="agent-stats">
                        <span>â±ï¸ Last active: ${lastActivity}</span>
                    </div>
                    <button class="focus-btn" data-agent-id="${escapeHtml(agentNodeId)}">ðŸŽ¯ Focus on Graph</button>
                </div>
            `}).join('');
            
            // Render recent agent-related activity from the log
            const agentNames = new Set(state.agents.map(a => a.name));
            const agentActivity = (state.log || [])
                .filter(entry => {
                    // Filter for agent-related entries based on command field
                    const command = entry.command || entry.action || entry.message || '';
                    return command.includes('agent') || 
                           command === 'hello' || 
                           command === 'goodbye' ||
                           command === 'orient' ||
                           command === 'task update' ||
                           command === 'task close' ||
                           command === 'bug update' ||
                           command === 'bug close';
                })
                .slice(0, 20);
            
            if (agentActivity.length === 0) {
                activityLog.innerHTML = '<div class="empty-state">No recent agent activity</div>';
            } else {
                activityLog.innerHTML = agentActivity.map(entry => {
                    const time = new Date(entry.timestamp).toLocaleTimeString();
                    const formatted = formatLogEntry(entry);
                    const statusIcon = entry.success === false ? 'âŒ' : 'âœ“';
                    return `
                        <div class="activity-entry ${entry.success === false ? 'activity-error' : ''}">
                            <span class="activity-time">${time}</span>
                            <span class="activity-status">${statusIcon}</span>
                            <span class="activity-action">${escapeHtml(formatted.action)}</span>
                            ${formatted.details ? `<span class="activity-details">${escapeHtml(formatted.details)}</span>` : ''}
                        </div>
                    `;
                }).join('');
            }
            
            // Also update the sidebar on graph view
            renderAgentsSidebar();
        }
        
        // Render agents in the graph sidebar
        function renderAgentsSidebar() {
            const list = document.getElementById('agents-sidebar-list');
            const workerAgents = (state.agents || []).filter(a => a.agent_type === 'worker');
            
            if (workerAgents.length === 0) {
                list.innerHTML = '<div class="agents-sidebar-empty">No active agents</div>';
                return;
            }
            
            list.innerHTML = workerAgents.map(agent => {
                const agentId = agent.id || `agent-${agent.pid}`;
                const currentTask = agent.tasks && agent.tasks.length > 0 ? agent.tasks[0] : null;
                return `
                <div class="agents-sidebar-item" data-agent-id="${agentId}" title="${escapeHtml(agent.name)}">
                    <div class="agents-sidebar-item-header">
                        <span class="agents-sidebar-item-name">${escapeHtml(agent.name)}</span>
                        <span class="agents-sidebar-item-status ${agent.status}"></span>
                    </div>
                    ${currentTask ? `<div class="agents-sidebar-item-task">â†’ ${escapeHtml(currentTask)}</div>` : ''}
                </div>
            `}).join('');
            
            // Add click handlers to pan to agent on graph
            list.querySelectorAll('.agents-sidebar-item').forEach(item => {
                item.addEventListener('click', () => {
                    const agentId = item.dataset.agentId;
                    // Disable auto-follow when user explicitly navigates to a specific node
                    state.graph.autoFollow = false;
                    updateAutoFollowDisplay();
                    panToNode(agentId, true);
                    const node = state.graph.nodes.find(n => n.id === agentId);
                    if (node) {
                        state.graph.selectedNode = node;
                        showInfoPanel(node);
                    }
                });
            });
        }

        // Event delegation for agent card interactive elements
        document.getElementById('agents-list').addEventListener('click', (e) => {
            // Handle task link clicks
            const taskLink = e.target.closest('.task-link');
            if (taskLink) {
                const nodeId = taskLink.dataset.nodeId;
                if (nodeId) {
                    navigateToNodeOnGraph(nodeId);
                }
                return;
            }
            
            // Handle focus button clicks
            const focusBtn = e.target.closest('.focus-btn');
            if (focusBtn) {
                const agentId = focusBtn.dataset.agentId;
                if (agentId) {
                    navigateToNodeOnGraph(agentId);
                }
                return;
            }
            
            // Handle terminate button clicks
            const terminateBtn = e.target.closest('.terminate-btn');
            if (terminateBtn) {
                const pid = parseInt(terminateBtn.dataset.pid, 10);
                const name = terminateBtn.dataset.name;
                const taskIds = terminateBtn.dataset.tasks;
                // Format task IDs as HTML for the modal
                const tasksHtml = taskIds 
                    ? taskIds.split(',').map(t => `<span class="task-id">${escapeHtml(t)}</span>`).join(', ')
                    : 'None';
                showTerminateModal(pid, name, tasksHtml);
                return;
            }
        });

        // Navigate to graph view and focus on a specific node
        function navigateToNodeOnGraph(nodeId) {
            // Disable auto-follow when user explicitly navigates to a specific node
            // This indicates they want to look at that specific node, not have it auto-switch
            state.graph.autoFollow = false;
            updateAutoFollowDisplay();
            // Switch to graph view
            switchView('graph');
            // Wait for graph to render, then pan to node
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    panToNode(nodeId, true);
                    // Also select the node to show info panel
                    const node = state.graph.nodes.find(n => n.id === nodeId);
                    if (node) {
                        state.selectedNode = node;
                        updateInfoPanel(node);
                    }
                });
            });
        }

        // Agent termination modal functions
        let terminatingPid = null;

        function showTerminateModal(pid, name, tasks) {
            terminatingPid = pid;
            const modal = document.getElementById('terminate-modal');
            const info = document.getElementById('modal-agent-info');
            info.innerHTML = `
                <div class="agent-name">${escapeHtml(name)}</div>
                <div class="agent-detail">PID: ${pid}</div>
                <div class="agent-detail">Tasks: ${tasks}</div>
            `;
            modal.style.display = 'flex';
            document.getElementById('confirm-terminate-btn').onclick = confirmTerminate;
        }

        function closeTerminateModal() {
            terminatingPid = null;
            document.getElementById('terminate-modal').style.display = 'none';
        }

        async function confirmTerminate() {
            if (!terminatingPid) return;
            const pid = terminatingPid;
            closeTerminateModal();
            
            try {
                const response = await fetch(`/api/agents/${pid}/kill`, { method: 'POST' });
                const result = await response.json();
                if (response.ok) {
                    showToast(result.message, 'success');
                    await loadData(); // Refresh the agents list
                } else {
                    showToast(`Failed to terminate agent: ${result.message || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                showToast(`Failed to terminate agent: ${error}`, 'error');
            }
        }

        // Agent Detail Modal functions (for graph node double-click)
        let detailAgentPid = null;

        function showAgentDetailModal(agent) {
            detailAgentPid = agent.pid;
            const modal = document.getElementById('agent-detail-modal');
            
            // Populate modal content
            document.getElementById('agent-modal-name').textContent = agent.name;
            document.getElementById('agent-modal-pid').textContent = `PID: ${agent.pid}`;
            
            // Status badge
            const statusBadge = document.getElementById('agent-modal-status-badge');
            statusBadge.textContent = agent.status;
            statusBadge.className = `badge badge-agent-${agent.status}`;
            
            // Purpose
            const purposeSection = document.getElementById('agent-modal-purpose-section');
            const purposeEl = document.getElementById('agent-modal-purpose');
            if (agent.purpose) {
                purposeEl.textContent = agent.purpose;
                purposeSection.style.display = 'block';
            } else {
                purposeEl.textContent = 'Not registered - use bn orient --register "purpose"';
                purposeEl.style.fontStyle = 'italic';
                purposeSection.style.display = 'block';
            }
            
            // Statistics
            document.getElementById('agent-modal-command-count').textContent = agent.command_count || 0;
            document.getElementById('agent-modal-task-count').textContent = (agent.tasks || []).length;
            
            // Tasks
            const tasksSection = document.getElementById('agent-modal-tasks-section');
            const tasksEl = document.getElementById('agent-modal-tasks');
            if (agent.tasks && agent.tasks.length > 0) {
                tasksEl.innerHTML = agent.tasks.map(t => 
                    `<span class="agent-detail-task-id">${escapeHtml(t)}</span>`
                ).join('');
                tasksSection.style.display = 'block';
            } else {
                tasksSection.style.display = 'none';
            }
            
            // Timeline
            document.getElementById('agent-modal-started').textContent = 
                `ðŸ• Started: ${new Date(agent.started_at).toLocaleString()}`;
            document.getElementById('agent-modal-last-activity').textContent = 
                `â±ï¸ Last active: ${new Date(agent.last_activity_at).toLocaleString()}`;
            
            // Set up terminate button
            document.getElementById('agent-modal-terminate-btn').onclick = () => {
                closeAgentDetailModal();
                const tasksHtml = agent.tasks && agent.tasks.length > 0 
                    ? agent.tasks.map(t => `<span class="task-id">${escapeHtml(t)}</span>`).join(', ')
                    : 'None';
                showTerminateModal(agent.pid, agent.name, tasksHtml);
            };
            
            modal.style.display = 'flex';
        }

        function closeAgentDetailModal() {
            detailAgentPid = null;
            document.getElementById('agent-detail-modal').style.display = 'none';
        }

        // Close modal when clicking outside content
        document.getElementById('agent-detail-modal').addEventListener('click', (e) => {
            if (e.target.id === 'agent-detail-modal') {
                closeAgentDetailModal();
            }
        });

        // ==================== Doc Viewer ====================

        /**
         * Simple markdown to HTML converter
         * Handles: headings, bold, italic, code blocks, inline code, lists, links, blockquotes, tables
         */
        function renderMarkdown(markdown) {
            if (!markdown) return '';
            
            let html = markdown;
            
            // Escape HTML first (but preserve what we need)
            const escapeHtmlInText = (text) => text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            // Store code blocks to protect them from other transformations
            const codeBlocks = [];
            html = html.replace(/```(\w*)\n([\s\S]*?)```/g, (match, lang, code) => {
                const index = codeBlocks.length;
                const highlightedCode = highlightSyntax(escapeHtmlInText(code.trim()), lang);
                codeBlocks.push(`<pre${lang ? ` data-lang="${lang}"` : ''}><code>${highlightedCode}</code></pre>`);
                return `__CODE_BLOCK_${index}__`;
            });
            
            // Store inline code
            const inlineCode = [];
            html = html.replace(/`([^`]+)`/g, (match, code) => {
                const index = inlineCode.length;
                inlineCode.push(`<code>${escapeHtmlInText(code)}</code>`);
                return `__INLINE_CODE_${index}__`;
            });
            
            // Escape remaining HTML
            html = escapeHtmlInText(html);
            
            // Restore code blocks and inline code
            html = html.replace(/__CODE_BLOCK_(\d+)__/g, (match, index) => codeBlocks[parseInt(index)]);
            html = html.replace(/__INLINE_CODE_(\d+)__/g, (match, index) => inlineCode[parseInt(index)]);
            
            // Headings (must be at start of line)
            html = html.replace(/^######\s+(.+)$/gm, '<h6>$1</h6>');
            html = html.replace(/^#####\s+(.+)$/gm, '<h5>$1</h5>');
            html = html.replace(/^####\s+(.+)$/gm, '<h4>$1</h4>');
            html = html.replace(/^###\s+(.+)$/gm, '<h3>$1</h3>');
            html = html.replace(/^##\s+(.+)$/gm, '<h2>$1</h2>');
            html = html.replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');
            
            // Bold and italic (careful order)
            html = html.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
            html = html.replace(/___(.+?)___/g, '<strong><em>$1</em></strong>');
            html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
            html = html.replace(/_(.+?)_/g, '<em>$1</em>');
            
            // Links
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
            
            // Horizontal rules
            html = html.replace(/^---+$/gm, '<hr>');
            html = html.replace(/^\*\*\*+$/gm, '<hr>');
            
            // Blockquotes
            html = html.replace(/^&gt;\s+(.+)$/gm, '<blockquote>$1</blockquote>');
            
            // Task lists (before regular lists)
            html = html.replace(/^(\s*)[-*]\s+\[x\]\s+(.+)$/gm, '$1<li class="task-list-item"><input type="checkbox" checked disabled> $2</li>');
            html = html.replace(/^(\s*)[-*]\s+\[\s?\]\s+(.+)$/gm, '$1<li class="task-list-item"><input type="checkbox" disabled> $2</li>');
            
            // Unordered lists
            html = html.replace(/^[-*]\s+(.+)$/gm, '<li>$1</li>');
            
            // Ordered lists
            html = html.replace(/^\d+\.\s+(.+)$/gm, '<li>$1</li>');
            
            // Wrap consecutive <li> in <ul> (simple approach)
            html = html.replace(/((?:<li[^>]*>.*<\/li>\n?)+)/g, '<ul>$1</ul>');
            
            // Tables (simple implementation)
            const tableRegex = /^\|(.+)\|$/gm;
            const rows = html.match(tableRegex);
            if (rows && rows.length >= 2) {
                let tableHtml = '<table>';
                rows.forEach((row, i) => {
                    const cells = row.slice(1, -1).split('|').map(c => c.trim());
                    // Skip separator row (contains only dashes)
                    if (cells.every(c => /^[-:]+$/.test(c))) return;
                    
                    const tag = i === 0 ? 'th' : 'td';
                    tableHtml += '<tr>' + cells.map(c => `<${tag}>${c}</${tag}>`).join('') + '</tr>';
                });
                tableHtml += '</table>';
                
                // Replace the table in the HTML
                let rowsPattern = rows.map(r => r.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')).join('\\n?');
                html = html.replace(new RegExp(rowsPattern), tableHtml);
            }
            
            // Paragraphs - wrap text blocks that aren't already wrapped
            html = html.split('\n\n').map(block => {
                block = block.trim();
                if (!block) return '';
                // Don't wrap if already starts with HTML tag
                if (/^<(h[1-6]|p|ul|ol|li|pre|blockquote|table|hr|div)/.test(block)) {
                    return block;
                }
                return `<p>${block}</p>`;
            }).join('\n');
            
            // Clean up excessive newlines
            html = html.replace(/\n{3,}/g, '\n\n');
            
            return html;
        }

        /**
         * Basic syntax highlighting for code blocks
         * Uses a two-pass approach: first tokenize, then wrap with spans
         * This avoids the issue of regex patterns matching our own HTML markup
         */
        function highlightSyntax(code, lang) {
            if (!lang) return code;
            
            lang = lang.toLowerCase();
            
            // Keywords by language family
            const keywords = {
                rust: ['fn', 'let', 'mut', 'const', 'pub', 'mod', 'use', 'struct', 'enum', 'impl', 'trait', 'where', 'for', 'while', 'loop', 'if', 'else', 'match', 'return', 'break', 'continue', 'async', 'await', 'move', 'ref', 'self', 'Self', 'super', 'crate', 'dyn', 'static', 'type', 'unsafe', 'extern', 'as', 'in'],
                javascript: ['function', 'const', 'let', 'var', 'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'break', 'continue', 'return', 'class', 'extends', 'new', 'this', 'super', 'import', 'export', 'default', 'async', 'await', 'try', 'catch', 'finally', 'throw', 'typeof', 'instanceof', 'in', 'of', 'yield'],
                typescript: ['function', 'const', 'let', 'var', 'if', 'else', 'for', 'while', 'do', 'switch', 'case', 'break', 'continue', 'return', 'class', 'extends', 'new', 'this', 'super', 'import', 'export', 'default', 'async', 'await', 'try', 'catch', 'finally', 'throw', 'typeof', 'instanceof', 'in', 'of', 'yield', 'interface', 'type', 'enum', 'namespace', 'module', 'declare', 'readonly', 'private', 'public', 'protected', 'static', 'abstract', 'implements'],
                python: ['def', 'class', 'if', 'elif', 'else', 'for', 'while', 'try', 'except', 'finally', 'with', 'as', 'import', 'from', 'return', 'yield', 'raise', 'pass', 'break', 'continue', 'and', 'or', 'not', 'in', 'is', 'None', 'True', 'False', 'lambda', 'global', 'nonlocal', 'async', 'await'],
                go: ['func', 'var', 'const', 'type', 'struct', 'interface', 'map', 'chan', 'if', 'else', 'for', 'range', 'switch', 'case', 'default', 'break', 'continue', 'return', 'go', 'defer', 'select', 'package', 'import', 'make', 'new', 'nil', 'true', 'false', 'iota'],
                json: ['null', 'true', 'false'],
                bash: ['if', 'then', 'else', 'elif', 'fi', 'for', 'while', 'do', 'done', 'case', 'esac', 'function', 'return', 'exit', 'echo', 'export', 'source', 'alias', 'cd', 'pwd', 'ls', 'mkdir', 'rm', 'cp', 'mv', 'cat', 'grep', 'sed', 'awk', 'find', 'chmod', 'chown', 'sudo'],
                sh: ['if', 'then', 'else', 'elif', 'fi', 'for', 'while', 'do', 'done', 'case', 'esac', 'function', 'return', 'exit', 'echo', 'export', 'source', 'alias', 'cd', 'pwd', 'ls', 'mkdir', 'rm', 'cp', 'mv', 'cat', 'grep', 'sed', 'awk', 'find', 'chmod', 'chown', 'sudo'],
            };
            
            const keywordSet = new Set(keywords[lang] || keywords.javascript);
            
            // Tokenize the code first, then apply highlighting to tokens
            // This prevents regex from matching our own HTML markup
            const tokens = [];
            let remaining = code;
            
            while (remaining.length > 0) {
                let matched = false;
                
                // Try to match a comment (// or #)
                const singleLineComment = remaining.match(/^(\/\/.*|#.*)$/m);
                if (singleLineComment && remaining.indexOf(singleLineComment[0]) === 0) {
                    tokens.push({ type: 'comment', value: singleLineComment[0] });
                    remaining = remaining.slice(singleLineComment[0].length);
                    matched = true;
                }
                
                // Try to match a double-quoted string
                if (!matched) {
                    const doubleString = remaining.match(/^"(?:[^"\\]|\\.)*"/);
                    if (doubleString) {
                        tokens.push({ type: 'string', value: doubleString[0] });
                        remaining = remaining.slice(doubleString[0].length);
                        matched = true;
                    }
                }
                
                // Try to match a single-quoted string
                if (!matched) {
                    const singleString = remaining.match(/^'(?:[^'\\]|\\.)*'/);
                    if (singleString) {
                        tokens.push({ type: 'string', value: singleString[0] });
                        remaining = remaining.slice(singleString[0].length);
                        matched = true;
                    }
                }
                
                // Try to match a number
                if (!matched) {
                    const number = remaining.match(/^\d+\.?\d*/);
                    if (number) {
                        tokens.push({ type: 'number', value: number[0] });
                        remaining = remaining.slice(number[0].length);
                        matched = true;
                    }
                }
                
                // Try to match an identifier (potential keyword)
                if (!matched) {
                    const identifier = remaining.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
                    if (identifier) {
                        const word = identifier[0];
                        if (keywordSet.has(word)) {
                            tokens.push({ type: 'keyword', value: word });
                        } else {
                            tokens.push({ type: 'text', value: word });
                        }
                        remaining = remaining.slice(word.length);
                        matched = true;
                    }
                }
                
                // Otherwise, take one character as plain text
                if (!matched) {
                    tokens.push({ type: 'text', value: remaining[0] });
                    remaining = remaining.slice(1);
                }
            }
            
            // Convert tokens to HTML
            return tokens.map(token => {
                switch (token.type) {
                    case 'keyword':
                        return `<span class="keyword">${token.value}</span>`;
                    case 'string':
                        return `<span class="string">${token.value}</span>`;
                    case 'number':
                        return `<span class="number">${token.value}</span>`;
                    case 'comment':
                        return `<span class="comment">${token.value}</span>`;
                    default:
                        return token.value;
                }
            }).join('');
        }

        /**
         * Open the doc viewer modal and load a doc by ID
         */
        async function openDocViewer(docId) {
            const modal = document.getElementById('doc-viewer-modal');
            const titleEl = document.getElementById('doc-viewer-title-text');
            const metaEl = document.getElementById('doc-viewer-meta');
            const summaryEl = document.getElementById('doc-viewer-summary');
            const summaryContentEl = document.getElementById('doc-viewer-summary-content');
            const contentEl = document.getElementById('doc-viewer-content');
            const dirtyIndicator = document.getElementById('doc-viewer-dirty-indicator');
            const historySidebar = document.getElementById('doc-viewer-history-sidebar');
            const historyList = document.getElementById('doc-viewer-history-list');
            
            // Show loading state
            modal.classList.add('visible');
            titleEl.textContent = 'Loading...';
            metaEl.innerHTML = '';
            summaryEl.style.display = 'none';
            contentEl.innerHTML = '<div class="doc-viewer-loading">Loading document...</div>';
            dirtyIndicator.style.display = 'none';
            historySidebar.classList.remove('visible');
            historyList.innerHTML = '';
            
            try {
                // Fetch doc content and history in parallel
                const [docResponse, historyResponse] = await Promise.all([
                    fetch(`/api/docs/${encodeURIComponent(docId)}`),
                    fetch(`/api/docs/${encodeURIComponent(docId)}/history`)
                ]);
                
                if (!docResponse.ok) {
                    throw new Error(`Failed to load doc: ${docResponse.status}`);
                }
                
                const data = await docResponse.json();
                const doc = data.doc;
                
                // Set title
                titleEl.textContent = doc.title || 'Untitled';
                
                // Show dirty indicator if summary needs update
                if (doc.summary_dirty) {
                    dirtyIndicator.style.display = 'inline';
                    summaryEl.classList.add('dirty');
                } else {
                    dirtyIndicator.style.display = 'none';
                    summaryEl.classList.remove('dirty');
                }
                
                // Build meta badges
                const docTypeLabels = {
                    prd: { label: 'ðŸ“‹ PRD', color: 'var(--accent-blue)' },
                    note: { label: 'ðŸ“ Note', color: 'var(--info)' },
                    handoff: { label: 'ðŸ”„ Handoff', color: 'var(--warning)' }
                };
                const typeInfo = docTypeLabels[doc.doc_type] || { label: doc.doc_type, color: 'var(--bg-tertiary)' };
                
                let metaHtml = `
                    <span class="badge" style="background: ${typeInfo.color}">${typeInfo.label}</span>
                    <span class="badge" style="background: var(--bg-tertiary)">${escapeHtml(doc.id)}</span>
                `;
                
                if (doc.tags && doc.tags.length > 0) {
                    metaHtml += doc.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('');
                }
                
                if (doc.editors && doc.editors.length > 0) {
                    const editorNames = doc.editors.map(e => e.name || e.agent_name || 'Unknown').join(', ');
                    metaHtml += `<span class="badge" style="background: var(--bg-tertiary)">âœï¸ ${escapeHtml(editorNames)}</span>`;
                }
                
                metaEl.innerHTML = metaHtml;
                
                // Render summary section prominently
                if (doc.summary && doc.summary.trim()) {
                    summaryEl.style.display = 'block';
                    summaryContentEl.innerHTML = renderMarkdown(doc.summary);
                } else {
                    summaryEl.style.display = 'none';
                }
                
                // Render main content (excluding summary section to avoid duplication)
                let mainContent = doc.content || '';
                // Remove the summary section from main content since we show it separately
                mainContent = mainContent.replace(/^#\s*Summary\s*\n[\s\S]*?(?=^#\s|\Z)/mi, '').trim();
                
                if (mainContent) {
                    contentEl.innerHTML = renderMarkdown(mainContent);
                } else if (!doc.summary) {
                    contentEl.innerHTML = '<div class="empty-state">No content</div>';
                } else {
                    contentEl.innerHTML = '';
                }
                
                // Render version history sidebar
                if (historyResponse.ok) {
                    const historyData = await historyResponse.json();
                    if (historyData.versions && historyData.versions.length > 1) {
                        historySidebar.classList.add('visible');
                        historyList.innerHTML = historyData.versions.map((version, index) => {
                            const date = new Date(version.created_at);
                            const dateStr = date.toLocaleDateString('en-US', { 
                                year: 'numeric', 
                                month: 'short', 
                                day: 'numeric' 
                            });
                            const editorName = version.editors && version.editors.length > 0 
                                ? (version.editors[0].name || version.editors[0].agent_name || 'Unknown')
                                : 'Unknown';
                            const isCurrent = version.is_current;
                            return `
                                <div class="doc-viewer-history-item ${isCurrent ? 'current' : ''}" 
                                     onclick="openDocViewer('${escapeHtml(version.id)}')"
                                     title="${escapeHtml(version.title)}">
                                    <div class="doc-viewer-history-item-version">v${historyData.versions.length - index}</div>
                                    <div class="doc-viewer-history-item-date">${dateStr}</div>
                                    <div class="doc-viewer-history-item-editor">by ${escapeHtml(editorName)}</div>
                                </div>
                            `;
                        }).join('');
                    } else {
                        historySidebar.classList.remove('visible');
                    }
                }
                
            } catch (error) {
                console.error('Failed to load doc:', error);
                contentEl.innerHTML = `<div class="empty-state" style="color: var(--danger)">Failed to load document: ${escapeHtml(error.message)}</div>`;
            }
        }

        /**
         * Close the doc viewer modal
         */
        function closeDocViewer() {
            document.getElementById('doc-viewer-modal').classList.remove('visible');
        }

        // Close doc viewer when clicking outside the container
        document.getElementById('doc-viewer-modal').addEventListener('click', (e) => {
            if (e.target.id === 'doc-viewer-modal') {
                closeDocViewer();
            }
        });

        // Close doc viewer with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const modal = document.getElementById('doc-viewer-modal');
                if (modal.classList.contains('visible')) {
                    closeDocViewer();
                }
            }
        });

        // ==================== End Doc Viewer ====================

        function renderLog() {
            const list = document.getElementById('log-list');
            if (state.log.length === 0) {
                list.innerHTML = '<div class="empty-state">No activity yet</div>';
                return;
            }
            list.innerHTML = state.log.slice(0, 50).map(entry => {
                const formatted = formatLogEntry(entry);
                const statusClass = entry.success === false ? 'log-error' : '';
                return `
                    <div class="card log-entry ${statusClass}">
                        <div class="log-header">
                            <div class="log-time">${new Date(entry.timestamp).toLocaleString()}</div>
                            ${entry.user ? `<div class="log-user">ðŸ‘¤ ${escapeHtml(entry.user)}</div>` : ''}
                        </div>
                        <div class="card-title">${escapeHtml(formatted.action)}</div>
                        ${formatted.details ? `<div class="log-details">${escapeHtml(formatted.details)}</div>` : ''}
                        ${entry.success === false && entry.error ? `<div class="log-error-msg">âŒ ${escapeHtml(entry.error)}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        // Format a log entry into a human-readable action and details
        function formatLogEntry(entry) {
            const command = entry.command || entry.action || entry.message || 'unknown';
            const args = entry.args || {};
            
            // Build a human-readable action description
            let action = command;
            let details = '';
            
            switch (command) {
                case 'task create':
                    action = `Created task`;
                    details = args.title || '';
                    break;
                case 'task update':
                    action = `Updated task ${args.id || ''}`;
                    const updates = [];
                    if (args.status) updates.push(`status â†’ ${args.status}`);
                    if (args.priority !== null && args.priority !== undefined) updates.push(`priority â†’ ${args.priority}`);
                    if (args.title) updates.push(`title changed`);
                    details = updates.join(', ');
                    break;
                case 'task close':
                    action = `Closed task ${args.id || ''}`;
                    details = args.reason || '';
                    break;
                case 'task delete':
                    action = `Deleted task ${args.id || ''}`;
                    break;
                case 'bug create':
                    action = `Created bug`;
                    details = args.title || '';
                    break;
                case 'bug update':
                    action = `Updated bug ${args.id || ''}`;
                    const bugUpdates = [];
                    if (args.status) bugUpdates.push(`status â†’ ${args.status}`);
                    if (args.severity) bugUpdates.push(`severity â†’ ${args.severity}`);
                    details = bugUpdates.join(', ');
                    break;
                case 'bug close':
                    action = `Closed bug ${args.id || ''}`;
                    details = args.reason || '';
                    break;
                case 'idea create':
                    action = `Created idea`;
                    details = args.title || '';
                    break;
                case 'link add':
                    action = `Linked ${args.source || ''} â†’ ${args.target || ''}`;
                    details = args.edge_type ? `(${args.edge_type})` : '';
                    break;
                case 'link rm':
                    action = `Unlinked ${args.source || ''} from ${args.target || ''}`;
                    break;
                case 'orient':
                    action = `Agent oriented`;
                    break;
                case 'ready':
                    action = `Checked ready tasks`;
                    break;
                case 'hello':
                    action = `Agent started`;
                    details = args.purpose || '';
                    break;
                case 'goodbye':
                    action = `Agent finished`;
                    details = args.reason || args.summary || '';
                    break;
                case 'test run':
                    action = `Ran tests`;
                    details = args.id || (args.all ? 'all tests' : '');
                    break;
                default:
                    // For other commands, just show command with first meaningful arg
                    if (args.id) {
                        action = `${command} ${args.id}`;
                    }
                    break;
            }
            
            // Look up entity titles if we have an ID reference
            const entityId = args.id || args.task_id;
            if (entityId && !details) {
                const entity = findEntityById(entityId);
                if (entity && entity.title) {
                    details = entity.title;
                }
            }
            
            return { action, details };
        }
        
        // Find an entity (task, bug, idea) by ID
        function findEntityById(id) {
            if (!id) return null;
            const allEntities = [...(state.tasks || []), ...(state.bugs || []), ...(state.ideas || [])];
            return allEntities.find(e => e.id === id);
        }

        function renderEmptyState(ctx, message) {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(message, ctx.canvas.width / 2, ctx.canvas.height / 2);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Edge filter UI functions
        function getEdgeCategoryColor(category) {
            const styles = getComputedStyle(document.documentElement);
            switch (category) {
                case 'blocking': return styles.getPropertyValue('--edge-blocking').trim();
                case 'informational': return styles.getPropertyValue('--edge-informational').trim();
                case 'fixes': return styles.getPropertyValue('--edge-fixes').trim();
                case 'hierarchy': return styles.getPropertyValue('--edge-hierarchy').trim();
                case 'queued': return styles.getPropertyValue('--edge-queued').trim();
                default: return styles.getPropertyValue('--edge-default').trim();
            }
        }

        function initializeEdgeFilters() {
            const container = document.getElementById('sidebar-edge-filters');
            if (!container) return;
            
            // Create filter buttons for each edge type
            container.innerHTML = '';
            
            // Add "All" toggle button first
            const allBtn = document.createElement('button');
            allBtn.className = 'edge-filter-btn edge-filter-all';
            allBtn.textContent = 'All';
            allBtn.title = 'Toggle all edge types';
            
            const updateAllBtnState = () => {
                const allActive = Object.keys(EDGE_TYPES).every(type => state.edgeFilters[type]);
                allBtn.classList.toggle('active', allActive);
            };
            
            // Update spring button enabled state based on visibility
            const updateSpringBtnState = (springBtn, type) => {
                const isVisible = state.edgeFilters[type];
                springBtn.disabled = !isVisible;
                if (!isVisible) {
                    springBtn.title = `Enable ${EDGE_TYPES[type].name} visibility first`;
                } else {
                    springBtn.title = state.edgeSpringFilters[type] 
                        ? `Disable spring physics for ${EDGE_TYPES[type].name} edges`
                        : `Enable spring physics for ${EDGE_TYPES[type].name} edges`;
                }
            };
            
            allBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const allActive = Object.keys(EDGE_TYPES).every(type => state.edgeFilters[type]);
                const newState = !allActive;
                
                for (const type of Object.keys(EDGE_TYPES)) {
                    state.edgeFilters[type] = newState;
                }
                
                // Update all visibility button states
                container.querySelectorAll('.edge-visibility-btn').forEach(visBtn => {
                    const type = visBtn.dataset.edgeType;
                    if (type) {
                        visBtn.classList.toggle('active', newState);
                        visBtn.title = newState 
                            ? `Hide ${EDGE_TYPES[type].name} edges`
                            : `Show ${EDGE_TYPES[type].name} edges`;
                    }
                });
                // Update all label button states (active when BOTH visible AND spring)
                container.querySelectorAll('.edge-filter-btn[data-edge-type]').forEach(btn => {
                    const type = btn.dataset.edgeType;
                    btn.classList.toggle('active', newState && state.edgeSpringFilters[type]);
                });
                // Update all spring button states
                container.querySelectorAll('.edge-spring-btn').forEach(springBtn => {
                    const type = springBtn.dataset.edgeType;
                    if (type) updateSpringBtnState(springBtn, type);
                });
                updateAllBtnState();
                saveEdgeFilters(state.edgeFilters);
                startAnimation();  // Restart animation to apply edge filter
            });
            
            container.appendChild(allBtn);
            
            for (const [type, info] of Object.entries(EDGE_TYPES)) {
                // Create row container: [eye visibility] [color label] [magnet spring]
                const row = document.createElement('div');
                row.className = 'edge-filter-row';
                
                // Create eye visibility button (toggles visibility only)
                const visBtn = document.createElement('button');
                visBtn.className = 'edge-visibility-btn' + (state.edgeFilters[type] ? ' active' : '');
                visBtn.dataset.edgeType = type;
                visBtn.innerHTML = 'ðŸ‘';
                visBtn.title = state.edgeFilters[type] 
                    ? `Hide ${info.name} edges`
                    : `Show ${info.name} edges`;
                
                // Create color label button (toggles BOTH visibility AND magnet)
                const btn = document.createElement('button');
                btn.className = 'edge-filter-btn' + (state.edgeFilters[type] && state.edgeSpringFilters[type] ? ' active' : '');
                btn.dataset.edgeType = type;
                btn.title = `Toggle ${info.name} visibility and physics`;
                
                const dot = document.createElement('span');
                dot.className = 'edge-filter-dot';
                dot.style.backgroundColor = getEdgeCategoryColor(info.category);
                
                btn.appendChild(dot);
                btn.appendChild(document.createTextNode(info.name));
                
                // Create spring toggle button (toggles magnet/physics only)
                const springBtn = document.createElement('button');
                springBtn.className = 'edge-spring-btn' + (state.edgeSpringFilters[type] ? ' active' : '');
                springBtn.dataset.edgeType = type;
                springBtn.innerHTML = 'ðŸ§²';  // Magnet emoji for springiness
                updateSpringBtnState(springBtn, type);
                
                // Helper to update visibility button state
                const updateVisBtnState = () => {
                    visBtn.classList.toggle('active', state.edgeFilters[type]);
                    visBtn.title = state.edgeFilters[type] 
                        ? `Hide ${info.name} edges`
                        : `Show ${info.name} edges`;
                };
                
                // Helper to update label button state (active when BOTH visible AND spring are on)
                const updateLabelBtnState = () => {
                    btn.classList.toggle('active', state.edgeFilters[type] && state.edgeSpringFilters[type]);
                };
                
                // Eye button: toggle visibility only
                visBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    state.edgeFilters[type] = !state.edgeFilters[type];
                    updateVisBtnState();
                    updateLabelBtnState();
                    updateSpringBtnState(springBtn, type);
                    updateAllBtnState();
                    saveEdgeFilters(state.edgeFilters);
                    startAnimation();
                });
                
                // Label button: toggle BOTH visibility AND magnet together
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // If both are on, turn both off; otherwise turn both on
                    const bothActive = state.edgeFilters[type] && state.edgeSpringFilters[type];
                    const newState = !bothActive;
                    state.edgeFilters[type] = newState;
                    state.edgeSpringFilters[type] = newState;
                    updateVisBtnState();
                    updateLabelBtnState();
                    springBtn.classList.toggle('active', newState);
                    updateSpringBtnState(springBtn, type);
                    updateAllBtnState();
                    saveEdgeFilters(state.edgeFilters);
                    saveEdgeSpringFilters(state.edgeSpringFilters);
                    startAnimation();
                });
                
                // Magnet button: toggle spring physics only (when visible)
                springBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!state.edgeFilters[type]) return; // Can't toggle spring if edge not visible
                    state.edgeSpringFilters[type] = !state.edgeSpringFilters[type];
                    springBtn.classList.toggle('active', state.edgeSpringFilters[type]);
                    updateLabelBtnState();
                    updateSpringBtnState(springBtn, type);
                    saveEdgeSpringFilters(state.edgeSpringFilters);
                    startAnimation();
                });
                
                row.appendChild(visBtn);
                row.appendChild(btn);
                row.appendChild(springBtn);
                container.appendChild(row);
            }
            
            updateAllBtnState();
        }

        // Global escape key handler to close modals
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close terminate modal if open
                const terminateModal = document.getElementById('terminate-modal');
                if (terminateModal && terminateModal.style.display !== 'none') {
                    closeTerminateModal();
                    e.preventDefault();
                    return;
                }
                // Close edge info panel if open
                const edgeInfoPanel = document.getElementById('edge-info-panel');
                if (edgeInfoPanel && edgeInfoPanel.classList.contains('visible')) {
                    state.graph.selectedEdge = null;
                    updateEdgeInfoPanel(null);
                    e.preventDefault();
                    return;
                }
            }
        });

        // Initialize
        initializeEdgeFilters();
        initializeStatFilters();
        updateAutoFollowDisplay();
        updateHideCompletedDisplay();
        initializeGraphSearch();
        initializeViewSearch();
        connectWebSocket();
        
        // Periodically refresh the recently completed pane to keep "time ago" display current
        setInterval(() => {
            updateRecentlyCompletedPane();
        }, 30000); // Refresh every 30 seconds
    </script>
</body>
</html>
