<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binnacle - Project State Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a2332;
            --bg-secondary: #243447;
            --bg-tertiary: #2d4059;
            --text-primary: #e8edf3;
            --text-secondary: #b8c5d6;
            --accent-blue: #4a90e2;
            --accent-light: #6aa8f0;
            --border-color: #3a4d66;
            --success: #5cb85c;
            --warning: #f0ad4e;
            --danger: #d9534f;
            --info: #5bc0de;
            /* Edge type colors */
            --edge-blocking: #e85d5d;
            --edge-informational: #7a8fa3;
            --edge-fixes: #5cb85c;
            --edge-hierarchy: #9b6ed8;
            --edge-default: #3a4d66;
            /* Node type colors - bugs (reddish) */
            --bug-pending: #e07878;
            --bug-in-progress: #d95050;
            --bug-blocked: #b33a3a;
            --bug-done: #8fbc8f;
            /* Node type colors - ideas (deeper purple) */
            --idea-pending: #8b5fc9;
            --idea-in-progress: #7a4db8;
            --idea-blocked: #5c3a8a;
            --idea-done: #8fbc8f;
            /* Node type colors - queue (teal/cyan) */
            --queue-color: #20b2aa;
            --queue-color-light: #40d0c8;
            /* Node type colors - agents (bright cyan/electric blue) */
            --agent-active: #00d4ff;
            --agent-idle: #6bb3c9;
            --agent-stale: #4a6670;
            /* Edge type colors - queued */
            --edge-queued: #20b2aa;
            /* Edge type colors - agent working_on */
            --edge-agent: #00d4ff;
            /* Overlay backgrounds */
            --overlay-bg: rgba(0, 0, 0, 0.85);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            border-bottom: 2px solid var(--border-color);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .header-left {
            flex: 1;
        }

        .active-task-pane {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            min-width: 280px;
            max-width: 400px;
            margin-left: 1rem;
            transition: all 0.3s ease;
        }

        .active-task-pane.empty {
            opacity: 0.5;
        }

        .active-task-pane-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .active-task-pane-header .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--warning);
            animation: pulse 2s ease-in-out infinite;
        }

        .active-task-pane.empty .indicator {
            background: var(--text-secondary);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .active-task-id {
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--accent-light);
            margin-bottom: 0.25rem;
        }

        .active-task-title {
            font-size: 0.95rem;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .active-task-meta {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .active-task-meta .badge {
            font-size: 0.75rem;
            padding: 0.15rem 0.5rem;
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--accent-light);
        }

        .subtitle {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        nav {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
        }

        .nav-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-light);
        }

        main {
            flex: 1;
            overflow: auto;
            padding: 2rem;
        }

        .view {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .view.active {
            display: block;
        }

        #graph-view {
            position: relative;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #graph-canvas {
            width: 100%;
            height: calc(100vh - 200px);
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .task-list, .test-list, .log-list, .agents-list {
            display: grid;
            gap: 1rem;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            border-color: var(--accent-blue);
        }

        .card-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .card-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.75rem;
        }

        .card-description {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            line-height: 1.4;
        }

        /* Card header with queue toggle */
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 0.75rem;
        }

        .card-header .card-title {
            flex: 1;
            min-width: 0;
        }

        /* Compact queue toggle for task cards */
        .card-queue-toggle {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
            flex-shrink: 0;
        }

        .card-queue-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--text-secondary);
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .card-queue-toggle.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .card-queue-toggle.active::after {
            transform: translateX(14px);
            background: white;
        }

        .card-queue-toggle:hover {
            border-color: #22c55e;
        }

        .card-queue-toggle:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .badge {
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .badge-priority-0 { background: var(--danger); color: white; }
        .badge-priority-1 { background: var(--warning); color: white; }
        .badge-priority-2 { background: var(--info); color: white; }
        .badge-priority-3 { background: var(--success); color: white; }

        .badge-status-pending { background: var(--info); color: white; }
        .badge-status-in_progress { background: var(--warning); color: white; }
        .badge-status-blocked { background: var(--danger); color: white; }
        .badge-status-done { background: var(--success); color: white; }

        /* Agent status badges */
        .badge-agent-Active { 
            background: var(--success); 
            color: white;
            animation: agent-pulse 2s ease-in-out infinite;
        }
        .badge-agent-Idle { background: var(--warning); color: white; }
        .badge-agent-Stale { 
            background: var(--danger); 
            color: white;
            opacity: 0.7;
        }

        @keyframes agent-pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(92, 184, 92, 0.5); }
            50% { box-shadow: 0 0 8px 4px rgba(92, 184, 92, 0.3); }
        }

        .badge-tag {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        /* Agent card styles */
        .agent-card {
            position: relative;
        }

        .agent-card .agent-pid {
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .agent-card .agent-name {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-light);
        }

        .agent-card .agent-purpose {
            font-size: 0.9rem;
            color: var(--text-primary);
            margin-top: 0.25rem;
            font-style: italic;
        }

        .agent-card .agent-purpose.agent-type-label {
            color: var(--text-secondary);
            font-style: normal;
            font-size: 0.85rem;
            text-transform: capitalize;
        }

        .agent-card .agent-tasks {
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .agent-card .agent-tasks .no-tasks {
            color: var(--text-muted);
            font-style: italic;
        }

        .agent-card .agent-tasks .task-id {
            font-family: monospace;
            color: var(--accent-blue);
            cursor: pointer;
        }

        .agent-card .agent-tasks .task-id:hover {
            text-decoration: underline;
        }

        .agent-card .agent-stats {
            display: flex;
            gap: 1rem;
            margin-top: 0.75rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .agent-card .agent-stats span {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .log-entry {
            padding: 1rem;
            border-left: 3px solid var(--accent-blue);
        }
        
        .log-entry.log-error {
            border-left-color: var(--status-bug);
        }

        .log-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .log-time {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }
        
        .log-user {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }
        
        .log-details {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
            font-style: italic;
        }
        
        .log-error-msg {
            font-size: 0.85rem;
            color: var(--status-bug);
            margin-top: 0.5rem;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .modal-content h3 {
            margin: 0 0 1rem 0;
            color: var(--danger);
        }

        .modal-body {
            margin-bottom: 1.5rem;
        }

        .modal-body p {
            margin: 0 0 1rem 0;
            color: var(--text-secondary);
        }

        .modal-agent-info {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 1rem;
        }

        .modal-agent-info .agent-name {
            font-weight: 600;
            color: var(--accent-light);
        }

        .modal-agent-info .agent-detail {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        .modal-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 0.95rem;
            transition: all 0.2s ease;
        }

        .modal-btn-cancel {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .modal-btn-cancel:hover {
            background: var(--bg-primary);
        }

        .modal-btn-danger {
            background: var(--danger);
            color: white;
        }

        .modal-btn-danger:hover {
            background: #c9302c;
        }

        .modal-btn-primary {
            background: var(--accent);
            color: white;
        }

        .modal-btn-primary:hover {
            background: var(--accent-light);
        }

        /* Agent Detail Modal */
        .agent-detail-modal .modal-content {
            max-width: 500px;
        }

        .agent-detail-modal .modal-content h3 {
            color: var(--accent);
            margin-bottom: 1.25rem;
        }

        .agent-detail-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .agent-detail-icon {
            width: 48px;
            height: 48px;
            background: var(--accent);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        .agent-detail-title {
            flex: 1;
        }

        .agent-detail-title .agent-name {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        .agent-detail-title .agent-pid {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .agent-detail-section {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .agent-detail-section-title {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-tertiary);
            margin-bottom: 0.5rem;
        }

        .agent-detail-purpose {
            color: var(--text-primary);
            line-height: 1.5;
        }

        .agent-detail-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
        }

        .agent-detail-stat {
            text-align: center;
        }

        .agent-detail-stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--accent);
        }

        .agent-detail-stat-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .agent-detail-tasks {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .agent-detail-task-id {
            background: var(--bg-secondary);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.9rem;
            color: var(--accent-light);
            font-family: monospace;
        }

        .agent-detail-timestamp {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        /* Terminate button in agent card */
        .agent-card .terminate-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            background: transparent;
            border: 1px solid var(--danger);
            color: var(--danger);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.7;
        }

        .agent-card .terminate-btn:hover {
            background: var(--danger);
            color: white;
            opacity: 1;
        }

        /* Agent Activity Section */
        .agents-activity-section {
            margin-top: 2rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }

        .agents-activity-section h3 {
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .agents-activity-log {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .activity-entry {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.75rem 1rem;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .activity-entry.activity-error {
            border-color: var(--status-bug);
        }

        .activity-entry .activity-time {
            font-size: 0.8rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }
        
        .activity-entry .activity-status {
            font-size: 0.8rem;
            opacity: 0.7;
        }

        .activity-entry .activity-agent {
            font-size: 0.85rem;
            color: var(--accent-light);
            font-weight: 500;
        }

        .activity-entry .activity-action {
            font-size: 0.9rem;
            color: var(--text-primary);
        }
        
        .activity-entry .activity-details {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-style: italic;
            flex-basis: 100%;
            padding-left: 3.5rem;
        }

        .connection-status {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-connected { background: var(--success); }
        .status-disconnected { background: var(--danger); animation: none; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .node-tooltip {
            position: fixed;
            background: var(--overlay-bg);
            color: var(--text-primary);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .node-tooltip.visible {
            display: block;
        }

        .graph-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 0.5rem;
            z-index: 100;
            align-items: center;
            justify-content: flex-end;
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            max-width: calc(100vw - 250px);
        }

        .zoom-buttons {
            display: flex;
            flex-direction: row;
            gap: 0.5rem;
            align-items: center;
            flex-shrink: 0;
        }

        .graph-search {
            height: 32px;
            width: 180px;
            padding: 0 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .graph-search::placeholder {
            color: var(--text-secondary);
        }

        .graph-search:focus {
            outline: none;
            border-color: var(--accent-light);
            box-shadow: 0 0 0 2px rgba(106, 168, 240, 0.2);
        }

        /* Auto-follow toggle */
        .auto-follow-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-right: 0.25rem;
            padding-right: 0.5rem;
            border-right: 1px solid var(--border-color);
        }

        .auto-follow-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .auto-follow-switch {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .auto-follow-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            transition: transform 0.2s ease;
        }

        .auto-follow-switch.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .auto-follow-switch.active::after {
            transform: translateX(14px);
        }

        /* Hide completed toggle */
        .hide-completed-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-right: 0.25rem;
            padding-right: 0.5rem;
            border-right: 1px solid var(--border-color);
        }

        .hide-completed-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .hide-completed-switch {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .hide-completed-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            transition: transform 0.2s ease;
        }

        .hide-completed-switch.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .hide-completed-switch.active::after {
            transform: translateX(14px);
        }

        /* Chain length filter */
        .chain-length-filter {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-right: 0.25rem;
            padding-right: 0.5rem;
            border-right: 1px solid var(--border-color);
        }

        .chain-length-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .chain-length-slider {
            width: 60px;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-tertiary);
            border-radius: 2px;
            cursor: pointer;
        }

        .chain-length-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .chain-length-slider::-webkit-slider-thumb:hover {
            background: var(--accent-light);
        }

        .chain-length-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            border: none;
            transition: background 0.2s ease;
        }

        .chain-length-slider::-moz-range-thumb:hover {
            background: var(--accent-light);
        }

        .chain-length-value {
            font-size: 0.75rem;
            font-family: monospace;
            color: var(--text-primary);
            min-width: 1.5rem;
            text-align: center;
        }

        .chain-length-filter.active .chain-length-label {
            color: var(--accent-light);
        }

        /* Edge filter dropdown */
        .edge-filters {
            position: relative;
        }

        .edge-filters-btn {
            padding: 0.4rem 0.75rem;
            font-size: 0.8rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            transition: all 0.2s ease;
        }

        .edge-filters-btn:hover {
            border-color: var(--accent-blue);
            color: var(--text-primary);
        }

        .edge-filters-btn .arrow {
            font-size: 0.6rem;
            transition: transform 0.2s ease;
        }

        .edge-filters.open .edge-filters-btn .arrow {
            transform: rotate(180deg);
        }

        .edge-filters-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 0.25rem;
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.5rem;
            z-index: 200;
            display: none;
            flex-direction: column;
            gap: 0.25rem;
            min-width: 140px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .edge-filters.open .edge-filters-dropdown {
            display: flex;
        }

        .edge-filter-btn {
            padding: 0.35rem 0.5rem;
            font-size: 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            width: 100%;
        }

        .edge-filter-btn:hover {
            border-color: var(--accent-blue);
        }

        .edge-filter-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-light);
            color: white;
        }

        .edge-filter-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .edge-filter-all {
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0.25rem;
            padding-bottom: 0.5rem;
        }

        .edge-filter-row {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            width: 100%;
        }

        .edge-filter-row .edge-filter-btn {
            flex: 1;
        }

        .edge-spring-btn {
            width: 28px;
            height: 28px;
            padding: 0;
            font-size: 0.85rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.5;
        }

        .edge-spring-btn:hover {
            border-color: var(--accent-blue);
            opacity: 0.8;
        }

        .edge-spring-btn.active {
            background: var(--success);
            border-color: var(--success);
            color: white;
            opacity: 1;
        }

        .edge-spring-btn[disabled] {
            opacity: 0.2;
            cursor: not-allowed;
        }

        .jump-queue-btn {
            padding: 0.4rem 0.75rem;
            font-size: 0.8rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            transition: all 0.2s ease;
            margin-left: 0.5rem;
        }

        .jump-queue-btn:hover {
            border-color: var(--queue-color);
            color: var(--text-primary);
        }

        .jump-queue-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .jump-queue-btn .queue-icon {
            color: var(--queue-color);
        }

        .graph-filters {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.5rem;
            z-index: 100;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .stats-overlay {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .stats-overlay .stat-group {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            margin: -0.25rem -0.5rem;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .stats-overlay .stat-group:hover {
            background-color: var(--bg-tertiary);
        }

        .stats-overlay .stat-group.active {
            background-color: var(--accent-blue);
            color: var(--text-primary);
        }

        .stats-overlay .stat-separator {
            color: var(--border-color);
            font-weight: 300;
        }

        .stats-overlay .stat-detail {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: var(--accent-blue);
        }

        .zoom-level {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.35rem 0.5rem;
            font-size: 0.8rem;
            text-align: center;
            color: var(--text-secondary);
            min-width: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tooltip-title {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: var(--accent-light);
        }

        .tooltip-id {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-family: monospace;
            margin-bottom: 0.5rem;
        }

        .tooltip-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        /* Edge tooltip styles */
        .edge-tooltip {
            position: fixed;
            background: var(--overlay-bg);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            pointer-events: none;
            z-index: 1000;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
            font-size: 0.9rem;
        }

        .edge-tooltip.visible {
            display: block;
        }

        .edge-tooltip-type {
            font-weight: 600;
            margin-bottom: 0.4rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .edge-tooltip-type .edge-color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .edge-tooltip-ids {
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.4rem;
        }

        .edge-tooltip-reason {
            font-style: italic;
            color: var(--text-secondary);
            margin-top: 0.4rem;
            padding-top: 0.4rem;
            border-top: 1px solid var(--border-color);
        }

        .edge-tooltip-date {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 0.3rem;
        }

        #graph-canvas {
            cursor: default;
        }

        #graph-canvas.hovering:not(.dragging) {
            cursor: grab;
        }

        #graph-canvas.dragging {
            cursor: grabbing;
        }

        .info-panel {
            position: absolute;
            top: 4rem;  /* Below graph-controls */
            right: 1rem;
            width: 320px;
            max-height: calc(100% - 5rem);
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 99;  /* Below graph-controls */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .info-panel.visible {
            opacity: 1;
            visibility: visible;
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .info-panel-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .info-panel-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: color 0.2s ease;
        }

        .info-panel-close:hover {
            color: var(--text-primary);
        }

        .info-panel-id {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--accent-light);
            margin-bottom: 0.5rem;
        }

        .info-panel-task-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }

        .info-panel-short-name-row {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .info-panel-label {
            font-weight: 500;
            margin-right: 0.5rem;
        }

        .info-panel-short-name {
            color: var(--accent-light);
        }

        .info-panel-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .info-panel-section {
            margin-bottom: 1rem;
        }

        .info-panel-section-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .info-panel-description {
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .info-panel-description.empty {
            color: var(--text-secondary);
            font-style: italic;
        }

        .info-panel-deps {
            list-style: none;
        }

        .info-panel-deps li {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--accent-light);
            padding: 0.25rem 0;
        }

        .info-panel-deps li:before {
            content: "â†’ ";
            color: var(--text-secondary);
        }

        .info-panel-closed-reason {
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.6;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border-left: 3px solid var(--success);
        }

        /* Clickable node links in info panel */
        .info-panel-node-link {
            font-family: monospace;
            color: var(--accent-light);
            cursor: pointer;
            text-decoration: none;
            transition: color 0.15s ease;
        }

        .info-panel-node-link:hover {
            color: var(--accent);
            text-decoration: underline;
        }

        /* Relationships list */
        .info-panel-relationships {
            list-style: none;
        }

        .info-panel-relationships li {
            font-size: 0.9rem;
            color: var(--text-primary);
            padding: 0.35rem 0;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-panel-edge-type {
            font-size: 0.75rem;
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .info-panel-edge-direction {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        /* Timestamps */
        .info-panel-timestamps {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .info-panel-timestamps dt {
            display: inline;
            font-weight: 500;
        }

        .info-panel-timestamps dd {
            display: inline;
            margin-left: 0.25rem;
            margin-right: 1rem;
        }

        /* Queue toggle in info panel */
        .info-panel-queue-section {
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-panel-queue-label {
            font-size: 0.9rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-panel-queue-label::before {
            content: 'ðŸ“‹';
        }

        .queue-toggle-switch {
            width: 40px;
            height: 22px;
            border-radius: 11px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .queue-toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--text-secondary);
            transition: transform 0.2s ease, background 0.2s ease;
        }

        .queue-toggle-switch.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .queue-toggle-switch.active::after {
            transform: translateX(18px);
            background: white;
        }

        .queue-toggle-switch:hover {
            border-color: var(--accent-light);
        }

        .queue-toggle-switch:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Edge Info Panel */
        .edge-info-panel {
            position: absolute;
            top: 4rem;
            right: 1rem;
            width: 320px;
            max-height: calc(100% - 5rem);
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 99;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .edge-info-panel.visible {
            opacity: 1;
            visibility: visible;
        }

        .edge-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .edge-info-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .edge-info-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: color 0.2s ease;
        }

        .edge-info-close:hover {
            color: var(--text-primary);
        }

        .edge-info-type {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.75rem;
        }

        .edge-info-type .edge-color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .edge-info-connection {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--accent-light);
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
        }

        .edge-info-node {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .edge-info-node-id {
            color: var(--accent-light);
            font-weight: 500;
        }

        .edge-info-node-title {
            font-family: inherit;
            font-size: 0.85rem;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .edge-info-arrow {
            text-align: center;
            color: var(--text-muted);
            font-size: 1.2rem;
            margin: 0.5rem 0;
        }

        .edge-info-section {
            margin-top: 1rem;
        }

        .edge-info-section-title {
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .edge-info-reason {
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.6;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-style: italic;
        }

        .edge-info-date {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 0.75rem;
        }

        /* Toast Notification System */
        .toast-container {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            pointer-events: none;
        }

        .toast {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            padding-right: 2.5rem;
            min-width: 280px;
            max-width: 450px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            pointer-events: auto;
            animation: toastSlideIn 0.3s ease;
            position: relative;
        }

        .toast.toast-exit {
            animation: toastSlideOut 0.3s ease forwards;
        }

        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes toastSlideOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        .toast-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
            font-size: 0.9rem;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .toast-close {
            position: absolute;
            top: 50%;
            right: 0.5rem;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            line-height: 1;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .toast-close:hover {
            opacity: 1;
        }

        /* Toast type-specific styles with colored tints */
        .toast-success {
            border-left: 4px solid var(--success);
            background: linear-gradient(90deg, rgba(92, 184, 92, 0.15), var(--bg-secondary) 30%);
        }

        .toast-success .toast-icon {
            color: var(--success);
        }

        .toast-error {
            border-left: 4px solid var(--danger);
            background: linear-gradient(90deg, rgba(217, 83, 79, 0.15), var(--bg-secondary) 30%);
        }

        .toast-error .toast-icon {
            color: var(--danger);
        }

        .toast-warning {
            border-left: 4px solid var(--warning);
            background: linear-gradient(90deg, rgba(240, 173, 78, 0.15), var(--bg-secondary) 30%);
        }

        .toast-warning .toast-icon {
            color: var(--warning);
        }

        .toast-info {
            border-left: 4px solid var(--info);
            background: linear-gradient(90deg, rgba(91, 192, 222, 0.15), var(--bg-secondary) 30%);
        }

        .toast-info .toast-icon {
            color: var(--info);
        }

        /* Responsive layout for graph overlays */
        @media (max-width: 1200px) {
            .graph-controls {
                max-width: calc(100vw - 300px);
            }
        }

        @media (max-width: 900px) {
            .graph-controls {
                max-width: calc(100vw - 200px);
            }
            .graph-search {
                width: 140px;
            }
        }

        @media (max-width: 700px) {
            .graph-controls {
                max-width: calc(100vw - 2rem);
                flex-direction: column;
                align-items: stretch;
            }
            .graph-filters {
                left: 1rem;
                right: 1rem;
                top: auto;
                bottom: 1rem;
            }
            .graph-search {
                width: 100%;
            }
            .hide-completed-toggle,
            .auto-follow-toggle,
            .chain-length-filter {
                border-right: none;
                padding-right: 0;
                margin-right: 0;
                justify-content: space-between;
            }
            .chain-length-slider {
                flex: 1;
                min-width: 80px;
            }
            .zoom-buttons {
                justify-content: center;
            }
            .info-panel {
                top: auto;
                bottom: 5rem;  /* Above the graph-filters on mobile */
                left: 1rem;
                right: 1rem;
                width: auto;
                max-height: 50vh;
            }
        }

    </style>
</head>
<body>
    <!-- Toast notification container -->
    <div class="toast-container" id="toast-container"></div>

    <div class="container">
        <header>
            <div class="header-left">
                <h1>ðŸ§­ Binnacle</h1>
                <p class="subtitle">Project State Tracker</p>
                <nav>
                    <button class="nav-btn active" data-view="graph">Graph</button>
                    <button class="nav-btn" data-view="ready">Ready Tasks</button>
                    <button class="nav-btn" data-view="ideas">Ideas</button>
                    <button class="nav-btn" data-view="tests">Tests</button>
                    <button class="nav-btn" data-view="agents">Agents</button>
                    <button class="nav-btn" data-view="log">Activity Log</button>
                </nav>
            </div>
            <div class="active-task-pane empty" id="active-task-pane">
                <div class="active-task-pane-header">
                    <span class="indicator"></span>
                    <span>Active Task</span>
                </div>
                <div class="active-task-id" id="active-task-id">No active task</div>
                <div class="active-task-title" id="active-task-title"></div>
                <div class="active-task-meta" id="active-task-meta"></div>
            </div>
        </header>

        <main>
            <div id="graph-view" class="view active">
                <canvas id="graph-canvas"></canvas>
                <div class="graph-filters">
                    <div class="stats-overlay" id="stats-overlay">
                        <span class="stat-group" id="stat-bugs">ðŸ› 0 bugs</span>
                        <span class="stat-separator">|</span>
                        <span class="stat-group" id="stat-blocked">âŒ 0 blocked</span>
                        <span class="stat-separator">|</span>
                        <span class="stat-group" id="stat-ready">âœ… 0 ready</span>
                        <span class="stat-separator">|</span>
                        <span class="stat-group" id="stat-ideas">ðŸ’­ 0 ideas</span>
                        <span class="stat-separator">|</span>
                        <span class="stat-group" id="stat-milestones">ðŸ 0 milestones</span>
                        <span class="stat-separator">|</span>
                        <span class="stat-group" id="stat-queued">â¬¡ 0 queued</span>
                    </div>
                    <div class="edge-filters" id="edge-filters">
                        <button class="edge-filters-btn" id="edge-filters-btn">
                            <span>Edge Types</span>
                            <span class="arrow">â–¼</span>
                        </button>
                        <div class="edge-filters-dropdown" id="edge-filter-group">
                            <!-- Filter buttons will be populated dynamically -->
                        </div>
                    </div>
                    <button class="jump-queue-btn" id="jump-queue-btn" title="Jump to work queue" disabled>
                        <span class="queue-icon">â¬¡</span>
                        <span>Queue</span>
                    </button>
                </div>
                <div class="node-tooltip" id="node-tooltip">
                    <div class="tooltip-title" id="tooltip-title"></div>
                    <div class="tooltip-id" id="tooltip-id"></div>
                    <div class="tooltip-meta" id="tooltip-meta"></div>
                </div>
                <div class="edge-tooltip" id="edge-tooltip">
                    <div class="edge-tooltip-type" id="edge-tooltip-type"></div>
                    <div class="edge-tooltip-ids" id="edge-tooltip-ids"></div>
                    <div class="edge-tooltip-reason" id="edge-tooltip-reason"></div>
                    <div class="edge-tooltip-date" id="edge-tooltip-date"></div>
                </div>
                <div class="graph-controls">
                    <input class="graph-search" id="graph-search" type="text" placeholder="Search nodesâ€¦" autocomplete="off" spellcheck="false" />
                    <div class="chain-length-filter" id="chain-length-filter">
                        <span class="chain-length-label">Chain â‰¥</span>
                        <input type="range" class="chain-length-slider" id="chain-length-slider" min="1" max="5" value="1" title="Filter nodes by minimum chain length" />
                        <span class="chain-length-value" id="chain-length-value">1</span>
                    </div>
                    <div class="hide-completed-toggle">
                        <span class="hide-completed-label">Hide completed</span>
                        <button class="hide-completed-switch" id="hide-completed-switch" title="Hide completed nodes (except in active chains)"></button>
                    </div>
                    <div class="auto-follow-toggle">
                        <span class="auto-follow-label">Follow active</span>
                        <button class="auto-follow-switch" id="auto-follow-switch" title="Follow active task"></button>
                    </div>
                    <div class="zoom-buttons">
                        <button class="zoom-btn" id="zoom-in" title="Zoom In">+</button>
                        <div class="zoom-level" id="zoom-level">100%</div>
                        <button class="zoom-btn" id="zoom-out" title="Zoom Out">âˆ’</button>
                        <button class="zoom-btn" id="zoom-reset" title="Reset Zoom">âŸ²</button>
                    </div>
                </div>
                <div class="info-panel" id="info-panel">
                    <div class="info-panel-header">
                        <span class="info-panel-title" id="info-panel-type-title">Task Details</span>
                        <button class="info-panel-close" id="info-panel-close" title="Close">&times;</button>
                    </div>
                    <div id="info-panel-id" class="info-panel-id"></div>
                    <div id="info-panel-task-title" class="info-panel-task-title"></div>
                    <div id="info-panel-short-name-row" class="info-panel-short-name-row" style="display: none;">
                        <span class="info-panel-label">Display Name:</span>
                        <span id="info-panel-short-name" class="info-panel-short-name"></span>
                    </div>
                    <div id="info-panel-meta" class="info-panel-meta"></div>
                    <div id="info-panel-queue-section" class="info-panel-queue-section" style="display: none;">
                        <span class="info-panel-queue-label">In Queue</span>
                        <button id="queue-toggle-btn" class="queue-toggle-switch" title="Toggle queue membership"></button>
                    </div>
                    <div id="info-panel-description-section" class="info-panel-section">
                        <div class="info-panel-section-title">Description</div>
                        <div id="info-panel-description" class="info-panel-description"></div>
                    </div>
                    <div id="info-panel-deps-section" class="info-panel-section" style="display: none;">
                        <div class="info-panel-section-title">Depends On</div>
                        <ul id="info-panel-deps" class="info-panel-deps"></ul>
                    </div>
                    <div id="info-panel-relationships-section" class="info-panel-section" style="display: none;">
                        <div class="info-panel-section-title">Relationships</div>
                        <ul id="info-panel-relationships" class="info-panel-relationships"></ul>
                    </div>
                    <div id="info-panel-closed-section" class="info-panel-section" style="display: none;">
                        <div class="info-panel-section-title">Closed Reason</div>
                        <div id="info-panel-closed-reason" class="info-panel-closed-reason"></div>
                    </div>
                    <div id="info-panel-timestamps-section" class="info-panel-section" style="display: none;">
                        <div class="info-panel-section-title">Timestamps</div>
                        <dl id="info-panel-timestamps" class="info-panel-timestamps"></dl>
                    </div>
                </div>
                <div class="edge-info-panel" id="edge-info-panel">
                    <div class="edge-info-header">
                        <span class="edge-info-title">Edge Details</span>
                        <button class="edge-info-close" id="edge-info-close" title="Close">&times;</button>
                    </div>
                    <div class="edge-info-type" id="edge-info-type">
                        <span class="edge-color-indicator" id="edge-info-color"></span>
                        <span id="edge-info-type-name"></span>
                    </div>
                    <div class="edge-info-connection">
                        <div class="edge-info-node">
                            <span class="edge-info-node-id" id="edge-info-source-id"></span>
                            <span class="edge-info-node-title" id="edge-info-source-title"></span>
                        </div>
                        <div class="edge-info-arrow">â†“</div>
                        <div class="edge-info-node">
                            <span class="edge-info-node-id" id="edge-info-target-id"></span>
                            <span class="edge-info-node-title" id="edge-info-target-title"></span>
                        </div>
                    </div>
                    <div id="edge-info-reason-section" class="edge-info-section" style="display: none;">
                        <div class="edge-info-section-title">Reason</div>
                        <div id="edge-info-reason" class="edge-info-reason"></div>
                    </div>
                    <div class="edge-info-date" id="edge-info-date"></div>
                </div>
            </div>

            <div id="ready-view" class="view">
                <div class="task-list" id="ready-list"></div>
            </div>

            <div id="ideas-view" class="view">
                <div class="task-list" id="ideas-list"></div>
            </div>

            <div id="tests-view" class="view">
                <div class="test-list" id="test-list"></div>
            </div>

            <div id="agents-view" class="view">
                <div class="agents-list" id="agents-list"></div>
                <div class="agents-activity-section">
                    <h3>Recent Agent Activity</h3>
                    <div class="agents-activity-log" id="agents-activity-log"></div>
                </div>
            </div>

            <div id="log-view" class="view">
                <div class="log-list" id="log-list"></div>
            </div>
        </main>

        <div class="connection-status">
            <div class="status-dot status-disconnected" id="status-dot"></div>
            <span id="status-text">Connecting...</span>
        </div>

        <!-- Agent Termination Confirmation Modal -->
        <div id="terminate-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <h3>Terminate Agent?</h3>
                <div class="modal-body">
                    <p>Are you sure you want to terminate this agent?</p>
                    <div class="modal-agent-info" id="modal-agent-info"></div>
                </div>
                <div class="modal-actions">
                    <button class="modal-btn modal-btn-cancel" onclick="closeTerminateModal()">Cancel</button>
                    <button class="modal-btn modal-btn-danger" id="confirm-terminate-btn">Terminate</button>
                </div>
            </div>
        </div>

        <!-- Agent Detail Modal (shown on graph node double-click) -->
        <div id="agent-detail-modal" class="modal-overlay agent-detail-modal" style="display: none;">
            <div class="modal-content">
                <h3>ðŸ¤– Agent Details</h3>
                <div class="modal-body">
                    <div class="agent-detail-header">
                        <div class="agent-detail-icon">ðŸ¤–</div>
                        <div class="agent-detail-title">
                            <div class="agent-name" id="agent-modal-name"></div>
                            <div class="agent-pid" id="agent-modal-pid"></div>
                        </div>
                        <span class="badge" id="agent-modal-status-badge"></span>
                    </div>

                    <div class="agent-detail-section" id="agent-modal-purpose-section">
                        <div class="agent-detail-section-title">Purpose</div>
                        <div class="agent-detail-purpose" id="agent-modal-purpose"></div>
                    </div>

                    <div class="agent-detail-section">
                        <div class="agent-detail-section-title">Statistics</div>
                        <div class="agent-detail-grid">
                            <div class="agent-detail-stat">
                                <div class="agent-detail-stat-value" id="agent-modal-command-count">0</div>
                                <div class="agent-detail-stat-label">Commands</div>
                            </div>
                            <div class="agent-detail-stat">
                                <div class="agent-detail-stat-value" id="agent-modal-task-count">0</div>
                                <div class="agent-detail-stat-label">Tasks</div>
                            </div>
                        </div>
                    </div>

                    <div class="agent-detail-section" id="agent-modal-tasks-section" style="display: none;">
                        <div class="agent-detail-section-title">Working On</div>
                        <div class="agent-detail-tasks" id="agent-modal-tasks"></div>
                    </div>

                    <div class="agent-detail-section">
                        <div class="agent-detail-section-title">Timeline</div>
                        <div class="agent-detail-timestamp" id="agent-modal-started"></div>
                        <div class="agent-detail-timestamp" id="agent-modal-last-activity"></div>
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="modal-btn modal-btn-cancel" onclick="closeAgentDetailModal()">Close</button>
                    <button class="modal-btn modal-btn-danger" id="agent-modal-terminate-btn">Terminate</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Toast Notification System
        const TOAST_ICONS = {
            success: 'âœ“',
            error: 'âœ•',
            warning: 'âš ',
            info: 'â„¹'
        };

        // Track recent toasts to prevent duplicates
        const recentToasts = new Map();  // message -> timestamp
        const TOAST_DEDUP_MS = 2000;  // Ignore duplicate messages within 2 seconds

        /**
         * Show a toast notification
         * @param {string} message - The message to display
         * @param {string} type - Toast type: 'success', 'error', 'warning', 'info' (default: 'info')
         * @param {number} duration - Auto-dismiss duration in ms (default: 5000, use 0 for no auto-dismiss)
         * @returns {HTMLElement|null} The toast element (can be used to dismiss manually), or null if deduplicated
         */
        function showToast(message, type = 'info', duration = 5000) {
            // Deduplicate: skip if same message shown recently
            const now = Date.now();
            const lastShown = recentToasts.get(message);
            if (lastShown && (now - lastShown) < TOAST_DEDUP_MS) {
                return null;  // Skip duplicate
            }
            recentToasts.set(message, now);
            
            // Clean up old entries periodically (keep map from growing)
            if (recentToasts.size > 50) {
                for (const [msg, timestamp] of recentToasts) {
                    if (now - timestamp > TOAST_DEDUP_MS * 2) {
                        recentToasts.delete(msg);
                    }
                }
            }

            const container = document.getElementById('toast-container');
            
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            
            const icon = document.createElement('span');
            icon.className = 'toast-icon';
            icon.textContent = TOAST_ICONS[type] || TOAST_ICONS.info;
            
            const msg = document.createElement('span');
            msg.className = 'toast-message';
            msg.textContent = message;
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'toast-close';
            closeBtn.innerHTML = '&times;';
            closeBtn.title = 'Dismiss';
            closeBtn.onclick = () => dismissToast(toast);
            
            toast.appendChild(icon);
            toast.appendChild(msg);
            toast.appendChild(closeBtn);
            
            container.appendChild(toast);
            
            // Auto-dismiss if duration > 0
            if (duration > 0) {
                toast._timeout = setTimeout(() => dismissToast(toast), duration);
            }
            
            return toast;
        }

        /**
         * Dismiss a toast notification
         * @param {HTMLElement} toast - The toast element to dismiss
         */
        function dismissToast(toast) {
            if (!toast || !toast.parentNode) return;
            
            // Clear any pending auto-dismiss
            if (toast._timeout) {
                clearTimeout(toast._timeout);
            }
            
            // Add exit animation
            toast.classList.add('toast-exit');
            
            // Remove after animation completes
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }

        // Edge type definitions with display names and default visibility
        const EDGE_TYPES = {
            depends_on: { name: 'Depends', category: 'blocking', defaultVisible: true },
            blocks: { name: 'Blocks', category: 'blocking', defaultVisible: true },
            related_to: { name: 'Related', category: 'informational', defaultVisible: false },
            duplicates: { name: 'Duplicates', category: 'informational', defaultVisible: false },
            fixes: { name: 'Fixes', category: 'fixes', defaultVisible: false },
            caused_by: { name: 'Caused By', category: 'fixes', defaultVisible: false },
            supersedes: { name: 'Supersedes', category: 'informational', defaultVisible: false },
            parent_of: { name: 'Parent', category: 'hierarchy', defaultVisible: false },
            child_of: { name: 'Child', category: 'hierarchy', defaultVisible: false },
            tests: { name: 'Tests', category: 'fixes', defaultVisible: false },
            queued: { name: 'Queued', category: 'queued', defaultVisible: true },
            working_on: { name: 'Working On', category: 'agent', defaultVisible: true }
        };

        // Load edge filter state from localStorage
        function loadEdgeFilters() {
            const saved = localStorage.getItem('binnacle_edge_filters');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    // Fall back to defaults
                }
            }
            // Default: only blocking edges visible
            const defaults = {};
            for (const [type, info] of Object.entries(EDGE_TYPES)) {
                defaults[type] = info.defaultVisible;
            }
            return defaults;
        }

        // Save edge filter state to localStorage
        function saveEdgeFilters(filters) {
            localStorage.setItem('binnacle_edge_filters', JSON.stringify(filters));
        }

        // Load edge spring (physics) state from localStorage
        function loadEdgeSpringFilters() {
            const saved = localStorage.getItem('binnacle_edge_spring_filters');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    // Fall back to defaults
                }
            }
            // Default: all edge types have springiness enabled
            const defaults = {};
            for (const type of Object.keys(EDGE_TYPES)) {
                defaults[type] = true;
            }
            return defaults;
        }

        // Save edge spring (physics) state to localStorage
        function saveEdgeSpringFilters(filters) {
            localStorage.setItem('binnacle_edge_spring_filters', JSON.stringify(filters));
        }

        // State management
        const state = {
            currentView: 'graph',
            tasks: [],
            ready: [],
            ideas: [],
            tests: [],
            log: [],
            agents: [],
            edges: [], // Raw edges from API
            edgeFilters: loadEdgeFilters(), // Which edge types are visible
            edgeSpringFilters: loadEdgeSpringFilters(), // Which edge types have spring physics
            ws: null,
            graph: {
                nodes: [],
                edges: [],
                hoveredNode: null,
                hoveredEdge: null,
                mouseX: 0,
                mouseY: 0,
                physics: {
                    damping: 0.92,
                    gravityStrength: 0.05,
                    gravityCenter: { x: 0, y: 0 },
                    repulsionStrength: 2500,
                    springStrength: 0.08,
                    springRestingLength: 200,
                    edgeAttractionEnabled: true,
                    maxVelocity: 3
                },
                // Viewport transformation
                viewport: {
                    panX: 0,
                    panY: 0,
                    zoom: 1.0,
                    minZoom: 0.1,
                    maxZoom: 3.0
                },
                // Drag state
                draggedNode: null,
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                dragNodeStartX: 0,
                dragNodeStartY: 0,
                dragStartTime: 0,
                dragLastX: 0,
                dragLastY: 0,
                // Canvas pan state
                isPanning: false,
                panStartX: 0,
                panStartY: 0,
                panStartOffsetX: 0,
                panStartOffsetY: 0,
                // Selection state
                selectedNode: null,
                selectedEdge: null,
                // Camera pan animation state
                followAnimation: null,  // { startPanX, startPanY, targetPanX, targetPanY, startZoom, targetZoom, startTime, duration }
                // Auto-follow state
                autoFollow: true,
                followingNodeId: null,  // ID of node currently being followed (for continuous tracking)
                // Stat highlight filter state (null = no filter active)
                highlightFilter: null,  // e.g., 'bugs', 'blocked', 'ready', 'ideas', 'milestones'
                // Hide completed nodes filter
                hideCompleted: true,  // When true, hide completed nodes except those in active chains
                // Chain length filter (1 = no filter, 2+ = only show nodes in chains of at least that length)
                minChainLength: 1,
                // Search filter
                searchQuery: '',
                // Cached visibility for hit-testing (null until first frame)
                visibleNodes: null,
                visibleNodeIds: null,
                // Animation time for continuous effects (ms)
                animationTime: 0
            }
        };

        // WebSocket connection
        let pendingReload = null;
        const RELOAD_DEBOUNCE_MS = 100;  // Client-side debounce as backup
        let wasConnected = false;  // Track connection state for toast notifications
        let disconnectToast = null;  // Track active disconnect toast
        let initialLoadComplete = false;  // Track if we've done the initial data load

        function connectWebSocket() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            state.ws = new WebSocket(`${protocol}//${location.host}/ws`);

            state.ws.onopen = async () => {
                updateConnectionStatus(true);
                // Show reconnection toast only if we were previously connected
                if (wasConnected) {
                    // Dismiss any active disconnect toast
                    if (disconnectToast) {
                        dismissToast(disconnectToast);
                        disconnectToast = null;
                    }
                    showToast('Connection restored', 'success', 3000);
                }
                const isInitialLoad = !wasConnected;
                wasConnected = true;
                await loadData();
                // On initial page load, snap to active task if auto-follow is enabled
                if (isInitialLoad && state.graph.autoFollow) {
                    snapToActiveTask();
                }
            };

            state.ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.type === 'reload') {
                    // Debounce rapid reload messages
                    if (pendingReload) clearTimeout(pendingReload);
                    pendingReload = setTimeout(async () => {
                        pendingReload = null;
                        // Save previous statuses for auto-follow detection
                        const prevStatuses = {};
                        const prevTitles = {};
                        if (state.tasks) {
                            state.tasks.forEach(t => {
                                prevStatuses[t.id] = t.status;
                                prevTitles[t.id] = t.title;
                            });
                        }
                        // Track previous ready count for completion detection
                        const prevReadyCount = state.ready ? state.ready.length : 0;
                        
                        await loadData();
                        
                        // Check for in_progress transitions when auto-follow is enabled
                        // Only follow actual tasks, not agent nodes (which move around too much)
                        if (state.graph.autoFollow && state.tasks) {
                            for (const task of state.tasks) {
                                if (task.type === 'agent') continue;  // Skip agent nodes
                                const prevStatus = prevStatuses[task.id];
                                if (task.status === 'in_progress' && prevStatus && prevStatus !== 'in_progress') {
                                    // Task just transitioned to in_progress - start following it with zoom to 100%
                                    state.graph.followingNodeId = task.id;
                                    panToNode(task.id, true);  // Zoom to 100%
                                    break; // Follow first transition found
                                }
                            }
                        }
                        
                        // Task completion detection: show toast when task is closed (1 minute timeout)
                        if (state.tasks) {
                            for (const task of state.tasks) {
                                const prevStatus = prevStatuses[task.id];
                                if (task.status === 'done' && prevStatus && prevStatus !== 'done') {
                                    // Task just transitioned to done - show toast with 1 minute timeout
                                    showToast(`âœ… Task closed: ${task.id} - ${task.title}`, 'success', 60000);
                                }
                            }
                        }
                        
                        // New task/bug detection: show auto-dismissing toast for new additions
                        // Only show if we've done the initial load (skip first population)
                        if (state.tasks && initialLoadComplete) {
                            for (const task of state.tasks) {
                                // Check if this is a new item (not in previous state)
                                if (prevStatuses[task.id] === undefined) {
                                    if (task.type === 'bug') {
                                        showToast(`ðŸ› Bug added: ${task.id} - ${task.title}`, 'warning', 5000);
                                    } else if (task.type === 'task') {
                                        showToast(`ðŸ“‹ Task added: ${task.id} - ${task.title}`, 'info', 5000);
                                    }
                                }
                            }
                        }
                        initialLoadComplete = true;
                        
                        // Completion detection: last ready task was claimed
                        const newReadyCount = state.ready ? state.ready.length : 0;
                        if (prevReadyCount > 0 && newReadyCount === 0) {
                            showToast('All ready tasks claimed! ðŸŽ¯', 'success', 5000);
                            // Zoom out 10% from current level
                            if (state.graph.scale > 0.1) {
                                state.graph.scale *= 0.9;
                            }
                        }
                    }, RELOAD_DEBOUNCE_MS);
                }
            };

            state.ws.onclose = () => {
                updateConnectionStatus(false);
                // Show disconnect toast if we were connected (and don't have one already)
                if (wasConnected && !disconnectToast) {
                    disconnectToast = showToast('Connection lost, reconnecting...', 'warning', 0);
                }
                setTimeout(connectWebSocket, 2000);
            };

            state.ws.onerror = () => {
                updateConnectionStatus(false);
            };
        }

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('status-dot');
            const text = document.getElementById('status-text');
            dot.className = `status-dot status-${connected ? 'connected' : 'disconnected'}`;
            text.textContent = connected ? 'Connected' : 'Disconnected';
        }

        // Data loading
        async function loadData() {
            // Load all data in parallel
            const [configData, tasksData, bugsData, ideasData, readyData, testsData, logData, edgesData, agentsData, queueData] = await Promise.all([
                fetch('/api/config').then(r => r.json()),
                fetch('/api/tasks').then(r => r.json()),
                fetch('/api/bugs').then(r => r.json()),
                fetch('/api/ideas').then(r => r.json()),
                fetch('/api/ready').then(r => r.json()),
                fetch('/api/tests').then(r => r.json()),
                fetch('/api/log').then(r => r.json()),
                fetch('/api/edges').then(r => r.json()),
                fetch('/api/agents').then(r => r.json()),
                fetch('/api/queue').then(r => r.json())
            ]);
            
            // Update the document title with project name
            if (configData.project_name) {
                document.title = `ðŸ§­ ${configData.project_name} - Binnacle`;
            }
            
            // Merge tasks, bugs, and ideas into unified tasks array for graph
            // Normalize bugs and ideas to have task-like fields for consistent rendering
            const normalizedBugs = (bugsData.bugs || []).map(bug => ({
                ...bug,
                type: 'bug',
                priority: bug.priority ?? 2,  // Default P2 if not set
                short_name: bug.short_name || null
            }));
            const normalizedIdeas = (ideasData.ideas || []).map(idea => ({
                ...idea,
                type: 'idea',
                priority: 4,  // Ideas are low priority by default
                short_name: idea.short_name || null,
                depends_on: idea.depends_on || []
            }));
            // Normalize queue to have node-like fields for graph rendering
            const normalizedQueue = queueData.queue ? [{
                ...queueData.queue,
                type: 'queue',
                status: 'active',  // Queues don't have status, use 'active' for rendering
                priority: 0,
                short_name: queueData.queue.title || null,
                depends_on: []
            }] : [];
            
            // Normalize agents to have node-like fields for graph rendering
            // Only show worker agents in the graph (filter out planner and buddy agents)
            const workerAgents = (agentsData.agents || []).filter(agent => agent.agent_type === 'worker');
            const normalizedAgents = workerAgents.map(agent => ({
                // Use proper binnacle ID (bna-xxxx) if available, fall back to PID-based ID for backwards compat
                id: agent.id || `agent-${agent.pid}`,
                title: agent.name,
                short_name: agent.purpose || agent.name,
                type: 'agent',
                status: agent.status,  // active, idle, stale
                priority: 0,  // Agents are high priority for visibility
                depends_on: [],
                // Keep original agent data for reference
                _agent: agent
            }));
            
            state.tasks = [...(tasksData.tasks || []), ...normalizedBugs, ...normalizedIdeas, ...normalizedQueue, ...normalizedAgents];
            state.ready = readyData.tasks || [];
            state.ideas = ideasData.ideas || [];
            state.tests = testsData.tests || [];
            state.log = logData.log || [];
            
            // Build agent-to-task edges ("working_on" edge type)
            // Only include edges from worker agents (same filter as node rendering)
            // Note: These edges should also exist in the main edges data now that working_on is a proper edge type
            // but we still build them here for backwards compatibility with agents without proper binnacle IDs
            const agentEdges = workerAgents
                .filter(agent => !agent.id)  // Only for agents without binnacle IDs
                .flatMap(agent => 
                    (agent.tasks || []).map(taskId => ({
                        source: `agent-${agent.pid}`,
                        target: taskId,
                        edge_type: 'working_on'
                    }))
                );
            state.edges = [...(edgesData.edges || []), ...agentEdges];
            state.agents = agentsData.agents || [];
            
            updateStatsOverlay();
            updateActiveTaskPane();
            renderCurrentView();
        }

        function updateStatsOverlay() {
            // Count entities by type and status (open items only for bugs/milestones)
            const openStatuses = ['pending', 'in_progress', 'blocked'];
            // Ideas have a different status lifecycle: seed/germinating are open, promoted/discarded are closed
            const openIdeaStatuses = ['seed', 'germinating'];
            const bugCount = state.tasks.filter(t => t.type === 'bug' && openStatuses.includes(t.status)).length;
            const blockedCount = state.tasks.filter(t => t.status === 'blocked').length;
            const readyCount = state.ready ? state.ready.length : 0;
            const ideaCount = state.tasks.filter(t => t.type === 'idea' && openIdeaStatuses.includes(t.status)).length;
            const milestoneCount = state.tasks.filter(t => t.type === 'milestone' && openStatuses.includes(t.status)).length;
            const queuedCount = state.tasks.filter(t => t.type !== 'queue' && t.type !== 'agent' && isNodeQueued(t.id)).length;

            // Update DOM elements
            document.getElementById('stat-bugs').textContent = `ðŸ› ${bugCount} bug${bugCount !== 1 ? 's' : ''}`;
            document.getElementById('stat-blocked').textContent = `âŒ ${blockedCount} blocked`;
            document.getElementById('stat-ready').textContent = `âœ… ${readyCount} ready`;
            document.getElementById('stat-ideas').textContent = `ðŸ’­ ${ideaCount} idea${ideaCount !== 1 ? 's' : ''}`;
            document.getElementById('stat-milestones').textContent = `ðŸ ${milestoneCount} milestone${milestoneCount !== 1 ? 's' : ''}`;
            document.getElementById('stat-queued').textContent = `â¬¡ ${queuedCount} queued`;
            
            // Update active state for stat filters
            updateStatFilterHighlights();
            
            // Update jump-to-queue button state
            updateJumpQueueButton();
        }
        
        function updateJumpQueueButton() {
            const queueNode = state.tasks.find(t => t.type === 'queue');
            const btn = document.getElementById('jump-queue-btn');
            if (queueNode) {
                btn.disabled = false;
                btn.title = `Jump to queue: ${queueNode.title || 'Work Queue'}`;
            } else {
                btn.disabled = true;
                btn.title = 'No work queue exists';
            }
        }
        
        function updateActiveTaskPane() {
            const pane = document.getElementById('active-task-pane');
            const idEl = document.getElementById('active-task-id');
            const titleEl = document.getElementById('active-task-title');
            const metaEl = document.getElementById('active-task-meta');
            
            // Find first in_progress task
            const activeTask = state.tasks.find(t => t.status === 'in_progress');
            
            if (activeTask) {
                pane.classList.remove('empty');
                idEl.textContent = activeTask.id;
                titleEl.textContent = activeTask.title || 'Untitled task';
                titleEl.title = activeTask.title || '';  // Full title on hover
                
                // Build meta badges
                let metaHtml = '';
                if (activeTask.priority !== undefined) {
                    metaHtml += `<span class="badge badge-priority-${activeTask.priority}">P${activeTask.priority}</span>`;
                }
                if (activeTask.tags && activeTask.tags.length > 0) {
                    activeTask.tags.slice(0, 2).forEach(tag => {
                        metaHtml += `<span class="badge badge-tag">${tag}</span>`;
                    });
                }
                metaEl.innerHTML = metaHtml;
            } else {
                pane.classList.add('empty');
                idEl.textContent = 'No active task';
                titleEl.textContent = '';
                titleEl.title = '';
                metaEl.innerHTML = '';
            }
        }
        
        // Initialize clickable stat filters
        function initializeStatFilters() {
            const filterMap = {
                'stat-bugs': 'bugs',
                'stat-blocked': 'blocked',
                'stat-ready': 'ready',
                'stat-ideas': 'ideas',
                'stat-milestones': 'milestones',
                'stat-queued': 'queued'
            };
            
            for (const [elementId, filterName] of Object.entries(filterMap)) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.addEventListener('click', () => {
                        toggleStatFilter(filterName);
                    });
                }
            }
        }
        
        // Toggle stat filter on/off
        function toggleStatFilter(filterName) {
            if (state.graph.highlightFilter === filterName) {
                // Clear filter if clicking same one
                state.graph.highlightFilter = null;
            } else {
                // Set new filter
                state.graph.highlightFilter = filterName;
            }
            updateStatFilterHighlights();
        }
        
        // Update visual state of stat filter buttons
        function updateStatFilterHighlights() {
            const filterMap = {
                'bugs': 'stat-bugs',
                'blocked': 'stat-blocked',
                'ready': 'stat-ready',
                'ideas': 'stat-ideas',
                'milestones': 'stat-milestones',
                'queued': 'stat-queued'
            };
            
            for (const [filter, elementId] of Object.entries(filterMap)) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.classList.toggle('active', state.graph.highlightFilter === filter);
                }
            }
        }
        
        // Check if a node matches the current highlight filter
        function nodeMatchesFilter(node) {
            const filter = state.graph.highlightFilter;
            if (!filter) return true; // No filter = all match
            
            const openStatuses = ['pending', 'in_progress', 'blocked'];
            const readyIds = state.ready ? new Set(state.ready.map(t => t.id)) : new Set();
            
            switch (filter) {
                case 'bugs':
                    return node.type === 'bug' && openStatuses.includes(node.status);
                case 'blocked':
                    return node.status === 'blocked';
                case 'ready':
                    return readyIds.has(node.id);
                case 'ideas':
                    // Ideas have different status lifecycle: seed/germinating are open
                    return node.type === 'idea' && ['seed', 'germinating'].includes(node.status);
                case 'milestones':
                    return node.type === 'milestone' && openStatuses.includes(node.status);
                case 'queued':
                    return node.type !== 'queue' && node.type !== 'agent' && isNodeQueued(node.id);
                default:
                    return true;
            }
        }

        // View switching
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const view = btn.dataset.view;
                switchView(view);
            });
        });

        function switchView(view) {
            state.currentView = view;
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-view="${view}"]`).classList.add('active');
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(`${view}-view`).classList.add('active');
            renderCurrentView();
        }

        // Rendering
        function renderCurrentView() {
            switch (state.currentView) {
                case 'graph':
                    renderGraph();
                    break;
                case 'ready':
                    renderReady();
                    break;
                case 'ideas':
                    renderIdeas();
                    break;
                case 'tests':
                    renderTests();
                    break;
                case 'agents':
                    renderAgents();
                    break;
                case 'log':
                    renderLog();
                    break;
            }
        }

        function renderGraph() {
            // This will be implemented with spring physics
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            if (state.tasks.length === 0) {
                renderEmptyState(ctx, 'No tasks yet');
                return;
            }

            // Build graph data structure
            buildGraphData();

            // Add mouse event listeners
            setupGraphMouseHandlers(canvas);

            // Initialize zoom display
            updateZoomDisplay();

            // Start animation loop
            requestAnimationFrame(animateGraph);
        }

        function setupGraphMouseHandlers(canvas) {
            // Remove old listeners to avoid duplicates
            const newCanvas = canvas.cloneNode(true);
            canvas.parentNode.replaceChild(newCanvas, canvas);
            const finalCanvas = document.getElementById('graph-canvas');

            finalCanvas.addEventListener('mousemove', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Handle canvas panning
                if (state.graph.isPanning) {
                    const dx = mouseX - state.graph.panStartX;
                    const dy = mouseY - state.graph.panStartY;
                    const zoom = state.graph.viewport.zoom;

                    // Update pan offset (inversely proportional to zoom)
                    state.graph.viewport.panX = state.graph.panStartOffsetX + dx / zoom;
                    state.graph.viewport.panY = state.graph.panStartOffsetY + dy / zoom;
                    return;
                }

                const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                if (state.graph.isDragging && state.graph.draggedNode) {
                    // Update dragged node position in world coordinates
                    const currentWorld = screenToWorld(mouseX, mouseY, finalCanvas);
                    const startWorld = screenToWorld(state.graph.dragStartX, state.graph.dragStartY, finalCanvas);
                    const dx = currentWorld.x - startWorld.x;
                    const dy = currentWorld.y - startWorld.y;
                    const node = state.graph.draggedNode;

                    node.x = state.graph.dragNodeStartX + dx;
                    node.y = state.graph.dragNodeStartY + dy;

                    // No boundary clamping for infinite canvas

                    // Track for momentum calculation
                    state.graph.dragLastX = mouseX;
                    state.graph.dragLastY = mouseY;

                    // Update tooltip position
                    updateTooltip(node, e.clientX, e.clientY);
                } else {
                    // Normal hover behavior - use world coordinates
                    state.graph.mouseX = worldPos.x;
                    state.graph.mouseY = worldPos.y;

                    // Find hovered node using world coordinates
                    const hoveredNode = state.graph.nodes.find(node => {
                        const dx = worldPos.x - node.x;
                        const dy = worldPos.y - node.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= node.radius;
                    });

                    if (hoveredNode !== state.graph.hoveredNode) {
                        state.graph.hoveredNode = hoveredNode;
                        updateTooltip(hoveredNode, e.clientX, e.clientY);
                        finalCanvas.classList.toggle('hovering', !!hoveredNode);
                        // Hide edge tooltip when showing node tooltip
                        if (hoveredNode) {
                            state.graph.hoveredEdge = null;
                            updateEdgeTooltip(null);
                        }
                    }

                    // Check for edge hover only if not hovering over a node
                    if (!hoveredNode) {
                        const hoveredEdge = findHoveredEdge(worldPos.x, worldPos.y);
                        if (hoveredEdge !== state.graph.hoveredEdge) {
                            state.graph.hoveredEdge = hoveredEdge;
                            updateEdgeTooltip(hoveredEdge, e.clientX, e.clientY);
                        } else if (hoveredEdge) {
                            // Update position while still hovering same edge
                            updateEdgeTooltip(hoveredEdge, e.clientX, e.clientY);
                        }
                    }
                }
            });

            finalCanvas.addEventListener('mouseleave', () => {
                // End any active drag
                if (state.graph.isDragging && state.graph.draggedNode) {
                    // Apply gentle stop (no momentum on mouse leave)
                    state.graph.draggedNode.vx = 0;
                    state.graph.draggedNode.vy = 0;
                    state.graph.isDragging = false;
                    state.graph.draggedNode = null;
                }

                // End any active pan
                if (state.graph.isPanning) {
                    state.graph.isPanning = false;
                    finalCanvas.style.cursor = 'default';
                }

                state.graph.hoveredNode = null;
                state.graph.hoveredEdge = null;
                updateTooltip(null);
                updateEdgeTooltip(null);
                finalCanvas.classList.remove('hovering', 'dragging');
            });

            finalCanvas.addEventListener('mousedown', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Middle mouse or Shift+Left mouse = always canvas pan
                // But not while auto-follow animation is active
                if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                    if (state.graph.followAnimation && state.graph.autoFollow) {
                        return; // Block panning during auto-follow
                    }
                    cancelPanAnimation();  // Cancel any ongoing camera animation
                    state.graph.isPanning = true;
                    state.graph.panStartX = mouseX;
                    state.graph.panStartY = mouseY;
                    state.graph.panStartOffsetX = state.graph.viewport.panX;
                    state.graph.panStartOffsetY = state.graph.viewport.panY;
                    finalCanvas.style.cursor = 'grabbing';
                    e.preventDefault();
                    return;
                }

                // Left mouse button = node drag or canvas pan
                if (e.button === 0) {
                    const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                    // Find node under mouse using world coordinates (visible nodes only)
                    const nodesForHitTest = state.graph.visibleNodes ?? state.graph.nodes;
                    const node = nodesForHitTest.find(n => {
                        const dx = worldPos.x - n.x;
                        const dy = worldPos.y - n.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= n.radius;
                    });

                    if (node) {
                        // Node found - drag the node
                        state.graph.draggedNode = node;
                        state.graph.isDragging = true;
                        state.graph.dragStartX = mouseX;
                        state.graph.dragStartY = mouseY;
                        state.graph.dragNodeStartX = node.x;
                        state.graph.dragNodeStartY = node.y;
                        state.graph.dragStartTime = Date.now();
                        state.graph.dragLastX = mouseX;
                        state.graph.dragLastY = mouseY;
                        finalCanvas.classList.add('dragging');
                        e.preventDefault();
                    } else {
                        // No node found - pan the canvas (but not during auto-follow animation)
                        if (state.graph.followAnimation && state.graph.autoFollow) {
                            return; // Block panning during auto-follow animation
                        }
                        // User is manually panning - stop following the node
                        state.graph.followingNodeId = null;
                        cancelPanAnimation();  // Cancel any ongoing camera animation
                        state.graph.isPanning = true;
                        state.graph.panStartX = mouseX;
                        state.graph.panStartY = mouseY;
                        state.graph.panStartOffsetX = state.graph.viewport.panX;
                        state.graph.panStartOffsetY = state.graph.viewport.panY;
                        finalCanvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                }
            });

            finalCanvas.addEventListener('mouseup', (e) => {
                // End canvas panning
                if (state.graph.isPanning) {
                    state.graph.isPanning = false;
                    finalCanvas.style.cursor = 'default';
                }

                // End node dragging
                if (state.graph.isDragging && state.graph.draggedNode) {
                    const rect = finalCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                    // Check if dropped on a queue node (drag-to-queue)
                    const draggedNode = state.graph.draggedNode;
                    const nodesForHitTest = state.graph.visibleNodes ?? state.graph.nodes;
                    const dropTarget = nodesForHitTest.find(n => {
                        if (n.id === draggedNode.id) return false;  // Skip self
                        const dx = worldPos.x - n.x;
                        const dy = worldPos.y - n.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= n.radius;
                    });

                    // If dropped on a queue and the dragged node is task/bug, add to queue
                    if (dropTarget && dropTarget.type === 'queue') {
                        const canBeQueued = ['task', 'bug'].includes(draggedNode.type);
                        const alreadyQueued = isNodeQueued(draggedNode.id);
                        
                        if (canBeQueued && !alreadyQueued) {
                            // Add queued link via API
                            fetch('/api/edges', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    source: draggedNode.id,
                                    target: dropTarget.id,
                                    edge_type: 'queued'
                                })
                            })
                            .then(r => r.json())
                            .then(result => {
                                if (result.success) {
                                    console.log(`Added ${draggedNode.id} to queue`);
                                    // The WebSocket will notify us of the change
                                } else {
                                    console.error('Failed to add to queue:', result.error);
                                }
                            })
                            .catch(err => console.error('Failed to add to queue:', err));
                        }
                    }

                    // Calculate momentum from recent drag motion in screen space
                    // Velocity is in world units per frame, so scale by zoom
                    const zoom = state.graph.viewport.zoom;
                    const velocityX = (mouseX - state.graph.dragLastX) * 2.5 / zoom;
                    const velocityY = (mouseY - state.graph.dragLastY) * 2.5 / zoom;

                    state.graph.draggedNode.vx = velocityX;
                    state.graph.draggedNode.vy = velocityY;

                    // Clear drag state
                    state.graph.isDragging = false;
                    state.graph.draggedNode = null;
                    finalCanvas.classList.remove('dragging');

                    // Update hover state (mouse may still be over a node)
                    const hoveredNode = nodesForHitTest.find(n => {
                        const dx = worldPos.x - n.x;
                        const dy = worldPos.y - n.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= n.radius;
                    });
                    state.graph.hoveredNode = hoveredNode;
                    updateTooltip(hoveredNode, e.clientX, e.clientY);
                    finalCanvas.classList.toggle('hovering', !!hoveredNode);
                }
            });

            finalCanvas.addEventListener('dblclick', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                // Find node under mouse using world coordinates (visible nodes only)
                const nodesForHitTest = state.graph.visibleNodes ?? state.graph.nodes;
                const node = nodesForHitTest.find(n => {
                    const dx = worldPos.x - n.x;
                    const dy = worldPos.y - n.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance <= n.radius;
                });

                if (node) {
                    // Check if it's an agent node - show detail modal
                    if (node.type === 'agent' && node._agent) {
                        showAgentDetailModal(node._agent);
                        e.preventDefault();
                        return;
                    }
                    
                    // Toggle selection for non-agent nodes
                    if (state.graph.selectedNode === node) {
                        state.graph.selectedNode = null;
                    } else {
                        state.graph.selectedNode = node;
                    }
                    // Hide edge info panel when selecting a node
                    state.graph.selectedEdge = null;
                    updateEdgeInfoPanel(null);
                    // Update info panel with current selection
                    updateInfoPanel(state.graph.selectedNode);
                } else {
                    // Check for edge under mouse
                    const edge = findHoveredEdge(worldPos.x, worldPos.y);
                    if (edge) {
                        // Show edge info panel
                        updateEdgeInfoPanel(edge);
                    } else {
                        // Click on empty space deselects everything
                        state.graph.selectedNode = null;
                        state.graph.selectedEdge = null;
                        updateInfoPanel(null);
                        updateEdgeInfoPanel(null);
                    }
                }

                e.preventDefault();
            });

            // Mouse wheel zoom
            finalCanvas.addEventListener('wheel', (e) => {
                e.preventDefault();

                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
                zoomCanvas(zoomDelta, mouseX, mouseY);
            }, { passive: false });
        }

        // Zoom button controls
        document.getElementById('zoom-in').addEventListener('click', () => {
            zoomCanvas(1.2);
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            zoomCanvas(0.8);
        });

        document.getElementById('zoom-reset').addEventListener('click', () => {
            state.graph.viewport.zoom = 1.0;
            state.graph.viewport.panX = 0;
            state.graph.viewport.panY = 0;
            updateZoomDisplay();
        });

        // Auto-follow toggle
        document.getElementById('auto-follow-switch').addEventListener('click', () => {
            state.graph.autoFollow = !state.graph.autoFollow;
            updateAutoFollowDisplay();
            // When enabling auto-follow, immediately snap to current active task
            if (state.graph.autoFollow) {
                snapToActiveTask();
            } else {
                // When disabling auto-follow, stop tracking
                state.graph.followingNodeId = null;
            }
        });

        function updateAutoFollowDisplay() {
            const switchEl = document.getElementById('auto-follow-switch');
            if (state.graph.autoFollow) {
                switchEl.classList.add('active');
            } else {
                switchEl.classList.remove('active');
            }
        }

        // Hide completed toggle
        document.getElementById('hide-completed-switch').addEventListener('click', () => {
            state.graph.hideCompleted = !state.graph.hideCompleted;
            updateHideCompletedDisplay();
        });

        function updateHideCompletedDisplay() {
            const switchEl = document.getElementById('hide-completed-switch');
            if (state.graph.hideCompleted) {
                switchEl.classList.add('active');
            } else {
                switchEl.classList.remove('active');
            }
        }

        // Chain length filter
        const chainLengthSlider = document.getElementById('chain-length-slider');
        const chainLengthValue = document.getElementById('chain-length-value');
        const chainLengthFilter = document.getElementById('chain-length-filter');

        // Load saved chain length filter from localStorage
        function loadChainLengthFilter() {
            const saved = localStorage.getItem('binnacle_chain_length_filter');
            if (saved) {
                const value = parseInt(saved, 10);
                if (!isNaN(value) && value >= 1 && value <= 5) {
                    return value;
                }
            }
            return 1;
        }

        // Save chain length filter to localStorage
        function saveChainLengthFilter(value) {
            localStorage.setItem('binnacle_chain_length_filter', value.toString());
        }

        // Initialize chain length filter from saved state
        state.graph.minChainLength = loadChainLengthFilter();
        chainLengthSlider.value = state.graph.minChainLength;
        chainLengthValue.textContent = state.graph.minChainLength >= 5 ? '5+' : state.graph.minChainLength;
        updateChainLengthDisplay();

        chainLengthSlider.addEventListener('input', () => {
            const value = parseInt(chainLengthSlider.value, 10);
            state.graph.minChainLength = value;
            chainLengthValue.textContent = value >= 5 ? '5+' : value;
            saveChainLengthFilter(value);
            updateChainLengthDisplay();
        });

        function updateChainLengthDisplay() {
            if (state.graph.minChainLength > 1) {
                chainLengthFilter.classList.add('active');
            } else {
                chainLengthFilter.classList.remove('active');
            }
        }

        function normalizeSearchQuery(query) {
            return (query || '').trim().toLowerCase();
        }

        function nodeMatchesSearch(node, normalizedQuery) {
            if (!normalizedQuery) return true;
            const haystack = `${node.id} ${(node.title || '')} ${(node.short_name || '')}`.toLowerCase();
            return haystack.includes(normalizedQuery);
        }

        function setGraphSearchQuery(query) {
            state.graph.searchQuery = query;
            // Note: We no longer need to clear selection/hover here since
            // non-matching nodes are now dimmed rather than hidden.
            // The visibleNodeIds check only applies to hideCompleted filtering.
        }

        function initializeGraphSearch() {
            const input = document.getElementById('graph-search');
            if (!input) return;

            input.addEventListener('input', () => {
                setGraphSearchQuery(input.value);
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    input.value = '';
                    setGraphSearchQuery('');
                    e.preventDefault();
                }
            });
        }

        // Find and pan to the first active agent or in_progress task, zooming to 100%
        function snapToActiveTask() {
            if (!state.tasks) return;
            
            // Follow the active task (in_progress), not agent nodes
            // Agent nodes move around too much and following them is distracting
            const activeTask = state.tasks.find(t => t.status === 'in_progress' && t.type !== 'agent');
            if (activeTask) {
                state.graph.followingNodeId = activeTask.id;
                panToNode(activeTask.id, true);  // Zoom to 100%
            } else {
                state.graph.followingNodeId = null;
            }
        }

        function zoomCanvas(zoomDelta, centerX, centerY) {
            const canvas = document.getElementById('graph-canvas');
            if (!centerX || !centerY) {
                // Default to canvas center
                centerX = canvas.width / 2;
                centerY = canvas.height / 2;
            }

            // World point under cursor before zoom
            const worldBefore = screenToWorld(centerX, centerY, canvas);

            // Update zoom
            const oldZoom = state.graph.viewport.zoom;
            state.graph.viewport.zoom = Math.max(
                state.graph.viewport.minZoom,
                Math.min(state.graph.viewport.maxZoom, oldZoom * zoomDelta)
            );

            // World point under cursor after zoom
            const worldAfter = screenToWorld(centerX, centerY, canvas);

            // Adjust pan to keep point stationary
            state.graph.viewport.panX += worldBefore.x - worldAfter.x;
            state.graph.viewport.panY += worldBefore.y - worldAfter.y;

            // Update zoom level display
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            const zoomLevelEl = document.getElementById('zoom-level');
            if (zoomLevelEl) {
                const percent = Math.round(state.graph.viewport.zoom * 100);
                zoomLevelEl.textContent = `${percent}%`;
            }
        }

        // Ease-in-out-cubic easing function
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Calculate adaptive pan duration based on distance
        function getPanDuration(distance) {
            // Doubled durations for smoother animation
            if (distance < 300) return 600;
            if (distance <= 800) return 1000;
            return 1600;
        }

        // Pan camera smoothly to center on a world position
        function panToWorldPosition(targetX, targetY, targetZoom = null) {
            const canvas = document.getElementById('graph-canvas');
            const { viewport } = state.graph;

            // Target pan values to center the position on screen
            // worldToScreen: screenX = (worldX + panX) * zoom + canvas.width / 2
            // To center targetX, we need: canvas.width / 2 = (targetX + panX) * zoom + canvas.width / 2
            // => 0 = (targetX + panX) * zoom
            // => panX = -targetX
            const targetPanX = -targetX;
            const targetPanY = -targetY;

            // Calculate distance in screen pixels for duration
            const startPanX = viewport.panX;
            const startPanY = viewport.panY;
            const startZoom = viewport.zoom;
            const dx = (targetPanX - startPanX) * viewport.zoom;
            const dy = (targetPanY - startPanY) * viewport.zoom;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Calculate zoom change for duration consideration
            const zoomChange = targetZoom !== null ? Math.abs(targetZoom - startZoom) : 0;

            // Skip animation if already centered (within 1 pixel) and no zoom change
            if (distance < 1 && zoomChange < 0.01) return;

            // Use longer duration if there's significant zoom change
            const baseDuration = getPanDuration(distance);
            const duration = zoomChange > 0.1 ? Math.max(baseDuration, 800) : baseDuration;

            // Start the animation
            state.graph.followAnimation = {
                startPanX,
                startPanY,
                targetPanX,
                targetPanY,
                startZoom,
                targetZoom: targetZoom !== null ? targetZoom : startZoom,
                startTime: performance.now(),
                duration
            };
        }

        // Pan camera smoothly to center on a node by ID, optionally zooming to 100%
        function panToNode(nodeId, zoomTo100 = false) {
            const node = state.graph.nodes.find(n => n.id === nodeId);
            if (node) {
                panToWorldPosition(node.x, node.y, zoomTo100 ? 1.0 : null);
            }
        }

        // Cancel any ongoing pan animation
        function cancelPanAnimation() {
            state.graph.followAnimation = null;
        }

        // Update pan animation (called from animateGraph)
        function updatePanAnimation() {
            const anim = state.graph.followAnimation;
            if (!anim) return;

            const now = performance.now();
            const elapsed = now - anim.startTime;
            const progress = Math.min(elapsed / anim.duration, 1);
            const easedProgress = easeInOutCubic(progress);

            // Interpolate pan values
            state.graph.viewport.panX = anim.startPanX + (anim.targetPanX - anim.startPanX) * easedProgress;
            state.graph.viewport.panY = anim.startPanY + (anim.targetPanY - anim.startPanY) * easedProgress;

            // Interpolate zoom if target differs from start
            if (anim.targetZoom !== anim.startZoom) {
                state.graph.viewport.zoom = anim.startZoom + (anim.targetZoom - anim.startZoom) * easedProgress;
                updateZoomDisplay();
            }

            // Animation complete
            if (progress >= 1) {
                state.graph.followAnimation = null;
            }
        }

        // Continuous follow: keep viewport centered on followed node as it moves
        function updateContinuousFollow(canvas) {
            // Skip if auto-follow is disabled or no node is being followed
            if (!state.graph.autoFollow || !state.graph.followingNodeId) return;
            
            // Skip if an animation is in progress (let it complete)
            if (state.graph.followAnimation) return;
            
            // Skip if user is panning or dragging
            if (state.graph.isPanning || state.graph.draggedNode) return;
            
            // Find the followed node
            const node = state.graph.nodes.find(n => n.id === state.graph.followingNodeId);
            if (!node) {
                // Node no longer exists, clear following
                state.graph.followingNodeId = null;
                return;
            }
            
            // Calculate target pan to center the node
            const targetPanX = -node.x;
            const targetPanY = -node.y;
            
            // Calculate distance to target
            const dx = targetPanX - state.graph.viewport.panX;
            const dy = targetPanY - state.graph.viewport.panY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Snap to exact center if very close (prevents perpetual drift)
            if (distance < 0.5) {
                state.graph.viewport.panX = targetPanX;
                state.graph.viewport.panY = targetPanY;
                return;
            }
            
            // Smoothly interpolate toward target (soft follow)
            // Use higher smoothing (0.15) for responsive tracking while still being smooth
            const smoothing = 0.15;
            state.graph.viewport.panX += dx * smoothing;
            state.graph.viewport.panY += dy * smoothing;
        }

        function updateTooltip(node, mouseX, mouseY) {
            const tooltip = document.getElementById('node-tooltip');
            const titleEl = document.getElementById('tooltip-title');
            const idEl = document.getElementById('tooltip-id');
            const metaEl = document.getElementById('tooltip-meta');

            if (!node) {
                tooltip.classList.remove('visible');
                return;
            }

            // Find full task data
            const task = state.tasks.find(t => t.id === node.id);
            if (!task) return;

            // Update tooltip content - show short_name if available, otherwise title
            titleEl.textContent = task.short_name || task.title;
            idEl.textContent = task.id;

            // Build metadata badges
            metaEl.innerHTML = `
                <span class="badge badge-priority-${task.priority}">P${task.priority}</span>
                <span class="badge badge-status-${task.status}">${task.status}</span>
                ${task.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
            `;

            // Position tooltip
            const offset = 15;
            tooltip.style.left = `${mouseX + offset}px`;
            tooltip.style.top = `${mouseY + offset}px`;

            // Adjust if tooltip goes off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (tooltipRect.right > viewportWidth) {
                tooltip.style.left = `${mouseX - tooltipRect.width - offset}px`;
            }
            if (tooltipRect.bottom > viewportHeight) {
                tooltip.style.top = `${mouseY - tooltipRect.height - offset}px`;
            }

            tooltip.classList.add('visible');
        }

        // Edge tooltip functions
        function getEdgeTypeName(edgeType) {
            const names = {
                'depends_on': 'Depends On',
                'blocks': 'Blocks',
                'related_to': 'Related To',
                'caused_by': 'Caused By',
                'duplicates': 'Duplicates',
                'supersedes': 'Supersedes',
                'fixes': 'Fixes',
                'tests': 'Tests',
                'parent_of': 'Parent Of',
                'child_of': 'Child Of'
            };
            return names[edgeType] || edgeType;
        }

        function distanceToEdge(px, py, edge) {
            // Get node positions
            const fromNode = state.graph.nodes.find(n => n.id === edge.from);
            const toNode = state.graph.nodes.find(n => n.id === edge.to);
            if (!fromNode || !toNode) return Infinity;

            // Calculate edge endpoints (at node boundaries, not centers)
            const dx = toNode.x - fromNode.x;
            const dy = toNode.y - fromNode.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < fromNode.radius + toNode.radius) return Infinity;

            const angle = Math.atan2(dy, dx);
            const x1 = fromNode.x + Math.cos(angle) * fromNode.radius;
            const y1 = fromNode.y + Math.sin(angle) * fromNode.radius;
            const x2 = toNode.x - Math.cos(angle) * toNode.radius;
            const y2 = toNode.y - Math.sin(angle) * toNode.radius;

            // Calculate distance from point to line segment
            const lineDx = x2 - x1;
            const lineDy = y2 - y1;
            const lineLen = Math.sqrt(lineDx * lineDx + lineDy * lineDy);
            if (lineLen === 0) return Infinity;

            // Project point onto line, clamped to segment
            const t = Math.max(0, Math.min(1, ((px - x1) * lineDx + (py - y1) * lineDy) / (lineLen * lineLen)));
            const projX = x1 + t * lineDx;
            const projY = y1 + t * lineDy;

            return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
        }

        function findHoveredEdge(worldX, worldY, threshold = 8) {
            // Adjust threshold for zoom level
            const adjustedThreshold = threshold / state.graph.viewport.zoom;
            
            let closestEdge = null;
            let closestDistance = adjustedThreshold;

            for (const edge of state.graph.edges) {
                // Skip edges that are filtered out
                if (!state.edgeFilters[edge.edge_type]) continue;

                // Skip edges where either endpoint is hidden
                if (state.graph.visibleNodeIds) {
                    if (!state.graph.visibleNodeIds.has(edge.from) || !state.graph.visibleNodeIds.has(edge.to)) {
                        continue;
                    }
                }
                
                const distance = distanceToEdge(worldX, worldY, edge);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestEdge = edge;
                }
            }

            return closestEdge;
        }

        function updateEdgeTooltip(edge, mouseX, mouseY) {
            const tooltip = document.getElementById('edge-tooltip');
            const typeEl = document.getElementById('edge-tooltip-type');
            const idsEl = document.getElementById('edge-tooltip-ids');
            const reasonEl = document.getElementById('edge-tooltip-reason');
            const dateEl = document.getElementById('edge-tooltip-date');

            if (!edge) {
                tooltip.classList.remove('visible');
                return;
            }

            // Get the full edge data from state.edges (API data with created_at)
            const fullEdge = state.edges.find(e => 
                e.source === edge.from && e.target === edge.to && e.edge_type === edge.edge_type
            );

            // Get edge style for color
            const style = getEdgeStyle(edge.edge_type);
            
            // Update tooltip content
            typeEl.innerHTML = `
                <span class="edge-color-dot" style="background-color: ${style.color}"></span>
                ${getEdgeTypeName(edge.edge_type)}${edge.bidirectional ? ' (bidirectional)' : ''}
            `;
            idsEl.textContent = `${edge.from} â†’ ${edge.to}`;

            // Show/hide reason
            if (edge.reason) {
                reasonEl.textContent = `"${edge.reason}"`;
                reasonEl.style.display = 'block';
            } else {
                reasonEl.style.display = 'none';
            }

            // Show created date if available
            if (fullEdge && fullEdge.created_at) {
                const date = new Date(fullEdge.created_at);
                dateEl.textContent = `Created: ${date.toLocaleDateString()}`;
                dateEl.style.display = 'block';
            } else {
                dateEl.style.display = 'none';
            }

            // Position tooltip
            const offset = 15;
            tooltip.style.left = `${mouseX + offset}px`;
            tooltip.style.top = `${mouseY + offset}px`;

            // Adjust if tooltip goes off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (tooltipRect.right > viewportWidth) {
                tooltip.style.left = `${mouseX - tooltipRect.width - offset}px`;
            }
            if (tooltipRect.bottom > viewportHeight) {
                tooltip.style.top = `${mouseY - tooltipRect.height - offset}px`;
            }

            tooltip.classList.add('visible');
        }

        function updateInfoPanel(node) {
            const panel = document.getElementById('info-panel');
            const idEl = document.getElementById('info-panel-id');
            const titleEl = document.getElementById('info-panel-task-title');
            const metaEl = document.getElementById('info-panel-meta');
            const descEl = document.getElementById('info-panel-description');
            const descSection = document.getElementById('info-panel-description-section');
            const depsSection = document.getElementById('info-panel-deps-section');
            const depsList = document.getElementById('info-panel-deps');
            const closedSection = document.getElementById('info-panel-closed-section');
            const closedReason = document.getElementById('info-panel-closed-reason');
            const typeTitleEl = document.getElementById('info-panel-type-title');
            const relationshipsSection = document.getElementById('info-panel-relationships-section');
            const relationshipsList = document.getElementById('info-panel-relationships');
            const timestampsSection = document.getElementById('info-panel-timestamps-section');
            const timestampsList = document.getElementById('info-panel-timestamps');

            if (!node) {
                panel.classList.remove('visible');
                return;
            }

            // Find full task data
            const task = state.tasks.find(t => t.id === node.id);
            if (!task) return;

            // Update header title based on node type
            const typeLabels = {
                'task': 'Task Details',
                'bug': 'Bug Details',
                'idea': 'Idea Details',
                'milestone': 'Milestone Details',
                'queue': 'Queue Details',
                'agent': 'Agent Details'
            };
            typeTitleEl.textContent = typeLabels[task.type] || 'Task Details';

            // Update panel content
            idEl.textContent = task.id;
            titleEl.textContent = task.title;

            // Show short_name if set (after title)
            const shortNameEl = document.getElementById('info-panel-short-name');
            const shortNameRow = document.getElementById('info-panel-short-name-row');
            if (task.short_name) {
                shortNameEl.textContent = task.short_name;
                shortNameRow.style.display = 'block';
            } else {
                shortNameRow.style.display = 'none';
            }

            // Build metadata badges
            metaEl.innerHTML = `
                <span class="badge badge-priority-${task.priority}">P${task.priority}</span>
                <span class="badge badge-status-${task.status}">${task.status}</span>
                ${task.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
            `;

            // Description
            if (task.description) {
                descEl.textContent = task.description;
                descEl.classList.remove('empty');
                descSection.style.display = 'block';
            } else {
                descEl.textContent = 'No description provided';
                descEl.classList.add('empty');
                descSection.style.display = 'block';
            }

            // Dependencies - now clickable
            if (task.depends_on && task.depends_on.length > 0) {
                depsList.innerHTML = task.depends_on.map(depId => {
                    const depTask = state.tasks.find(t => t.id === depId);
                    const depTitle = depTask ? ` â€” ${escapeHtml(depTask.title)}` : '';
                    return `<li><span class="info-panel-node-link" data-node-id="${escapeHtml(depId)}">${escapeHtml(depId)}</span>${depTitle}</li>`;
                }).join('');
                depsSection.style.display = 'block';
            } else {
                depsSection.style.display = 'none';
            }

            // Relationships - show all edges connected to this node (excluding depends_on which are shown above)
            const nodeEdges = (state.edges || []).filter(edge => 
                (edge.source === task.id || edge.target === task.id) && edge.edge_type !== 'depends_on'
            );
            if (nodeEdges.length > 0) {
                relationshipsList.innerHTML = nodeEdges.map(edge => {
                    const isOutbound = edge.source === task.id;
                    const relatedId = isOutbound ? edge.target : edge.source;
                    const relatedTask = state.tasks.find(t => t.id === relatedId);
                    const relatedTitle = relatedTask ? escapeHtml(relatedTask.title) : '';
                    const direction = isOutbound ? 'â†’' : 'â†';
                    const edgeTypeName = EDGE_TYPES[edge.edge_type]?.name || edge.edge_type;
                    return `<li>
                        <span class="info-panel-edge-type">${escapeHtml(edgeTypeName)}</span>
                        <span class="info-panel-edge-direction">${direction}</span>
                        <span class="info-panel-node-link" data-node-id="${escapeHtml(relatedId)}">${escapeHtml(relatedId)}</span>
                        ${relatedTitle ? `<span style="color: var(--text-secondary)">â€” ${relatedTitle}</span>` : ''}
                    </li>`;
                }).join('');
                relationshipsSection.style.display = 'block';
            } else {
                relationshipsSection.style.display = 'none';
            }

            // Closed reason
            if (task.status === 'done' && task.closed_reason) {
                closedReason.textContent = task.closed_reason;
                closedSection.style.display = 'block';
            } else {
                closedSection.style.display = 'none';
            }

            // Timestamps
            const formatTimestamp = (ts) => {
                if (!ts) return null;
                const date = new Date(ts);
                return date.toLocaleDateString(undefined, { 
                    year: 'numeric', month: 'short', day: 'numeric',
                    hour: '2-digit', minute: '2-digit'
                });
            };
            const created = formatTimestamp(task.created_at);
            const updated = formatTimestamp(task.updated_at);
            const closed = formatTimestamp(task.closed_at);
            
            if (created || updated || closed) {
                let html = '';
                if (created) html += `<dt>Created:</dt><dd>${escapeHtml(created)}</dd>`;
                if (updated && updated !== created) html += `<dt>Updated:</dt><dd>${escapeHtml(updated)}</dd>`;
                if (closed) html += `<dt>Closed:</dt><dd>${escapeHtml(closed)}</dd>`;
                timestampsList.innerHTML = html;
                timestampsSection.style.display = 'block';
            } else {
                timestampsSection.style.display = 'none';
            }

            // Queue toggle - only show for tasks/bugs that can be queued
            const queueSection = document.getElementById('info-panel-queue-section');
            const queueToggle = document.getElementById('queue-toggle-btn');
            const canBeQueued = task.type === 'task' || task.type === 'bug' || !task.type;
            const isCompleted = task.status === 'done' || task.status === 'cancelled' || task.status === 'discarded';
            
            if (canBeQueued && !isCompleted) {
                queueSection.style.display = 'flex';
                const isQueued = isNodeQueued(task.id);
                queueToggle.classList.toggle('active', isQueued);
                queueToggle.title = isQueued ? 'Remove from queue' : 'Add to queue';
            } else {
                queueSection.style.display = 'none';
            }

            // Show panel
            panel.classList.add('visible');
        }

        // Handle clicks on node links in info panel
        document.getElementById('info-panel').addEventListener('click', (e) => {
            const link = e.target.closest('.info-panel-node-link');
            if (link) {
                const nodeId = link.dataset.nodeId;
                if (nodeId) {
                    // Find and select the node
                    const targetNode = state.graph.nodes.find(n => n.id === nodeId);
                    if (targetNode) {
                        state.graph.selectedNode = targetNode;
                        updateInfoPanel(targetNode);
                        panToNode(nodeId);
                    }
                }
            }
        });

        // Info panel close button
        document.getElementById('info-panel-close').addEventListener('click', () => {
            state.graph.selectedNode = null;
            updateInfoPanel(null);
        });

        // Edge info panel functions
        function updateEdgeInfoPanel(edge) {
            const panel = document.getElementById('edge-info-panel');
            
            if (!edge) {
                panel.classList.remove('visible');
                return;
            }

            // Hide node info panel when showing edge info
            document.getElementById('info-panel').classList.remove('visible');
            state.graph.selectedNode = null;

            // Get full edge data from state.edges
            const fullEdge = state.edges.find(e => 
                e.source === edge.from && e.target === edge.to && e.edge_type === edge.edge_type
            );

            // Get edge style for color
            const style = getEdgeStyle(edge.edge_type);
            
            // Update type with color indicator
            document.getElementById('edge-info-color').style.backgroundColor = style.color;
            document.getElementById('edge-info-type-name').textContent = getEdgeTypeName(edge.edge_type);

            // Find source and target task info
            const sourceTask = state.tasks.find(t => t.id === edge.from);
            const targetTask = state.tasks.find(t => t.id === edge.to);

            // Update connection info
            document.getElementById('edge-info-source-id').textContent = edge.from;
            document.getElementById('edge-info-source-title').textContent = sourceTask?.title || 'Unknown';
            document.getElementById('edge-info-target-id').textContent = edge.to;
            document.getElementById('edge-info-target-title').textContent = targetTask?.title || 'Unknown';

            // Show/hide reason section
            const reasonSection = document.getElementById('edge-info-reason-section');
            const reasonEl = document.getElementById('edge-info-reason');
            if (edge.reason || fullEdge?.reason) {
                reasonEl.textContent = edge.reason || fullEdge.reason;
                reasonSection.style.display = 'block';
            } else {
                reasonSection.style.display = 'none';
            }

            // Show created date if available
            const dateEl = document.getElementById('edge-info-date');
            if (fullEdge && fullEdge.created_at) {
                const date = new Date(fullEdge.created_at);
                dateEl.textContent = `Created: ${date.toLocaleDateString()} ${date.toLocaleTimeString()}`;
                dateEl.style.display = 'block';
            } else {
                dateEl.style.display = 'none';
            }

            // Show panel
            panel.classList.add('visible');
            
            // Store selected edge
            state.graph.selectedEdge = edge;
        }

        // Edge info panel close button
        document.getElementById('edge-info-close').addEventListener('click', () => {
            state.graph.selectedEdge = null;
            updateEdgeInfoPanel(null);
        });

        // Queue toggle button click handler
        document.getElementById('queue-toggle-btn').addEventListener('click', async () => {
            const selectedNode = state.graph.selectedNode;
            if (!selectedNode) return;

            const queueToggle = document.getElementById('queue-toggle-btn');
            queueToggle.disabled = true;

            try {
                const response = await fetch('/api/queue/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ node_id: selectedNode.id })
                });

                const result = await response.json();
                
                if (result.success) {
                    const isQueued = result.queued;
                    queueToggle.classList.toggle('active', isQueued);
                    queueToggle.title = isQueued ? 'Remove from queue' : 'Add to queue';
                    showToast(result.message, 'success');
                    // Refresh data to update edges and visual state
                    await loadData();
                } else {
                    showToast(result.error || 'Failed to toggle queue', 'error');
                }
            } catch (err) {
                showToast('Failed to toggle queue: ' + err.message, 'error');
            } finally {
                queueToggle.disabled = false;
            }
        });

        // Coordinate transformation functions
        function screenToWorld(screenX, screenY, canvas) {
            const { panX, panY, zoom } = state.graph.viewport;
            return {
                x: (screenX - canvas.width / 2) / zoom - panX,
                y: (screenY - canvas.height / 2) / zoom - panY
            };
        }

        function worldToScreen(worldX, worldY, canvas) {
            const { panX, panY, zoom } = state.graph.viewport;
            return {
                x: (worldX + panX) * zoom + canvas.width / 2,
                y: (worldY + panY) * zoom + canvas.height / 2
            };
        }

        /**
         * Build a set of "active" node IDs - nodes that are not in a completed state.
         * Active nodes include: pending, in_progress, blocked, reopened statuses.
         * For ideas: seed, germinating are active; promoted, discarded are not.
         */
        function buildActiveNodeSet() {
            const activeStatuses = ['pending', 'in_progress', 'blocked', 'reopened'];
            const activeIdeaStatuses = ['seed', 'germinating'];

            const activeNodes = new Set();

            state.tasks.forEach(task => {
                let isActive = false;

                if (task.type === 'idea') {
                    isActive = activeIdeaStatuses.includes(task.status);
                } else {
                    isActive = activeStatuses.includes(task.status);
                }

                if (isActive) {
                    activeNodes.add(task.id);
                }
            });

            return activeNodes;
        }

        /**
         * Check if a node is in an "active chain" - meaning it's either:
         * 1. An active node itself, OR
         * 2. Connected (transitively through edges) to an active node
         *
         * This allows completed nodes to remain visible if they're part of
         * a dependency chain with work that's still in progress.
         */
        function isInActiveChain(nodeId, activeNodes, edges) {
            // If the node itself is active, it's in an active chain
            if (activeNodes.has(nodeId)) {
                return true;
            }

            // Build adjacency list for traversal (both directions)
            const adjacency = new Map();
            edges.forEach(edge => {
                if (!adjacency.has(edge.from)) {
                    adjacency.set(edge.from, []);
                }
                if (!adjacency.has(edge.to)) {
                    adjacency.set(edge.to, []);
                }
                // Add bidirectional edges for traversal
                adjacency.get(edge.from).push(edge.to);
                adjacency.get(edge.to).push(edge.from);
            });

            // BFS to check if we can reach any active node from this node
            const visited = new Set();
            const queue = [nodeId];
            visited.add(nodeId);

            while (queue.length > 0) {
                const current = queue.shift();

                // If we reached an active node, this node is in an active chain
                if (activeNodes.has(current)) {
                    return true;
                }

                // Explore neighbors
                const neighbors = adjacency.get(current) || [];
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push(neighbor);
                    }
                }
            }

            return false;
        }

        /**
         * Calculate the length of the chain that contains a node.
         * Chain length = total number of unique nodes reachable through edges from this node
         * (including the node itself).
         */
        function getChainLength(nodeId, adjacency) {
            const visited = new Set();
            const queue = [nodeId];
            visited.add(nodeId);

            while (queue.length > 0) {
                const current = queue.shift();
                const neighbors = adjacency.get(current) || [];
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push(neighbor);
                    }
                }
            }

            return visited.size;
        }

        /**
         * Build adjacency list for chain length calculations.
         * Uses ALL edges regardless of visibility filters to correctly calculate
         * actual dependency chain lengths.
         */
        function buildChainAdjacency(edges) {
            const adjacency = new Map();

            edges.forEach(edge => {
                if (!adjacency.has(edge.from)) {
                    adjacency.set(edge.from, []);
                }
                if (!adjacency.has(edge.to)) {
                    adjacency.set(edge.to, []);
                }
                // Add bidirectional edges for traversal
                adjacency.get(edge.from).push(edge.to);
                adjacency.get(edge.to).push(edge.from);
            });

            return adjacency;
        }

        /**
         * Time window (in ms) for showing recently completed nodes before they fade out completely.
         */
        const RECENTLY_COMPLETED_WINDOW_MS = 5 * 60 * 1000; // 5 minutes

        /**
         * Check if a node was completed recently (within RECENTLY_COMPLETED_WINDOW_MS).
         * Returns the age in ms if recently completed, or null if not.
         */
        function getCompletedAge(node) {
            if (!node.closed_at) return null;
            const closedTime = new Date(node.closed_at).getTime();
            const now = Date.now();
            const age = now - closedTime;
            return age < RECENTLY_COMPLETED_WINDOW_MS ? age : null;
        }

        /**
         * Calculate opacity for a recently completed node based on age.
         * Returns 1.0 for just-completed nodes, fading to 0.3 at the 5-minute mark.
         */
        function getRecentlyCompletedOpacity(node) {
            const age = getCompletedAge(node);
            if (age === null) return 1.0;  // Not recently completed
            // Linear fade from 1.0 (age=0) to 0.3 (age=5min)
            const progress = age / RECENTLY_COMPLETED_WINDOW_MS;
            return 1.0 - (0.7 * progress);
        }

        /**
         * Filter nodes based on hideCompleted setting.
         * Returns array of nodes that should be visible.
         *
         * When hideCompleted is true:
         * - Hide nodes with status 'done' or 'cancelled'
         * - EXCEPT those in active dependency chains
         * - EXCEPT those completed within the last 5 minutes (shown with fade-out)
         */
        function getVisibleNodes(nodes) {
            // If hideCompleted is not enabled, start with all nodes
            let visible = nodes;

            if (state.graph.hideCompleted) {
                // Build active node set and prepare edges for chain detection
                const activeNodes = buildActiveNodeSet();
                const edges = state.graph.edges;

                // Filter nodes: keep if not completed, or if in active chain, or if recently completed
                visible = nodes.filter(node => {
                    const isCompleted = node.status === 'done' || node.status === 'cancelled';

                    // If not completed, always show it
                    if (!isCompleted) {
                        return true;
                    }

                    // If recently completed (within 5 min), show it with fade effect
                    if (getCompletedAge(node) !== null) {
                        return true;
                    }

                    // If completed, only show if it's in an active chain
                    return isInActiveChain(node.id, activeNodes, edges);
                });
            }

            // Apply chain length filter if enabled (minChainLength > 1)
            if (state.graph.minChainLength > 1) {
                const adjacency = buildChainAdjacency(state.graph.edges);

                // Only keep nodes whose chain length meets the minimum
                visible = visible.filter(node => {
                    const chainLen = getChainLength(node.id, adjacency);
                    return chainLen >= state.graph.minChainLength;
                });
            }

            // Note: Search no longer hides nodes - non-matching nodes are dimmed instead
            // See drawNode() for dimming logic
            return visible;
        }

        function buildGraphData() {
            // Build a map of existing node positions to preserve them on reload
            const existingNodes = new Map();
            state.graph.nodes.forEach(node => {
                existingNodes.set(node.id, { x: node.x, y: node.y });
            });

            // Convert tasks to nodes - preserve positions or place in circular layout
            state.graph.nodes = state.tasks.map((task, index) => {
                const existing = existingNodes.get(task.id);

                if (existing) {
                    // Preserve existing position, but reset velocity to prevent oscillation
                    return {
                        id: task.id,
                        title: task.title,
                        short_name: task.short_name,
                        status: task.status,
                        priority: task.priority,
                        type: task.type || 'task',
                        closed_at: task.closed_at,  // Track when node was completed for fade-out
                        x: existing.x,
                        y: existing.y,
                        vx: 0,
                        vy: 0,
                        radius: 30
                    };
                } else {
                    // New node - place in circular layout in world space
                    const totalNodes = state.tasks.length;
                    const angle = (index / totalNodes) * 2 * Math.PI;
                    const radius = 300; // Initial radius in world units

                    return {
                        id: task.id,
                        title: task.title,
                        short_name: task.short_name,
                        status: task.status,
                        priority: task.priority,
                        type: task.type || 'task',
                        closed_at: task.closed_at,  // Track when node was completed for fade-out
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius,
                        vx: 0,
                        vy: 0,
                        radius: 30  // Node radius in world units
                    };
                }
            });

            // Build edges from API data with edge type metadata
            state.graph.edges = (state.edges || []).map(edge => ({
                from: edge.source,
                to: edge.target,
                edge_type: edge.edge_type,
                bidirectional: edge.bidirectional,
                reason: edge.reason
            }));
        }

        function animateGraph() {
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');
            const { nodes, edges, physics } = state.graph;

            // Update canvas size if window was resized
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }

            // Update animation time for continuous effects
            state.graph.animationTime = performance.now();

            // Update camera pan animation if active
            updatePanAnimation();

            // Clear canvas
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Filter nodes based on hideCompleted + search setting
            const visibleNodes = getVisibleNodes(nodes);
            const visibleNodeIds = new Set(visibleNodes.map(n => n.id));
            state.graph.visibleNodes = visibleNodes;
            state.graph.visibleNodeIds = visibleNodeIds;

            if (visibleNodes.length === 0) {
                renderEmptyState(ctx, 'No matching nodes');
                if (state.currentView === 'graph') {
                    requestAnimationFrame(animateGraph);
                }
                return;
            }

            // Apply forces (circular gravity system) - only to visible nodes
            applyCircularGravity(visibleNodes, physics);
            applyRepulsionForces(visibleNodes, physics);
            applyEdgeAttraction(visibleNodes, edges, physics);
            updatePositions(visibleNodes, physics, canvas);

            // Continuous follow: track the followed node as it moves
            updateContinuousFollow(canvas);

            // Draw edges (filtered by edge type visibility and node visibility)
            edges.forEach(edge => {
                // Skip edges that are filtered out by type
                if (!state.edgeFilters[edge.edge_type]) return;

                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);

                // Skip edges where either endpoint is hidden
                if (!fromNode || !toNode || !visibleNodeIds.has(edge.from) || !visibleNodeIds.has(edge.to)) {
                    return;
                }

                const style = getEdgeStyle(edge.edge_type);
                drawArrow(ctx, fromNode.x, fromNode.y, toNode.x, toNode.y, canvas, fromNode.radius, toNode.radius, style, edge.bidirectional);
            });

            // Draw visible nodes only
            visibleNodes.forEach(node => {
                drawNode(ctx, node, canvas);
            });

            if (state.currentView === 'graph') {
                requestAnimationFrame(animateGraph);
            }
        }

        function applyCircularGravity(nodes, physics) {
            const draggedNode = state.graph.draggedNode;
            const { gravityCenter, gravityStrength } = physics;

            nodes.forEach(node => {
                // Don't apply forces to dragged nodes
                if (node === draggedNode) return;

                const dx = gravityCenter.x - node.x;
                const dy = gravityCenter.y - node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    const force = gravityStrength;
                    node.vx += (dx / distance) * force;
                    node.vy += (dy / distance) * force;
                }
            });
        }

        function applyEdgeAttraction(nodes, edges, physics) {
            if (!physics.edgeAttractionEnabled) return;

            const draggedNode = state.graph.draggedNode;
            const { springStrength, springRestingLength } = physics;

            edges.forEach(edge => {
                // Skip edges with springiness disabled
                const edgeType = edge.edge_type;
                if (edgeType && !state.edgeSpringFilters[edgeType]) return;

                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                if (!fromNode || !toNode) return;

                // Don't apply to dragged nodes
                if (fromNode === draggedNode && toNode === draggedNode) return;

                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance === 0) return;

                // Bidirectional spring force: applies when compressed OR extended
                // Force increases linearly with deviation from resting length
                const deviation = distance - springRestingLength;
                const force = springStrength * deviation;

                // Spring pulls toward resting length:
                // - If compressed (distance < resting): deviation is negative, pushes apart
                // - If extended (distance > resting): deviation is positive, pulls together
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;

                if (fromNode !== draggedNode) {
                    fromNode.vx += fx;
                    fromNode.vy += fy;
                }
                if (toNode !== draggedNode) {
                    toNode.vx -= fx;
                    toNode.vy -= fy;
                }
            });
        }

        function applyRepulsionForces(nodes, physics) {
            const draggedNode = state.graph.draggedNode;

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const n1 = nodes[i];
                    const n2 = nodes[j];
                    const dx = n2.x - n1.x;
                    const dy = n2.y - n1.y;
                    const distanceSq = dx * dx + dy * dy;
                    if (distanceSq === 0) continue;

                    const force = physics.repulsionStrength / distanceSq;
                    const distance = Math.sqrt(distanceSq);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;

                    // Don't apply forces to dragged nodes
                    if (n1 !== draggedNode) {
                        n1.vx -= fx;
                        n1.vy -= fy;
                    }
                    if (n2 !== draggedNode) {
                        n2.vx += fx;
                        n2.vy += fy;
                    }
                }
            }
        }

        function updatePositions(nodes, physics, canvas) {
            const draggedNode = state.graph.draggedNode;
            const { damping, maxVelocity } = physics;

            nodes.forEach(node => {
                // Freeze dragged node
                if (node === draggedNode) {
                    node.vx = 0;
                    node.vy = 0;
                    return;
                }

                // Apply damping
                node.vx *= damping;
                node.vy *= damping;

                // Cap velocity to prevent extreme speeds
                const speed = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
                if (speed > maxVelocity) {
                    node.vx = (node.vx / speed) * maxVelocity;
                    node.vy = (node.vy / speed) * maxVelocity;
                }

                // Update position (NO BOUNDARY CLAMPING for infinite canvas)
                node.x += node.vx;
                node.y += node.vy;
            });
        }

        // Format node label with word wrap and truncation
        // Returns array of lines (max 2 lines, max 8 chars per line)
        // NOTE: Uses string length (UTF-16 code units), not grapheme clusters.
        // Emoji/complex Unicode may appear shorter visually than their length suggests.
        function formatNodeLabel(text, maxCharsPerLine = 8, maxLines = 2) {
            if (!text) return [];

            const maxTotal = maxCharsPerLine * maxLines;

            // If text fits on one line, return early
            if (text.length <= maxCharsPerLine) {
                return [text];
            }

            // Truncate if too long overall (with ellipsis)
            if (text.length > maxTotal) {
                text = text.substring(0, maxTotal - 1) + 'â€¦';
            }

            const lines = [];
            let remaining = text;

            while (remaining.length > 0 && lines.length < maxLines) {
                if (remaining.length <= maxCharsPerLine) {
                    lines.push(remaining);
                    break;
                }

                // Try to break at a reasonable point (space, hyphen, underscore)
                let breakPoint = maxCharsPerLine;
                for (let i = maxCharsPerLine - 1; i >= Math.floor(maxCharsPerLine / 2); i--) {
                    if (remaining[i] === ' ' || remaining[i] === '-' || remaining[i] === '_') {
                        breakPoint = i + 1;
                        break;
                    }
                }

                lines.push(remaining.substring(0, breakPoint).trim());
                remaining = remaining.substring(breakPoint).trim();
            }

            return lines;
        }

        // Draw a hexagon path centered at (cx, cy) with the given radius
        function drawHexagonPath(ctx, cx, cy, radius) {
            const sides = 6;
            const angleOffset = Math.PI / 6; // Rotate 30 degrees so flat side is at bottom
            ctx.moveTo(
                cx + radius * Math.cos(angleOffset),
                cy + radius * Math.sin(angleOffset)
            );
            for (let i = 1; i <= sides; i++) {
                const angle = angleOffset + (i * 2 * Math.PI / sides);
                ctx.lineTo(
                    cx + radius * Math.cos(angle),
                    cy + radius * Math.sin(angle)
                );
            }
            ctx.closePath();
        }

        // Draw a diamond (rhombus) path centered at (cx, cy) with the given radius
        function drawDiamondPath(ctx, cx, cy, radius) {
            ctx.moveTo(cx, cy - radius);       // Top
            ctx.lineTo(cx + radius, cy);       // Right
            ctx.lineTo(cx, cy + radius);       // Bottom
            ctx.lineTo(cx - radius, cy);       // Left
            ctx.closePath();
        }

        // Draw a square path centered at (cx, cy) with the given radius (half-side length)
        function drawSquarePath(ctx, cx, cy, radius) {
            ctx.moveTo(cx - radius, cy - radius);  // Top-left
            ctx.lineTo(cx + radius, cy - radius);  // Top-right
            ctx.lineTo(cx + radius, cy + radius);  // Bottom-right
            ctx.lineTo(cx - radius, cy + radius);  // Bottom-left
            ctx.closePath();
        }

        // Draw a cloud/bubble path centered at (cx, cy) with the given radius
        // Uses overlapping circles to create a puffy cloud shape
        function drawCloudPath(ctx, cx, cy, radius) {
            // Classic cloud shape: a main body with overlapping circular bumps
            // Draw using bezier curves for smooth transitions between bumps
            const w = radius * 1.1;  // Width scale
            const h = radius * 0.75;  // Height scale (slightly flattened)
            
            ctx.moveTo(cx - w, cy + h * 0.3);
            
            // Bottom edge (flat-ish base)
            ctx.quadraticCurveTo(cx - w * 0.5, cy + h * 0.5, cx, cy + h * 0.4);
            ctx.quadraticCurveTo(cx + w * 0.5, cy + h * 0.5, cx + w, cy + h * 0.3);
            
            // Right bump
            ctx.quadraticCurveTo(cx + w * 1.2, cy, cx + w * 0.9, cy - h * 0.3);
            
            // Top-right bump  
            ctx.quadraticCurveTo(cx + w * 0.8, cy - h * 0.8, cx + w * 0.3, cy - h * 0.7);
            
            // Top middle bump (main puffy top)
            ctx.quadraticCurveTo(cx + w * 0.1, cy - h * 1.0, cx - w * 0.2, cy - h * 0.75);
            
            // Top-left bump
            ctx.quadraticCurveTo(cx - w * 0.6, cy - h * 0.9, cx - w * 0.8, cy - h * 0.4);
            
            // Left bump (back to start)
            ctx.quadraticCurveTo(cx - w * 1.2, cy, cx - w, cy + h * 0.3);
            
            ctx.closePath();
        }

        // Check if a node is in the queue (has a 'queued' edge to a queue node)
        function isNodeQueued(nodeId) {
            // Check state.edges (API data) directly, not state.graph.edges
            // state.graph.edges is only populated when the graph view is rendered
            return (state.edges || []).some(edge => 
                edge.source === nodeId && edge.edge_type === 'queued'
            );
        }

        function drawNode(ctx, node, canvas) {
            const isHovered = node === state.graph.hoveredNode;
            const isDragging = node === state.graph.draggedNode;
            const isSelected = node === state.graph.selectedNode;
            
            // Check if node matches current highlight filter
            const matchesFilter = nodeMatchesFilter(node);
            const highlightDimmed = state.graph.highlightFilter && !matchesFilter;
            
            // Check if node matches current search query (dim non-matching instead of hiding)
            const normalizedQuery = normalizeSearchQuery(state.graph.searchQuery);
            const matchesSearch = nodeMatchesSearch(node, normalizedQuery);
            const searchDimmed = normalizedQuery && !matchesSearch;
            
            // Node is dimmed if either filter or search doesn't match
            const isDimmed = highlightDimmed || searchDimmed;

            // Transform world coordinates to screen coordinates
            const screenPos = worldToScreen(node.x, node.y, canvas);
            const zoom = state.graph.viewport.zoom;
            const radius = node.radius * zoom;

            // Node colors based on status
            const colors = {
                'pending': '#5bc0de',
                'in_progress': '#f0ad4e',
                'blocked': '#d9534f',
                'done': '#5cb85c'
            };
            
            // Bug colors (reddish tones) - use CSS variables
            const bugColors = {
                'pending': '#e07878',      // --bug-pending
                'in_progress': '#d95050',  // --bug-in-progress
                'blocked': '#b33a3a',      // --bug-blocked
                'done': '#8fbc8f'          // --bug-done
            };
            
            // Idea colors (deeper purple) - use CSS variables
            const ideaColors = {
                'pending': '#8b5fc9',      // --idea-pending
                'in_progress': '#7a4db8',  // --idea-in-progress
                'blocked': '#5c3a8a',      // --idea-blocked
                'done': '#8fbc8f'          // --idea-done
            };
            
            // Queue color (teal) - queues don't have status, always same color
            const queueColor = '#20b2aa';  // --queue-color
            
            // Agent colors (cyan/electric blue) - based on agent status
            const agentColors = {
                'active': '#00d4ff',       // Bright cyan for active
                'idle': '#6bb3c9',         // Muted cyan for idle
                'stale': '#4a6670'         // Dark gray-blue for stale
            };
            
            // Select color palette based on node type
            let colorPalette = colors;
            let color;
            if (node.type === 'queue') {
                color = queueColor;
            } else if (node.type === 'bug') {
                colorPalette = bugColors;
                color = colorPalette[node.status] || '#4a90e2';
            } else if (node.type === 'idea') {
                colorPalette = ideaColors;
                color = colorPalette[node.status] || '#4a90e2';
            } else if (node.type === 'agent') {
                colorPalette = agentColors;
                color = colorPalette[node.status] || '#00d4ff';
            } else {
                color = colorPalette[node.status] || '#4a90e2';
            }
            
            // Apply dimming for filtered-out nodes, and fade-out for recently completed nodes
            let opacity = 1.0;
            if (isDimmed) {
                opacity = 0.3;
            } else {
                // Apply fade-out effect for recently completed nodes (when hideCompleted is on)
                const isCompleted = node.status === 'done' || node.status === 'cancelled';
                if (state.graph.hideCompleted && isCompleted) {
                    opacity = getRecentlyCompletedOpacity(node);
                }
            }
            ctx.globalAlpha = opacity;

            // Draw selection highlight (persistent)
            if (isSelected) {
                ctx.beginPath();
                if (node.type === 'queue') {
                    drawHexagonPath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else if (node.type === 'agent') {
                    drawDiamondPath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 10 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 10 * zoom, 0, Math.PI * 2);
                }
                ctx.strokeStyle = '#f0ad4e';
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.fillStyle = 'rgba(240, 173, 78, 0.15)';
                ctx.fill();
            }

            // Draw drag highlight (active)
            if (isDragging) {
                ctx.beginPath();
                if (node.type === 'queue') {
                    drawHexagonPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'agent') {
                    drawDiamondPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 8 * zoom, 0, Math.PI * 2);
                }
                ctx.fillStyle = 'rgba(74, 144, 226, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            // Draw hover highlight
            else if (isHovered) {
                ctx.beginPath();
                if (node.type === 'queue') {
                    drawHexagonPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'agent') {
                    drawDiamondPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 8 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 8 * zoom, 0, Math.PI * 2);
                }
                ctx.fillStyle = 'rgba(74, 144, 226, 0.2)';
                ctx.fill();
                ctx.strokeStyle = '#6aa8f0';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // Draw queued indicator (teal glow for tasks in the queue)
            const isQueued = node.type !== 'queue' && node.type !== 'agent' && isNodeQueued(node.id);
            if (isQueued) {
                ctx.beginPath();
                if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 6 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 6 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 6 * zoom, 0, Math.PI * 2);
                }
                ctx.strokeStyle = '#20b2aa';  // --queue-color
                ctx.lineWidth = 3;
                ctx.stroke();
                // Add subtle glow effect
                ctx.beginPath();
                if (node.type === 'bug') {
                    drawSquarePath(ctx, screenPos.x, screenPos.y, radius + 4 * zoom);
                } else if (node.type === 'idea') {
                    drawCloudPath(ctx, screenPos.x, screenPos.y, radius + 4 * zoom);
                } else {
                    ctx.arc(screenPos.x, screenPos.y, radius + 4 * zoom, 0, Math.PI * 2);
                }
                ctx.fillStyle = 'rgba(32, 178, 170, 0.15)';  // --queue-color with transparency
                ctx.fill();
            }

            // Draw active task indicator: counter-rotating hatched rings (Ghost in the Shell style)
            // Only for in_progress tasks/bugs/ideas (not queues/agents)
            if (node.status === 'in_progress' && node.type !== 'queue' && node.type !== 'agent') {
                const animTime = state.graph.animationTime;
                const rotationSpeed = 0.001; // radians per ms
                const outerRingRadius = radius + 14 * zoom;
                const innerRingRadius = radius + 8 * zoom;
                const ringWidth = 2.5 * zoom;
                const hatchCount = 12;
                const hatchLength = Math.PI / 18; // Arc length of each hatch
                
                // Outer ring - rotates clockwise
                ctx.save();
                ctx.translate(screenPos.x, screenPos.y);
                ctx.rotate(animTime * rotationSpeed);
                ctx.strokeStyle = 'rgba(240, 173, 78, 0.8)'; // Orange-amber like in_progress color
                ctx.lineWidth = ringWidth;
                ctx.lineCap = 'round';
                for (let i = 0; i < hatchCount; i++) {
                    const startAngle = (i * Math.PI * 2) / hatchCount;
                    ctx.beginPath();
                    ctx.arc(0, 0, outerRingRadius, startAngle, startAngle + hatchLength);
                    ctx.stroke();
                }
                ctx.restore();
                
                // Inner ring - rotates counter-clockwise
                ctx.save();
                ctx.translate(screenPos.x, screenPos.y);
                ctx.rotate(-animTime * rotationSpeed * 1.5); // Faster and opposite direction
                ctx.strokeStyle = 'rgba(255, 200, 100, 0.6)'; // Lighter orange-gold
                ctx.lineWidth = ringWidth * 0.8;
                ctx.lineCap = 'round';
                for (let i = 0; i < hatchCount; i++) {
                    const startAngle = (i * Math.PI * 2) / hatchCount + Math.PI / hatchCount; // Offset from outer ring
                    ctx.beginPath();
                    ctx.arc(0, 0, innerRingRadius, startAngle, startAngle + hatchLength * 0.8);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // Draw node shape (hexagon for queue, diamond for agent, square for bug, cloud for idea, circle for others)
            ctx.beginPath();
            if (node.type === 'queue') {
                drawHexagonPath(ctx, screenPos.x, screenPos.y, radius);
            } else if (node.type === 'agent') {
                drawDiamondPath(ctx, screenPos.x, screenPos.y, radius);
            } else if (node.type === 'bug') {
                drawSquarePath(ctx, screenPos.x, screenPos.y, radius);
            } else if (node.type === 'idea') {
                drawCloudPath(ctx, screenPos.x, screenPos.y, radius);
            } else {
                ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
            }
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = (isHovered || isDragging) ? '#ffffff' : '#e8edf3';
            ctx.lineWidth = (isHovered || isDragging) ? 3 : 2;
            ctx.stroke();

            // Draw text - show short_name if set, with task ID below in smaller font
            ctx.fillStyle = '#1a2332';
            const baseFontSize = 12 * Math.max(0.8, Math.min(1.5, zoom));
            const smallFontSize = baseFontSize * 0.75;
            ctx.textAlign = 'center';

            if (node.short_name) {
                // Format short_name with word wrap
                const labelLines = formatNodeLabel(node.short_name, 8, 2);
                const lineHeight = baseFontSize * 1.2;
                
                // Calculate total height for centering
                const totalLines = labelLines.length + 1; // +1 for ID below
                const totalHeight = (totalLines - 1) * lineHeight;
                const startY = screenPos.y - totalHeight / 2 + baseFontSize / 2;
                
                // Draw short_name lines
                ctx.font = (isHovered || isDragging) ? `bold ${baseFontSize}px sans-serif` : `${baseFontSize}px sans-serif`;
                ctx.textBaseline = 'middle';
                labelLines.forEach((line, i) => {
                    ctx.fillText(line, screenPos.x, startY + i * lineHeight);
                });
                
                // Draw task ID below in smaller font
                ctx.font = `${smallFontSize}px sans-serif`;
                ctx.fillStyle = 'rgba(26, 35, 50, 0.7)';
                ctx.fillText(node.id, screenPos.x, startY + labelLines.length * lineHeight);
            } else {
                // No short_name - just show task ID centered
                ctx.font = (isHovered || isDragging) ? `bold ${baseFontSize}px sans-serif` : `${baseFontSize}px sans-serif`;
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id, screenPos.x, screenPos.y);
            }
            
            // Reset globalAlpha after drawing
            ctx.globalAlpha = 1.0;
        }

        // Get edge style based on edge type
        function getEdgeStyle(edgeType) {
            const styles = getComputedStyle(document.documentElement);
            switch (edgeType) {
                case 'depends_on':
                case 'blocks':
                    return {
                        color: styles.getPropertyValue('--edge-blocking').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
                case 'related_to':
                case 'caused_by':
                case 'duplicates':
                case 'supersedes':
                    return {
                        color: styles.getPropertyValue('--edge-informational').trim(),
                        dashed: true,
                        lineWidth: 1.5
                    };
                case 'fixes':
                case 'tests':
                    return {
                        color: styles.getPropertyValue('--edge-fixes').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
                case 'parent_of':
                case 'child_of':
                    return {
                        color: styles.getPropertyValue('--edge-hierarchy').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
                case 'queued':
                    return {
                        color: styles.getPropertyValue('--edge-queued').trim(),
                        dashed: true,
                        lineWidth: 2
                    };
                case 'working_on':
                    return {
                        color: styles.getPropertyValue('--edge-agent').trim() || '#00d4ff',
                        dashed: false,
                        lineWidth: 3  // Thicker to stand out
                    };
                default:
                    return {
                        color: styles.getPropertyValue('--edge-default').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
            }
        }

        function drawArrow(ctx, x1, y1, x2, y2, canvas, fromRadius = 30, toRadius = 30, style = null, bidirectional = false) {
            // Calculate the angle of the line
            const dx = x2 - x1;
            const dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            const distance = Math.sqrt(dx * dx + dy * dy);

            // If nodes are overlapping, skip drawing
            if (distance < fromRadius + toRadius) return;

            // Calculate start point at edge of fromNode
            const startX = x1 + Math.cos(angle) * fromRadius;
            const startY = y1 + Math.sin(angle) * fromRadius;

            // Calculate end point at edge of toNode
            const endX = x2 - Math.cos(angle) * toRadius;
            const endY = y2 - Math.sin(angle) * toRadius;

            // Transform to screen coordinates
            const p1 = worldToScreen(startX, startY, canvas);
            const p2 = worldToScreen(endX, endY, canvas);

            // Apply style
            const defaultStyle = { color: getComputedStyle(document.documentElement).getPropertyValue('--edge-default').trim(), dashed: false, lineWidth: 2 };
            const edgeStyle = style || defaultStyle;
            ctx.strokeStyle = edgeStyle.color;
            ctx.fillStyle = edgeStyle.color;
            ctx.lineWidth = edgeStyle.lineWidth * state.graph.viewport.zoom;

            // Set dash pattern for informational edges
            if (edgeStyle.dashed) {
                ctx.setLineDash([6, 4]);
            } else {
                ctx.setLineDash([]);
            }

            // Calculate midpoint for arrow head
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;

            const headLength = 10 * state.graph.viewport.zoom;
            const screenAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

            // Draw line from start to end
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();

            // Reset dash pattern for arrow heads
            ctx.setLineDash([]);

            // Arrow head at midpoint (pointing from source to target)
            ctx.beginPath();
            ctx.moveTo(midX, midY);
            ctx.lineTo(
                midX - headLength * Math.cos(screenAngle - Math.PI / 6),
                midY - headLength * Math.sin(screenAngle - Math.PI / 6)
            );
            ctx.lineTo(
                midX - headLength * Math.cos(screenAngle + Math.PI / 6),
                midY - headLength * Math.sin(screenAngle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();

            // Draw second arrow head for bidirectional edges (pointing from target to source)
            if (bidirectional) {
                const reverseAngle = screenAngle + Math.PI;
                ctx.beginPath();
                ctx.moveTo(midX, midY);
                ctx.lineTo(
                    midX - headLength * Math.cos(reverseAngle - Math.PI / 6),
                    midY - headLength * Math.sin(reverseAngle - Math.PI / 6)
                );
                ctx.lineTo(
                    midX - headLength * Math.cos(reverseAngle + Math.PI / 6),
                    midY - headLength * Math.sin(reverseAngle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fill();
            }
        }

        function renderReady() {
            const list = document.getElementById('ready-list');
            if (state.ready.length === 0) {
                list.innerHTML = '<div class="empty-state">No ready tasks</div>';
                return;
            }
            list.innerHTML = state.ready.map(task => {
                const isQueued = isNodeQueued(task.id);
                return `
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">${escapeHtml(task.title)}</div>
                        <button class="card-queue-toggle ${isQueued ? 'active' : ''}" 
                                data-task-id="${task.id}" 
                                title="${isQueued ? 'Remove from queue' : 'Add to queue'}">
                        </button>
                    </div>
                    <div class="card-meta">
                        <span class="badge badge-priority-${task.priority}">P${task.priority}</span>
                        <span class="badge" style="background: var(--bg-tertiary)">${task.id}</span>
                        ${task.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
                    </div>
                </div>
            `}).join('');
            
            // Attach event handlers to queue toggle buttons
            list.querySelectorAll('.card-queue-toggle').forEach(btn => {
                btn.addEventListener('click', handleCardQueueToggle);
            });
        }

        function renderIdeas() {
            const list = document.getElementById('ideas-list');
            // Filter to show only open ideas (seed or germinating)
            const openIdeas = state.ideas.filter(idea => 
                idea.status === 'seed' || idea.status === 'germinating'
            );
            if (openIdeas.length === 0) {
                list.innerHTML = '<div class="empty-state">No open ideas</div>';
                return;
            }
            list.innerHTML = openIdeas.map(idea => {
                const isQueued = isNodeQueued(idea.id);
                const statusLabel = idea.status === 'seed' ? 'ðŸŒ± Seed' : 'ðŸŒ¿ Germinating';
                return `
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">${escapeHtml(idea.title)}</div>
                        <button class="card-queue-toggle ${isQueued ? 'active' : ''}" 
                                data-task-id="${idea.id}" 
                                title="${isQueued ? 'Remove from queue' : 'Add to queue'}">
                        </button>
                    </div>
                    ${idea.description ? `<div class="card-description">${escapeHtml(idea.description)}</div>` : ''}
                    <div class="card-meta">
                        <span class="badge" style="background: var(--idea-${idea.status})">${statusLabel}</span>
                        <span class="badge" style="background: var(--bg-tertiary)">${idea.id}</span>
                        ${(idea.tags || []).map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
                    </div>
                </div>
            `}).join('');
            
            // Attach event handlers to queue toggle buttons
            list.querySelectorAll('.card-queue-toggle').forEach(btn => {
                btn.addEventListener('click', handleCardQueueToggle);
            });
        }

        async function handleCardQueueToggle(event) {
            event.stopPropagation();
            const btn = event.currentTarget;
            const taskId = btn.dataset.taskId;
            
            btn.disabled = true;
            
            try {
                const response = await fetch('/api/queue/toggle', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ node_id: taskId })
                });

                const result = await response.json();
                
                if (result.success) {
                    const isQueued = result.queued;
                    btn.classList.toggle('active', isQueued);
                    btn.title = isQueued ? 'Remove from queue' : 'Add to queue';
                    showToast(result.message, 'success');
                    // Refresh data to update edges and visual state
                    await loadData();
                } else {
                    showToast(result.error || 'Failed to toggle queue', 'error');
                }
            } catch (err) {
                showToast('Failed to toggle queue: ' + err.message, 'error');
            } finally {
                btn.disabled = false;
            }
        }

        function renderTests() {
            const list = document.getElementById('test-list');
            if (state.tests.length === 0) {
                list.innerHTML = '<div class="empty-state">No tests configured</div>';
                return;
            }
            list.innerHTML = state.tests.map(test => `
                <div class="card">
                    <div class="card-title">${escapeHtml(test.name)}</div>
                    <div class="card-meta">
                        <span class="badge" style="background: var(--bg-tertiary)">${test.id}</span>
                        <span class="badge ${test.last_status === 'passed' ? 'badge-status-done' : 'badge-status-blocked'}">
                            ${test.last_status || 'Not run'}
                        </span>
                    </div>
                </div>
            `).join('');
        }

        function renderAgents() {
            const list = document.getElementById('agents-list');
            const activityLog = document.getElementById('agents-activity-log');
            
            if (!state.agents || state.agents.length === 0) {
                list.innerHTML = '<div class="empty-state">No agents registered</div>';
                activityLog.innerHTML = '<div class="empty-state">No agent activity</div>';
                return;
            }
            list.innerHTML = state.agents.map(agent => {
                const startedAt = new Date(agent.started_at).toLocaleString();
                const lastActivity = new Date(agent.last_activity_at).toLocaleString();
                const tasksHtml = agent.tasks && agent.tasks.length > 0 
                    ? agent.tasks.map(t => `<span class="task-id">${escapeHtml(t)}</span>`).join(', ')
                    : '<span class="no-tasks">No active tasks</span>';
                const purposeHtml = agent.purpose 
                    ? `<div class="agent-purpose">${escapeHtml(agent.purpose)}</div>` 
                    : `<div class="agent-purpose agent-type-label">${escapeHtml(agent.agent_type || 'worker')} agent</div>`;
                return `
                <div class="card agent-card">
                    <button class="terminate-btn" onclick="showTerminateModal(${agent.pid}, '${escapeHtml(agent.name).replace(/'/g, "\\'")}', '${tasksHtml.replace(/'/g, "\\'")}')">âœ• Terminate</button>
                    <div class="agent-name">${escapeHtml(agent.name)}</div>
                    ${purposeHtml}
                    <div class="agent-pid">PID: ${agent.pid}</div>
                    <div class="card-meta">
                        <span class="badge badge-agent-${agent.status}">${agent.status}</span>
                    </div>
                    <div class="agent-tasks">Tasks: ${tasksHtml}</div>
                    <div class="agent-stats">
                        <span>ðŸ“Š ${agent.command_count} commands</span>
                        <span>ðŸ• Started: ${startedAt}</span>
                    </div>
                    <div class="agent-stats">
                        <span>â±ï¸ Last active: ${lastActivity}</span>
                    </div>
                </div>
            `}).join('');
            
            // Render recent agent-related activity from the log
            const agentNames = new Set(state.agents.map(a => a.name));
            const agentActivity = (state.log || [])
                .filter(entry => {
                    // Filter for agent-related entries based on command field
                    const command = entry.command || entry.action || entry.message || '';
                    return command.includes('agent') || 
                           command === 'hello' || 
                           command === 'goodbye' ||
                           command === 'orient' ||
                           command === 'task update' ||
                           command === 'task close' ||
                           command === 'bug update' ||
                           command === 'bug close';
                })
                .slice(0, 20);
            
            if (agentActivity.length === 0) {
                activityLog.innerHTML = '<div class="empty-state">No recent agent activity</div>';
            } else {
                activityLog.innerHTML = agentActivity.map(entry => {
                    const time = new Date(entry.timestamp).toLocaleTimeString();
                    const formatted = formatLogEntry(entry);
                    const statusIcon = entry.success === false ? 'âŒ' : 'âœ“';
                    return `
                        <div class="activity-entry ${entry.success === false ? 'activity-error' : ''}">
                            <span class="activity-time">${time}</span>
                            <span class="activity-status">${statusIcon}</span>
                            <span class="activity-action">${escapeHtml(formatted.action)}</span>
                            ${formatted.details ? `<span class="activity-details">${escapeHtml(formatted.details)}</span>` : ''}
                        </div>
                    `;
                }).join('');
            }
        }

        // Agent termination modal functions
        let terminatingPid = null;

        function showTerminateModal(pid, name, tasks) {
            terminatingPid = pid;
            const modal = document.getElementById('terminate-modal');
            const info = document.getElementById('modal-agent-info');
            info.innerHTML = `
                <div class="agent-name">${escapeHtml(name)}</div>
                <div class="agent-detail">PID: ${pid}</div>
                <div class="agent-detail">Tasks: ${tasks}</div>
            `;
            modal.style.display = 'flex';
            document.getElementById('confirm-terminate-btn').onclick = confirmTerminate;
        }

        function closeTerminateModal() {
            terminatingPid = null;
            document.getElementById('terminate-modal').style.display = 'none';
        }

        async function confirmTerminate() {
            if (!terminatingPid) return;
            const pid = terminatingPid;
            closeTerminateModal();
            
            try {
                const response = await fetch(`/api/agents/${pid}/kill`, { method: 'POST' });
                const result = await response.json();
                if (response.ok) {
                    showToast(result.message, 'success');
                    await loadData(); // Refresh the agents list
                } else {
                    showToast(`Failed to terminate agent: ${result.message || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                showToast(`Failed to terminate agent: ${error}`, 'error');
            }
        }

        // Agent Detail Modal functions (for graph node double-click)
        let detailAgentPid = null;

        function showAgentDetailModal(agent) {
            detailAgentPid = agent.pid;
            const modal = document.getElementById('agent-detail-modal');
            
            // Populate modal content
            document.getElementById('agent-modal-name').textContent = agent.name;
            document.getElementById('agent-modal-pid').textContent = `PID: ${agent.pid}`;
            
            // Status badge
            const statusBadge = document.getElementById('agent-modal-status-badge');
            statusBadge.textContent = agent.status;
            statusBadge.className = `badge badge-agent-${agent.status}`;
            
            // Purpose
            const purposeSection = document.getElementById('agent-modal-purpose-section');
            const purposeEl = document.getElementById('agent-modal-purpose');
            if (agent.purpose) {
                purposeEl.textContent = agent.purpose;
                purposeSection.style.display = 'block';
            } else {
                purposeEl.textContent = 'Not registered - use bn orient --register "purpose"';
                purposeEl.style.fontStyle = 'italic';
                purposeSection.style.display = 'block';
            }
            
            // Statistics
            document.getElementById('agent-modal-command-count').textContent = agent.command_count || 0;
            document.getElementById('agent-modal-task-count').textContent = (agent.tasks || []).length;
            
            // Tasks
            const tasksSection = document.getElementById('agent-modal-tasks-section');
            const tasksEl = document.getElementById('agent-modal-tasks');
            if (agent.tasks && agent.tasks.length > 0) {
                tasksEl.innerHTML = agent.tasks.map(t => 
                    `<span class="agent-detail-task-id">${escapeHtml(t)}</span>`
                ).join('');
                tasksSection.style.display = 'block';
            } else {
                tasksSection.style.display = 'none';
            }
            
            // Timeline
            document.getElementById('agent-modal-started').textContent = 
                `ðŸ• Started: ${new Date(agent.started_at).toLocaleString()}`;
            document.getElementById('agent-modal-last-activity').textContent = 
                `â±ï¸ Last active: ${new Date(agent.last_activity_at).toLocaleString()}`;
            
            // Set up terminate button
            document.getElementById('agent-modal-terminate-btn').onclick = () => {
                closeAgentDetailModal();
                const tasksHtml = agent.tasks && agent.tasks.length > 0 
                    ? agent.tasks.map(t => `<span class="task-id">${escapeHtml(t)}</span>`).join(', ')
                    : 'None';
                showTerminateModal(agent.pid, agent.name, tasksHtml);
            };
            
            modal.style.display = 'flex';
        }

        function closeAgentDetailModal() {
            detailAgentPid = null;
            document.getElementById('agent-detail-modal').style.display = 'none';
        }

        // Close modal when clicking outside content
        document.getElementById('agent-detail-modal').addEventListener('click', (e) => {
            if (e.target.id === 'agent-detail-modal') {
                closeAgentDetailModal();
            }
        });

        function renderLog() {
            const list = document.getElementById('log-list');
            if (state.log.length === 0) {
                list.innerHTML = '<div class="empty-state">No activity yet</div>';
                return;
            }
            list.innerHTML = state.log.slice(0, 50).map(entry => {
                const formatted = formatLogEntry(entry);
                const statusClass = entry.success === false ? 'log-error' : '';
                return `
                    <div class="card log-entry ${statusClass}">
                        <div class="log-header">
                            <div class="log-time">${new Date(entry.timestamp).toLocaleString()}</div>
                            ${entry.user ? `<div class="log-user">ðŸ‘¤ ${escapeHtml(entry.user)}</div>` : ''}
                        </div>
                        <div class="card-title">${escapeHtml(formatted.action)}</div>
                        ${formatted.details ? `<div class="log-details">${escapeHtml(formatted.details)}</div>` : ''}
                        ${entry.success === false && entry.error ? `<div class="log-error-msg">âŒ ${escapeHtml(entry.error)}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        // Format a log entry into a human-readable action and details
        function formatLogEntry(entry) {
            const command = entry.command || entry.action || entry.message || 'unknown';
            const args = entry.args || {};
            
            // Build a human-readable action description
            let action = command;
            let details = '';
            
            switch (command) {
                case 'task create':
                    action = `Created task`;
                    details = args.title || '';
                    break;
                case 'task update':
                    action = `Updated task ${args.id || ''}`;
                    const updates = [];
                    if (args.status) updates.push(`status â†’ ${args.status}`);
                    if (args.priority !== null && args.priority !== undefined) updates.push(`priority â†’ ${args.priority}`);
                    if (args.title) updates.push(`title changed`);
                    details = updates.join(', ');
                    break;
                case 'task close':
                    action = `Closed task ${args.id || ''}`;
                    details = args.reason || '';
                    break;
                case 'task delete':
                    action = `Deleted task ${args.id || ''}`;
                    break;
                case 'bug create':
                    action = `Created bug`;
                    details = args.title || '';
                    break;
                case 'bug update':
                    action = `Updated bug ${args.id || ''}`;
                    const bugUpdates = [];
                    if (args.status) bugUpdates.push(`status â†’ ${args.status}`);
                    if (args.severity) bugUpdates.push(`severity â†’ ${args.severity}`);
                    details = bugUpdates.join(', ');
                    break;
                case 'bug close':
                    action = `Closed bug ${args.id || ''}`;
                    details = args.reason || '';
                    break;
                case 'idea create':
                    action = `Created idea`;
                    details = args.title || '';
                    break;
                case 'link add':
                    action = `Linked ${args.source || ''} â†’ ${args.target || ''}`;
                    details = args.edge_type ? `(${args.edge_type})` : '';
                    break;
                case 'link rm':
                    action = `Unlinked ${args.source || ''} from ${args.target || ''}`;
                    break;
                case 'orient':
                    action = `Agent oriented`;
                    break;
                case 'ready':
                    action = `Checked ready tasks`;
                    break;
                case 'hello':
                    action = `Agent started`;
                    details = args.purpose || '';
                    break;
                case 'goodbye':
                    action = `Agent finished`;
                    details = args.reason || args.summary || '';
                    break;
                case 'test run':
                    action = `Ran tests`;
                    details = args.id || (args.all ? 'all tests' : '');
                    break;
                default:
                    // For other commands, just show command with first meaningful arg
                    if (args.id) {
                        action = `${command} ${args.id}`;
                    }
                    break;
            }
            
            // Look up entity titles if we have an ID reference
            const entityId = args.id || args.task_id;
            if (entityId && !details) {
                const entity = findEntityById(entityId);
                if (entity && entity.title) {
                    details = entity.title;
                }
            }
            
            return { action, details };
        }
        
        // Find an entity (task, bug, idea) by ID
        function findEntityById(id) {
            if (!id) return null;
            const allEntities = [...(state.tasks || []), ...(state.bugs || []), ...(state.ideas || [])];
            return allEntities.find(e => e.id === id);
        }

        function renderEmptyState(ctx, message) {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(message, ctx.canvas.width / 2, ctx.canvas.height / 2);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Edge filter UI functions
        function getEdgeCategoryColor(category) {
            const styles = getComputedStyle(document.documentElement);
            switch (category) {
                case 'blocking': return styles.getPropertyValue('--edge-blocking').trim();
                case 'informational': return styles.getPropertyValue('--edge-informational').trim();
                case 'fixes': return styles.getPropertyValue('--edge-fixes').trim();
                case 'hierarchy': return styles.getPropertyValue('--edge-hierarchy').trim();
                case 'queued': return styles.getPropertyValue('--edge-queued').trim();
                default: return styles.getPropertyValue('--edge-default').trim();
            }
        }

        function initializeEdgeFilters() {
            const container = document.getElementById('edge-filter-group');
            const dropdownBtn = document.getElementById('edge-filters-btn');
            const filtersPanel = document.getElementById('edge-filters');
            
            // Create filter buttons for each edge type
            container.innerHTML = '';
            
            // Add "All" toggle button first
            const allBtn = document.createElement('button');
            allBtn.className = 'edge-filter-btn edge-filter-all';
            allBtn.textContent = 'All';
            allBtn.title = 'Toggle all edge types';
            
            const updateAllBtnState = () => {
                const allActive = Object.keys(EDGE_TYPES).every(type => state.edgeFilters[type]);
                allBtn.classList.toggle('active', allActive);
            };
            
            // Update spring button enabled state based on visibility
            const updateSpringBtnState = (springBtn, type) => {
                const isVisible = state.edgeFilters[type];
                springBtn.disabled = !isVisible;
                if (!isVisible) {
                    springBtn.title = `Enable ${EDGE_TYPES[type].name} visibility first`;
                } else {
                    springBtn.title = state.edgeSpringFilters[type] 
                        ? `Disable spring physics for ${EDGE_TYPES[type].name} edges`
                        : `Enable spring physics for ${EDGE_TYPES[type].name} edges`;
                }
            };
            
            allBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const allActive = Object.keys(EDGE_TYPES).every(type => state.edgeFilters[type]);
                const newState = !allActive;
                
                for (const type of Object.keys(EDGE_TYPES)) {
                    state.edgeFilters[type] = newState;
                }
                
                // Update all button states
                container.querySelectorAll('.edge-filter-btn[data-edge-type]').forEach(btn => {
                    btn.classList.toggle('active', newState);
                });
                // Update all spring button states
                container.querySelectorAll('.edge-spring-btn').forEach(springBtn => {
                    const type = springBtn.dataset.edgeType;
                    if (type) updateSpringBtnState(springBtn, type);
                });
                updateAllBtnState();
                saveEdgeFilters(state.edgeFilters);
            });
            
            container.appendChild(allBtn);
            
            for (const [type, info] of Object.entries(EDGE_TYPES)) {
                // Create row container for filter and spring buttons
                const row = document.createElement('div');
                row.className = 'edge-filter-row';
                
                const btn = document.createElement('button');
                btn.className = 'edge-filter-btn' + (state.edgeFilters[type] ? ' active' : '');
                btn.dataset.edgeType = type;
                btn.title = `Toggle ${info.name} edges`;
                
                const dot = document.createElement('span');
                dot.className = 'edge-filter-dot';
                dot.style.backgroundColor = getEdgeCategoryColor(info.category);
                
                btn.appendChild(dot);
                btn.appendChild(document.createTextNode(info.name));
                
                // Create spring toggle button
                const springBtn = document.createElement('button');
                springBtn.className = 'edge-spring-btn' + (state.edgeSpringFilters[type] ? ' active' : '');
                springBtn.dataset.edgeType = type;
                springBtn.innerHTML = 'ðŸ§²';  // Magnet emoji for springiness
                updateSpringBtnState(springBtn, type);
                
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    state.edgeFilters[type] = !state.edgeFilters[type];
                    btn.classList.toggle('active', state.edgeFilters[type]);
                    updateSpringBtnState(springBtn, type);
                    updateAllBtnState();
                    saveEdgeFilters(state.edgeFilters);
                });
                
                springBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!state.edgeFilters[type]) return; // Can't toggle spring if edge not visible
                    state.edgeSpringFilters[type] = !state.edgeSpringFilters[type];
                    springBtn.classList.toggle('active', state.edgeSpringFilters[type]);
                    updateSpringBtnState(springBtn, type);
                    saveEdgeSpringFilters(state.edgeSpringFilters);
                });
                
                row.appendChild(btn);
                row.appendChild(springBtn);
                container.appendChild(row);
            }
            
            updateAllBtnState();
            
            // Toggle dropdown open/close
            dropdownBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                filtersPanel.classList.toggle('open');
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!filtersPanel.contains(e.target)) {
                    filtersPanel.classList.remove('open');
                }
            });
        }

        // Global escape key handler to close modals
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                // Close terminate modal if open
                const terminateModal = document.getElementById('terminate-modal');
                if (terminateModal && terminateModal.style.display !== 'none') {
                    closeTerminateModal();
                    e.preventDefault();
                    return;
                }
                // Close edge info panel if open
                const edgeInfoPanel = document.getElementById('edge-info-panel');
                if (edgeInfoPanel && edgeInfoPanel.classList.contains('visible')) {
                    state.graph.selectedEdge = null;
                    updateEdgeInfoPanel(null);
                    e.preventDefault();
                    return;
                }
                // Close edge filters dropdown if open
                const edgeFilters = document.querySelector('.edge-filters.open');
                if (edgeFilters) {
                    edgeFilters.classList.remove('open');
                    e.preventDefault();
                }
            }
        });

        // Jump to queue button click handler
        document.getElementById('jump-queue-btn').addEventListener('click', () => {
            const queueNode = state.tasks.find(t => t.type === 'queue');
            if (queueNode) {
                panToNode(queueNode.id, true);  // Zoom to 100%
            }
        });

        // Initialize
        initializeEdgeFilters();
        initializeStatFilters();
        updateAutoFollowDisplay();
        updateHideCompletedDisplay();
        initializeGraphSearch();
        connectWebSocket();
    </script>
</body>
</html>
