<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binnacle - Project State Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #1a2332;
            --bg-secondary: #243447;
            --bg-tertiary: #2d4059;
            --text-primary: #e8edf3;
            --text-secondary: #b8c5d6;
            --accent-blue: #4a90e2;
            --accent-light: #6aa8f0;
            --border-color: #3a4d66;
            --success: #5cb85c;
            --warning: #f0ad4e;
            --danger: #d9534f;
            --info: #5bc0de;
            /* Edge type colors */
            --edge-blocking: #e85d5d;
            --edge-informational: #7a8fa3;
            --edge-fixes: #5cb85c;
            --edge-hierarchy: #9b6ed8;
            --edge-default: #3a4d66;
            /* Node type colors - bugs (reddish) */
            --bug-pending: #e07878;
            --bug-in-progress: #d95050;
            --bug-blocked: #b33a3a;
            --bug-done: #8fbc8f;
            /* Node type colors - ideas (deeper purple) */
            --idea-pending: #8b5fc9;
            --idea-in-progress: #7a4db8;
            --idea-blocked: #5c3a8a;
            --idea-done: #8fbc8f;
            /* Overlay backgrounds */
            --overlay-bg: rgba(0, 0, 0, 0.85);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            background: var(--bg-secondary);
            padding: 1rem 2rem;
            border-bottom: 2px solid var(--border-color);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .header-left {
            flex: 1;
        }

        .active-task-pane {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            min-width: 280px;
            max-width: 400px;
            margin-left: 1rem;
            transition: all 0.3s ease;
        }

        .active-task-pane.empty {
            opacity: 0.5;
        }

        .active-task-pane-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .active-task-pane-header .indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--warning);
            animation: pulse 2s ease-in-out infinite;
        }

        .active-task-pane.empty .indicator {
            background: var(--text-secondary);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .active-task-id {
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--accent-light);
            margin-bottom: 0.25rem;
        }

        .active-task-title {
            font-size: 0.95rem;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .active-task-meta {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .active-task-meta .badge {
            font-size: 0.75rem;
            padding: 0.15rem 0.5rem;
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 600;
            color: var(--accent-light);
        }

        .subtitle {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        nav {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }

        .nav-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
        }

        .nav-btn:hover {
            background: var(--accent-blue);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.3);
        }

        .nav-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-light);
        }

        main {
            flex: 1;
            overflow: auto;
            padding: 2rem;
        }

        .view {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .view.active {
            display: block;
        }

        #graph-view {
            position: relative;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        #graph-canvas {
            width: 100%;
            height: calc(100vh - 200px);
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .task-list, .test-list, .log-list {
            display: grid;
            gap: 1rem;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        }

        .card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1.5rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            border-color: var(--accent-blue);
        }

        .card-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .card-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.75rem;
        }

        .badge {
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .badge-priority-0 { background: var(--danger); color: white; }
        .badge-priority-1 { background: var(--warning); color: white; }
        .badge-priority-2 { background: var(--info); color: white; }
        .badge-priority-3 { background: var(--success); color: white; }

        .badge-status-pending { background: var(--info); color: white; }
        .badge-status-in_progress { background: var(--warning); color: white; }
        .badge-status-blocked { background: var(--danger); color: white; }
        .badge-status-done { background: var(--success); color: white; }

        .badge-tag {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }

        .log-entry {
            padding: 1rem;
            border-left: 3px solid var(--accent-blue);
        }

        .log-time {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .connection-status {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            padding: 0.5rem 1rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-connected { background: var(--success); }
        .status-disconnected { background: var(--danger); animation: none; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-secondary);
        }

        .empty-state svg {
            width: 64px;
            height: 64px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        .node-tooltip {
            position: fixed;
            background: var(--overlay-bg);
            color: var(--text-primary);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .node-tooltip.visible {
            display: block;
        }

        .graph-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 0.5rem;
            z-index: 100;
            align-items: center;
            justify-content: flex-end;
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            max-width: calc(100vw - 250px);
        }

        .zoom-buttons {
            display: flex;
            flex-direction: row;
            gap: 0.5rem;
            align-items: center;
            flex-shrink: 0;
        }

        .graph-search {
            height: 32px;
            width: 180px;
            padding: 0 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .graph-search::placeholder {
            color: var(--text-secondary);
        }

        .graph-search:focus {
            outline: none;
            border-color: var(--accent-light);
            box-shadow: 0 0 0 2px rgba(106, 168, 240, 0.2);
        }

        /* Auto-follow toggle */
        .auto-follow-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-right: 0.25rem;
            padding-right: 0.5rem;
            border-right: 1px solid var(--border-color);
        }

        .auto-follow-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .auto-follow-switch {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .auto-follow-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            transition: transform 0.2s ease;
        }

        .auto-follow-switch.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .auto-follow-switch.active::after {
            transform: translateX(14px);
        }

        /* Hide completed toggle */
        .hide-completed-toggle {
            display: flex;
            align-items: center;
            gap: 0.4rem;
            margin-right: 0.25rem;
            padding-right: 0.5rem;
            border-right: 1px solid var(--border-color);
        }

        .hide-completed-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .hide-completed-switch {
            width: 32px;
            height: 18px;
            border-radius: 9px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            cursor: pointer;
            position: relative;
            transition: background 0.2s ease, border-color 0.2s ease;
            padding: 0;
        }

        .hide-completed-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: white;
            transition: transform 0.2s ease;
        }

        .hide-completed-switch.active {
            background: #22c55e;
            border-color: #22c55e;
        }

        .hide-completed-switch.active::after {
            transform: translateX(14px);
        }

        /* Edge filter dropdown */
        .edge-filters {
            position: relative;
        }

        .edge-filters-btn {
            padding: 0.4rem 0.75rem;
            font-size: 0.8rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.4rem;
            transition: all 0.2s ease;
        }

        .edge-filters-btn:hover {
            border-color: var(--accent-blue);
            color: var(--text-primary);
        }

        .edge-filters-btn .arrow {
            font-size: 0.6rem;
            transition: transform 0.2s ease;
        }

        .edge-filters.open .edge-filters-btn .arrow {
            transform: rotate(180deg);
        }

        .edge-filters-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 0.25rem;
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.5rem;
            z-index: 200;
            display: none;
            flex-direction: column;
            gap: 0.25rem;
            min-width: 140px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .edge-filters.open .edge-filters-dropdown {
            display: flex;
        }

        .edge-filter-btn {
            padding: 0.35rem 0.5rem;
            font-size: 0.75rem;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.3rem;
            width: 100%;
        }

        .edge-filter-btn:hover {
            border-color: var(--accent-blue);
        }

        .edge-filter-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-light);
            color: white;
        }

        .edge-filter-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .edge-filter-all {
            font-weight: 600;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0.25rem;
            padding-bottom: 0.5rem;
        }

        .graph-filters {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0.5rem;
            z-index: 100;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .stats-overlay {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .stats-overlay .stat-group {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            margin: -0.25rem -0.5rem;
            border-radius: 4px;
            transition: background-color 0.2s ease;
        }

        .stats-overlay .stat-group:hover {
            background-color: var(--bg-tertiary);
        }

        .stats-overlay .stat-group.active {
            background-color: var(--accent-blue);
            color: var(--text-primary);
        }

        .stats-overlay .stat-separator {
            color: var(--border-color);
            font-weight: 300;
        }

        .stats-overlay .stat-detail {
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: var(--accent-blue);
        }

        .zoom-level {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.35rem 0.5rem;
            font-size: 0.8rem;
            text-align: center;
            color: var(--text-secondary);
            min-width: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tooltip-title {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.5rem;
            color: var(--accent-light);
        }

        .tooltip-id {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-family: monospace;
            margin-bottom: 0.5rem;
        }

        .tooltip-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }

        /* Edge tooltip styles */
        .edge-tooltip {
            position: fixed;
            background: var(--overlay-bg);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            pointer-events: none;
            z-index: 1000;
            max-width: 280px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            display: none;
            font-size: 0.9rem;
        }

        .edge-tooltip.visible {
            display: block;
        }

        .edge-tooltip-type {
            font-weight: 600;
            margin-bottom: 0.4rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .edge-tooltip-type .edge-color-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .edge-tooltip-ids {
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.4rem;
        }

        .edge-tooltip-reason {
            font-style: italic;
            color: var(--text-secondary);
            margin-top: 0.4rem;
            padding-top: 0.4rem;
            border-top: 1px solid var(--border-color);
        }

        .edge-tooltip-date {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 0.3rem;
        }

        #graph-canvas {
            cursor: default;
        }

        #graph-canvas.hovering:not(.dragging) {
            cursor: grab;
        }

        #graph-canvas.dragging {
            cursor: grabbing;
        }

        .info-panel {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 320px;
            max-height: calc(100% - 2rem);
            background: var(--overlay-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            overflow-y: auto;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .info-panel.visible {
            opacity: 1;
            visibility: visible;
        }

        .info-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border-color);
        }

        .info-panel-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .info-panel-close {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            line-height: 1;
            transition: color 0.2s ease;
        }

        .info-panel-close:hover {
            color: var(--text-primary);
        }

        .info-panel-id {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--accent-light);
            margin-bottom: 0.5rem;
        }

        .info-panel-task-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }

        .info-panel-short-name-row {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .info-panel-label {
            font-weight: 500;
            margin-right: 0.5rem;
        }

        .info-panel-short-name {
            color: var(--accent-light);
        }

        .info-panel-meta {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-bottom: 1rem;
        }

        .info-panel-section {
            margin-bottom: 1rem;
        }

        .info-panel-section-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.5rem;
        }

        .info-panel-description {
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .info-panel-description.empty {
            color: var(--text-secondary);
            font-style: italic;
        }

        .info-panel-deps {
            list-style: none;
        }

        .info-panel-deps li {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--accent-light);
            padding: 0.25rem 0;
        }

        .info-panel-deps li:before {
            content: "‚Üí ";
            color: var(--text-secondary);
        }

        .info-panel-closed-reason {
            font-size: 0.95rem;
            color: var(--text-primary);
            line-height: 1.6;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            border-left: 3px solid var(--success);
        }

        /* Toast Notification System */
        .toast-container {
            position: fixed;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            pointer-events: none;
        }

        .toast {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            padding-right: 2.5rem;
            min-width: 280px;
            max-width: 450px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 0.75rem;
            pointer-events: auto;
            animation: toastSlideIn 0.3s ease;
            position: relative;
        }

        .toast.toast-exit {
            animation: toastSlideOut 0.3s ease forwards;
        }

        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes toastSlideOut {
            from {
                opacity: 1;
                transform: translateY(0);
            }
            to {
                opacity: 0;
                transform: translateY(-20px);
            }
        }

        .toast-icon {
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .toast-message {
            flex: 1;
            font-size: 0.9rem;
            color: var(--text-primary);
            line-height: 1.4;
        }

        .toast-close {
            position: absolute;
            top: 50%;
            right: 0.5rem;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem;
            font-size: 1rem;
            line-height: 1;
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }

        .toast-close:hover {
            opacity: 1;
        }

        /* Toast type-specific styles with colored tints */
        .toast-success {
            border-left: 4px solid var(--success);
            background: linear-gradient(90deg, rgba(92, 184, 92, 0.15), var(--bg-secondary) 30%);
        }

        .toast-success .toast-icon {
            color: var(--success);
        }

        .toast-error {
            border-left: 4px solid var(--danger);
            background: linear-gradient(90deg, rgba(217, 83, 79, 0.15), var(--bg-secondary) 30%);
        }

        .toast-error .toast-icon {
            color: var(--danger);
        }

        .toast-warning {
            border-left: 4px solid var(--warning);
            background: linear-gradient(90deg, rgba(240, 173, 78, 0.15), var(--bg-secondary) 30%);
        }

        .toast-warning .toast-icon {
            color: var(--warning);
        }

        .toast-info {
            border-left: 4px solid var(--info);
            background: linear-gradient(90deg, rgba(91, 192, 222, 0.15), var(--bg-secondary) 30%);
        }

        .toast-info .toast-icon {
            color: var(--info);
        }

        /* Responsive layout for graph overlays */
        @media (max-width: 1200px) {
            .graph-controls {
                max-width: calc(100vw - 300px);
            }
        }

        @media (max-width: 900px) {
            .graph-controls {
                max-width: calc(100vw - 200px);
            }
            .graph-search {
                width: 140px;
            }
        }

        @media (max-width: 700px) {
            .graph-controls {
                max-width: calc(100vw - 2rem);
                flex-direction: column;
                align-items: stretch;
            }
            .graph-filters {
                left: 1rem;
                right: 1rem;
                top: auto;
                bottom: 1rem;
            }
            .graph-search {
                width: 100%;
            }
            .hide-completed-toggle,
            .auto-follow-toggle {
                border-right: none;
                padding-right: 0;
                margin-right: 0;
                justify-content: space-between;
            }
            .zoom-buttons {
                justify-content: center;
            }
        }

    </style>
</head>
<body>
    <!-- Toast notification container -->
    <div class="toast-container" id="toast-container"></div>

    <div class="container">
        <header>
            <div class="header-left">
                <h1>üß≠ Binnacle</h1>
                <p class="subtitle">Project State Tracker</p>
                <nav>
                    <button class="nav-btn active" data-view="graph">Graph</button>
                    <button class="nav-btn" data-view="ready">Ready Tasks</button>
                    <button class="nav-btn" data-view="tests">Tests</button>
                    <button class="nav-btn" data-view="log">Activity Log</button>
                </nav>
            </div>
            <div class="active-task-pane empty" id="active-task-pane">
                <div class="active-task-pane-header">
                    <span class="indicator"></span>
                    <span>Active Task</span>
                </div>
                <div class="active-task-id" id="active-task-id">No active task</div>
                <div class="active-task-title" id="active-task-title"></div>
                <div class="active-task-meta" id="active-task-meta"></div>
            </div>
        </header>

        <main>
            <div id="graph-view" class="view active">
                <canvas id="graph-canvas"></canvas>
                <div class="graph-filters">
                    <div class="stats-overlay" id="stats-overlay">
                        <span class="stat-group" id="stat-bugs">üêõ 0 bugs</span>
                        <span class="stat-separator">|</span>
                        <span class="stat-group" id="stat-blocked">‚ùå 0 blocked</span>
                        <span class="stat-separator">|</span>
                        <span class="stat-group" id="stat-ready">‚úÖ 0 ready</span>
                        <span class="stat-separator">|</span>
                        <span class="stat-group" id="stat-ideas">üí≠ 0 ideas</span>
                        <span class="stat-separator">|</span>
                        <span class="stat-group" id="stat-milestones">üèÅ 0 milestones</span>
                    </div>
                    <div class="edge-filters" id="edge-filters">
                        <button class="edge-filters-btn" id="edge-filters-btn">
                            <span>Edge Types</span>
                            <span class="arrow">‚ñº</span>
                        </button>
                        <div class="edge-filters-dropdown" id="edge-filter-group">
                            <!-- Filter buttons will be populated dynamically -->
                        </div>
                    </div>
                </div>
                <div class="node-tooltip" id="node-tooltip">
                    <div class="tooltip-title" id="tooltip-title"></div>
                    <div class="tooltip-id" id="tooltip-id"></div>
                    <div class="tooltip-meta" id="tooltip-meta"></div>
                </div>
                <div class="edge-tooltip" id="edge-tooltip">
                    <div class="edge-tooltip-type" id="edge-tooltip-type"></div>
                    <div class="edge-tooltip-ids" id="edge-tooltip-ids"></div>
                    <div class="edge-tooltip-reason" id="edge-tooltip-reason"></div>
                    <div class="edge-tooltip-date" id="edge-tooltip-date"></div>
                </div>
                <div class="graph-controls">
                    <input class="graph-search" id="graph-search" type="text" placeholder="Search nodes‚Ä¶" autocomplete="off" spellcheck="false" />
                    <div class="hide-completed-toggle">
                        <span class="hide-completed-label">Hide completed</span>
                        <button class="hide-completed-switch" id="hide-completed-switch" title="Hide completed nodes (except in active chains)"></button>
                    </div>
                    <div class="auto-follow-toggle">
                        <span class="auto-follow-label">Follow active</span>
                        <button class="auto-follow-switch" id="auto-follow-switch" title="Follow active task"></button>
                    </div>
                    <div class="zoom-buttons">
                        <button class="zoom-btn" id="zoom-in" title="Zoom In">+</button>
                        <div class="zoom-level" id="zoom-level">100%</div>
                        <button class="zoom-btn" id="zoom-out" title="Zoom Out">‚àí</button>
                        <button class="zoom-btn" id="zoom-reset" title="Reset Zoom">‚ü≤</button>
                    </div>
                </div>
                <div class="info-panel" id="info-panel">
                    <div class="info-panel-header">
                        <span class="info-panel-title">Task Details</span>
                        <button class="info-panel-close" id="info-panel-close" title="Close">&times;</button>
                    </div>
                    <div id="info-panel-id" class="info-panel-id"></div>
                    <div id="info-panel-task-title" class="info-panel-task-title"></div>
                    <div id="info-panel-short-name-row" class="info-panel-short-name-row" style="display: none;">
                        <span class="info-panel-label">Display Name:</span>
                        <span id="info-panel-short-name" class="info-panel-short-name"></span>
                    </div>
                    <div id="info-panel-meta" class="info-panel-meta"></div>
                    <div id="info-panel-description-section" class="info-panel-section">
                        <div class="info-panel-section-title">Description</div>
                        <div id="info-panel-description" class="info-panel-description"></div>
                    </div>
                    <div id="info-panel-deps-section" class="info-panel-section" style="display: none;">
                        <div class="info-panel-section-title">Depends On</div>
                        <ul id="info-panel-deps" class="info-panel-deps"></ul>
                    </div>
                    <div id="info-panel-closed-section" class="info-panel-section" style="display: none;">
                        <div class="info-panel-section-title">Closed Reason</div>
                        <div id="info-panel-closed-reason" class="info-panel-closed-reason"></div>
                    </div>
                </div>
            </div>

            <div id="ready-view" class="view">
                <div class="task-list" id="ready-list"></div>
            </div>

            <div id="tests-view" class="view">
                <div class="test-list" id="test-list"></div>
            </div>

            <div id="log-view" class="view">
                <div class="log-list" id="log-list"></div>
            </div>
        </main>

        <div class="connection-status">
            <div class="status-dot status-disconnected" id="status-dot"></div>
            <span id="status-text">Connecting...</span>
        </div>
    </div>

    <script>
        // Toast Notification System
        const TOAST_ICONS = {
            success: '‚úì',
            error: '‚úï',
            warning: '‚ö†',
            info: '‚Ñπ'
        };

        /**
         * Show a toast notification
         * @param {string} message - The message to display
         * @param {string} type - Toast type: 'success', 'error', 'warning', 'info' (default: 'info')
         * @param {number} duration - Auto-dismiss duration in ms (default: 5000, use 0 for no auto-dismiss)
         * @returns {HTMLElement} The toast element (can be used to dismiss manually)
         */
        function showToast(message, type = 'info', duration = 5000) {
            const container = document.getElementById('toast-container');
            
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            
            const icon = document.createElement('span');
            icon.className = 'toast-icon';
            icon.textContent = TOAST_ICONS[type] || TOAST_ICONS.info;
            
            const msg = document.createElement('span');
            msg.className = 'toast-message';
            msg.textContent = message;
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'toast-close';
            closeBtn.innerHTML = '&times;';
            closeBtn.title = 'Dismiss';
            closeBtn.onclick = () => dismissToast(toast);
            
            toast.appendChild(icon);
            toast.appendChild(msg);
            toast.appendChild(closeBtn);
            
            container.appendChild(toast);
            
            // Auto-dismiss if duration > 0
            if (duration > 0) {
                toast._timeout = setTimeout(() => dismissToast(toast), duration);
            }
            
            return toast;
        }

        /**
         * Dismiss a toast notification
         * @param {HTMLElement} toast - The toast element to dismiss
         */
        function dismissToast(toast) {
            if (!toast || !toast.parentNode) return;
            
            // Clear any pending auto-dismiss
            if (toast._timeout) {
                clearTimeout(toast._timeout);
            }
            
            // Add exit animation
            toast.classList.add('toast-exit');
            
            // Remove after animation completes
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        }

        // Edge type definitions with display names and default visibility
        const EDGE_TYPES = {
            depends_on: { name: 'Depends', category: 'blocking', defaultVisible: true },
            blocks: { name: 'Blocks', category: 'blocking', defaultVisible: true },
            related_to: { name: 'Related', category: 'informational', defaultVisible: false },
            duplicates: { name: 'Duplicates', category: 'informational', defaultVisible: false },
            fixes: { name: 'Fixes', category: 'fixes', defaultVisible: false },
            caused_by: { name: 'Caused By', category: 'fixes', defaultVisible: false },
            supersedes: { name: 'Supersedes', category: 'informational', defaultVisible: false },
            parent_of: { name: 'Parent', category: 'hierarchy', defaultVisible: false },
            child_of: { name: 'Child', category: 'hierarchy', defaultVisible: false },
            tests: { name: 'Tests', category: 'fixes', defaultVisible: false }
        };

        // Load edge filter state from localStorage
        function loadEdgeFilters() {
            const saved = localStorage.getItem('binnacle_edge_filters');
            if (saved) {
                try {
                    return JSON.parse(saved);
                } catch (e) {
                    // Fall back to defaults
                }
            }
            // Default: only blocking edges visible
            const defaults = {};
            for (const [type, info] of Object.entries(EDGE_TYPES)) {
                defaults[type] = info.defaultVisible;
            }
            return defaults;
        }

        // Save edge filter state to localStorage
        function saveEdgeFilters(filters) {
            localStorage.setItem('binnacle_edge_filters', JSON.stringify(filters));
        }

        // State management
        const state = {
            currentView: 'graph',
            tasks: [],
            ready: [],
            tests: [],
            log: [],
            edges: [], // Raw edges from API
            edgeFilters: loadEdgeFilters(), // Which edge types are visible
            ws: null,
            graph: {
                nodes: [],
                edges: [],
                hoveredNode: null,
                hoveredEdge: null,
                mouseX: 0,
                mouseY: 0,
                physics: {
                    damping: 0.92,
                    gravityStrength: 0.05,
                    gravityCenter: { x: 0, y: 0 },
                    repulsionStrength: 2500,
                    springStrength: 0.08,
                    springRestingLength: 200,
                    edgeAttractionEnabled: true,
                    maxVelocity: 3
                },
                // Viewport transformation
                viewport: {
                    panX: 0,
                    panY: 0,
                    zoom: 1.0,
                    minZoom: 0.1,
                    maxZoom: 3.0
                },
                // Drag state
                draggedNode: null,
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                dragNodeStartX: 0,
                dragNodeStartY: 0,
                dragStartTime: 0,
                dragLastX: 0,
                dragLastY: 0,
                // Canvas pan state
                isPanning: false,
                panStartX: 0,
                panStartY: 0,
                panStartOffsetX: 0,
                panStartOffsetY: 0,
                // Selection state
                selectedNode: null,
                // Camera pan animation state
                followAnimation: null,  // { startPanX, startPanY, targetPanX, targetPanY, startZoom, targetZoom, startTime, duration }
                // Auto-follow state
                autoFollow: true,
                followingNodeId: null,  // ID of node currently being followed (for continuous tracking)
                // Stat highlight filter state (null = no filter active)
                highlightFilter: null,  // e.g., 'bugs', 'blocked', 'ready', 'ideas', 'milestones'
                // Hide completed nodes filter
                hideCompleted: false,  // When true, hide completed nodes except those in active chains
                // Search filter
                searchQuery: '',
                // Cached visibility for hit-testing (null until first frame)
                visibleNodes: null,
                visibleNodeIds: null
            }
        };

        // WebSocket connection
        let pendingReload = null;
        const RELOAD_DEBOUNCE_MS = 100;  // Client-side debounce as backup
        let wasConnected = false;  // Track connection state for toast notifications
        let disconnectToast = null;  // Track active disconnect toast
        let initialLoadComplete = false;  // Track if we've done the initial data load

        function connectWebSocket() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            state.ws = new WebSocket(`${protocol}//${location.host}/ws`);

            state.ws.onopen = () => {
                updateConnectionStatus(true);
                // Show reconnection toast only if we were previously connected
                if (wasConnected) {
                    // Dismiss any active disconnect toast
                    if (disconnectToast) {
                        dismissToast(disconnectToast);
                        disconnectToast = null;
                    }
                    showToast('Connection restored', 'success', 3000);
                }
                wasConnected = true;
                loadData();
            };

            state.ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.type === 'reload') {
                    // Debounce rapid reload messages
                    if (pendingReload) clearTimeout(pendingReload);
                    pendingReload = setTimeout(async () => {
                        pendingReload = null;
                        // Save previous statuses for auto-follow detection
                        const prevStatuses = {};
                        const prevTitles = {};
                        if (state.tasks) {
                            state.tasks.forEach(t => {
                                prevStatuses[t.id] = t.status;
                                prevTitles[t.id] = t.title;
                            });
                        }
                        // Track previous ready count for completion detection
                        const prevReadyCount = state.ready ? state.ready.length : 0;
                        
                        await loadData();
                        
                        // Check for in_progress transitions when auto-follow is enabled
                        if (state.graph.autoFollow && state.tasks) {
                            for (const task of state.tasks) {
                                const prevStatus = prevStatuses[task.id];
                                if (task.status === 'in_progress' && prevStatus && prevStatus !== 'in_progress') {
                                    // Task just transitioned to in_progress - start following it with zoom to 100%
                                    state.graph.followingNodeId = task.id;
                                    panToNode(task.id, true);  // Zoom to 100%
                                    break; // Follow first transition found
                                }
                            }
                        }
                        
                        // Task completion detection: show toast when task is closed (1 minute timeout)
                        if (state.tasks) {
                            for (const task of state.tasks) {
                                const prevStatus = prevStatuses[task.id];
                                if (task.status === 'done' && prevStatus && prevStatus !== 'done') {
                                    // Task just transitioned to done - show toast with 1 minute timeout
                                    showToast(`‚úÖ Task closed: ${task.id} - ${task.title}`, 'success', 60000);
                                }
                            }
                        }
                        
                        // New task/bug detection: show auto-dismissing toast for new additions
                        // Only show if we've done the initial load (skip first population)
                        if (state.tasks && initialLoadComplete) {
                            for (const task of state.tasks) {
                                // Check if this is a new item (not in previous state)
                                if (prevStatuses[task.id] === undefined) {
                                    if (task.type === 'bug') {
                                        showToast(`üêõ Bug added: ${task.id} - ${task.title}`, 'warning', 5000);
                                    } else if (task.type === 'task') {
                                        showToast(`üìã Task added: ${task.id} - ${task.title}`, 'info', 5000);
                                    }
                                }
                            }
                        }
                        initialLoadComplete = true;
                        
                        // Completion detection: last ready task was claimed
                        const newReadyCount = state.ready ? state.ready.length : 0;
                        if (prevReadyCount > 0 && newReadyCount === 0) {
                            showToast('All ready tasks claimed! üéØ', 'success', 5000);
                            // Zoom out 10% from current level
                            if (state.graph.scale > 0.1) {
                                state.graph.scale *= 0.9;
                            }
                        }
                    }, RELOAD_DEBOUNCE_MS);
                }
            };

            state.ws.onclose = () => {
                updateConnectionStatus(false);
                // Show disconnect toast if we were connected (and don't have one already)
                if (wasConnected && !disconnectToast) {
                    disconnectToast = showToast('Connection lost, reconnecting...', 'warning', 0);
                }
                setTimeout(connectWebSocket, 2000);
            };

            state.ws.onerror = () => {
                updateConnectionStatus(false);
            };
        }

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('status-dot');
            const text = document.getElementById('status-text');
            dot.className = `status-dot status-${connected ? 'connected' : 'disconnected'}`;
            text.textContent = connected ? 'Connected' : 'Disconnected';
        }

        // Data loading
        async function loadData() {
            // Load all data in parallel
            const [configData, tasksData, bugsData, ideasData, readyData, testsData, logData, edgesData] = await Promise.all([
                fetch('/api/config').then(r => r.json()),
                fetch('/api/tasks').then(r => r.json()),
                fetch('/api/bugs').then(r => r.json()),
                fetch('/api/ideas').then(r => r.json()),
                fetch('/api/ready').then(r => r.json()),
                fetch('/api/tests').then(r => r.json()),
                fetch('/api/log').then(r => r.json()),
                fetch('/api/edges').then(r => r.json())
            ]);
            
            // Update the document title with project name
            if (configData.project_name) {
                document.title = `üß≠ ${configData.project_name} - Binnacle`;
            }
            
            // Merge tasks, bugs, and ideas into unified tasks array for graph
            // Normalize bugs and ideas to have task-like fields for consistent rendering
            const normalizedBugs = (bugsData.bugs || []).map(bug => ({
                ...bug,
                type: 'bug',
                priority: bug.priority ?? 2,  // Default P2 if not set
                short_name: bug.short_name || null
            }));
            const normalizedIdeas = (ideasData.ideas || []).map(idea => ({
                ...idea,
                type: 'idea',
                priority: 4,  // Ideas are low priority by default
                short_name: idea.short_name || null,
                depends_on: idea.depends_on || []
            }));
            
            state.tasks = [...(tasksData.tasks || []), ...normalizedBugs, ...normalizedIdeas];
            state.ready = readyData.tasks || [];
            state.tests = testsData.tests || [];
            state.log = logData.log || [];
            state.edges = edgesData.edges || [];
            
            updateStatsOverlay();
            updateActiveTaskPane();
            renderCurrentView();
        }

        function updateStatsOverlay() {
            // Count entities by type and status (open items only for bugs/milestones)
            const openStatuses = ['pending', 'in_progress', 'blocked'];
            // Ideas have a different status lifecycle: seed/germinating are open, promoted/discarded are closed
            const openIdeaStatuses = ['seed', 'germinating'];
            const bugCount = state.tasks.filter(t => t.type === 'bug' && openStatuses.includes(t.status)).length;
            const blockedCount = state.tasks.filter(t => t.status === 'blocked').length;
            const readyCount = state.ready ? state.ready.length : 0;
            const ideaCount = state.tasks.filter(t => t.type === 'idea' && openIdeaStatuses.includes(t.status)).length;
            const milestoneCount = state.tasks.filter(t => t.type === 'milestone' && openStatuses.includes(t.status)).length;

            // Update DOM elements
            document.getElementById('stat-bugs').textContent = `üêõ ${bugCount} bug${bugCount !== 1 ? 's' : ''}`;
            document.getElementById('stat-blocked').textContent = `‚ùå ${blockedCount} blocked`;
            document.getElementById('stat-ready').textContent = `‚úÖ ${readyCount} ready`;
            document.getElementById('stat-ideas').textContent = `üí≠ ${ideaCount} idea${ideaCount !== 1 ? 's' : ''}`;
            document.getElementById('stat-milestones').textContent = `üèÅ ${milestoneCount} milestone${milestoneCount !== 1 ? 's' : ''}`;
            
            // Update active state for stat filters
            updateStatFilterHighlights();
        }
        
        function updateActiveTaskPane() {
            const pane = document.getElementById('active-task-pane');
            const idEl = document.getElementById('active-task-id');
            const titleEl = document.getElementById('active-task-title');
            const metaEl = document.getElementById('active-task-meta');
            
            // Find first in_progress task
            const activeTask = state.tasks.find(t => t.status === 'in_progress');
            
            if (activeTask) {
                pane.classList.remove('empty');
                idEl.textContent = activeTask.id;
                titleEl.textContent = activeTask.title || 'Untitled task';
                titleEl.title = activeTask.title || '';  // Full title on hover
                
                // Build meta badges
                let metaHtml = '';
                if (activeTask.priority !== undefined) {
                    metaHtml += `<span class="badge badge-priority-${activeTask.priority}">P${activeTask.priority}</span>`;
                }
                if (activeTask.tags && activeTask.tags.length > 0) {
                    activeTask.tags.slice(0, 2).forEach(tag => {
                        metaHtml += `<span class="badge badge-tag">${tag}</span>`;
                    });
                }
                metaEl.innerHTML = metaHtml;
            } else {
                pane.classList.add('empty');
                idEl.textContent = 'No active task';
                titleEl.textContent = '';
                titleEl.title = '';
                metaEl.innerHTML = '';
            }
        }
        
        // Initialize clickable stat filters
        function initializeStatFilters() {
            const filterMap = {
                'stat-bugs': 'bugs',
                'stat-blocked': 'blocked',
                'stat-ready': 'ready',
                'stat-ideas': 'ideas',
                'stat-milestones': 'milestones'
            };
            
            for (const [elementId, filterName] of Object.entries(filterMap)) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.addEventListener('click', () => {
                        toggleStatFilter(filterName);
                    });
                }
            }
        }
        
        // Toggle stat filter on/off
        function toggleStatFilter(filterName) {
            if (state.graph.highlightFilter === filterName) {
                // Clear filter if clicking same one
                state.graph.highlightFilter = null;
            } else {
                // Set new filter
                state.graph.highlightFilter = filterName;
            }
            updateStatFilterHighlights();
        }
        
        // Update visual state of stat filter buttons
        function updateStatFilterHighlights() {
            const filterMap = {
                'bugs': 'stat-bugs',
                'blocked': 'stat-blocked',
                'ready': 'stat-ready',
                'ideas': 'stat-ideas',
                'milestones': 'stat-milestones'
            };
            
            for (const [filter, elementId] of Object.entries(filterMap)) {
                const element = document.getElementById(elementId);
                if (element) {
                    element.classList.toggle('active', state.graph.highlightFilter === filter);
                }
            }
        }
        
        // Check if a node matches the current highlight filter
        function nodeMatchesFilter(node) {
            const filter = state.graph.highlightFilter;
            if (!filter) return true; // No filter = all match
            
            const openStatuses = ['pending', 'in_progress', 'blocked'];
            const readyIds = state.ready ? new Set(state.ready.map(t => t.id)) : new Set();
            
            switch (filter) {
                case 'bugs':
                    return node.type === 'bug' && openStatuses.includes(node.status);
                case 'blocked':
                    return node.status === 'blocked';
                case 'ready':
                    return readyIds.has(node.id);
                case 'ideas':
                    // Ideas have different status lifecycle: seed/germinating are open
                    return node.type === 'idea' && ['seed', 'germinating'].includes(node.status);
                case 'milestones':
                    return node.type === 'milestone' && openStatuses.includes(node.status);
                default:
                    return true;
            }
        }

        // View switching
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const view = btn.dataset.view;
                switchView(view);
            });
        });

        function switchView(view) {
            state.currentView = view;
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-view="${view}"]`).classList.add('active');
            document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
            document.getElementById(`${view}-view`).classList.add('active');
            renderCurrentView();
        }

        // Rendering
        function renderCurrentView() {
            switch (state.currentView) {
                case 'graph':
                    renderGraph();
                    break;
                case 'ready':
                    renderReady();
                    break;
                case 'tests':
                    renderTests();
                    break;
                case 'log':
                    renderLog();
                    break;
            }
        }

        function renderGraph() {
            // This will be implemented with spring physics
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');

            // Set canvas size
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;

            if (state.tasks.length === 0) {
                renderEmptyState(ctx, 'No tasks yet');
                return;
            }

            // Build graph data structure
            buildGraphData();

            // Add mouse event listeners
            setupGraphMouseHandlers(canvas);

            // Initialize zoom display
            updateZoomDisplay();

            // Start animation loop
            requestAnimationFrame(animateGraph);
        }

        function setupGraphMouseHandlers(canvas) {
            // Remove old listeners to avoid duplicates
            const newCanvas = canvas.cloneNode(true);
            canvas.parentNode.replaceChild(newCanvas, canvas);
            const finalCanvas = document.getElementById('graph-canvas');

            finalCanvas.addEventListener('mousemove', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Handle canvas panning
                if (state.graph.isPanning) {
                    const dx = mouseX - state.graph.panStartX;
                    const dy = mouseY - state.graph.panStartY;
                    const zoom = state.graph.viewport.zoom;

                    // Update pan offset (inversely proportional to zoom)
                    state.graph.viewport.panX = state.graph.panStartOffsetX + dx / zoom;
                    state.graph.viewport.panY = state.graph.panStartOffsetY + dy / zoom;
                    return;
                }

                const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                if (state.graph.isDragging && state.graph.draggedNode) {
                    // Update dragged node position in world coordinates
                    const currentWorld = screenToWorld(mouseX, mouseY, finalCanvas);
                    const startWorld = screenToWorld(state.graph.dragStartX, state.graph.dragStartY, finalCanvas);
                    const dx = currentWorld.x - startWorld.x;
                    const dy = currentWorld.y - startWorld.y;
                    const node = state.graph.draggedNode;

                    node.x = state.graph.dragNodeStartX + dx;
                    node.y = state.graph.dragNodeStartY + dy;

                    // No boundary clamping for infinite canvas

                    // Track for momentum calculation
                    state.graph.dragLastX = mouseX;
                    state.graph.dragLastY = mouseY;

                    // Update tooltip position
                    updateTooltip(node, e.clientX, e.clientY);
                } else {
                    // Normal hover behavior - use world coordinates
                    state.graph.mouseX = worldPos.x;
                    state.graph.mouseY = worldPos.y;

                    // Find hovered node using world coordinates
                    const hoveredNode = state.graph.nodes.find(node => {
                        const dx = worldPos.x - node.x;
                        const dy = worldPos.y - node.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= node.radius;
                    });

                    if (hoveredNode !== state.graph.hoveredNode) {
                        state.graph.hoveredNode = hoveredNode;
                        updateTooltip(hoveredNode, e.clientX, e.clientY);
                        finalCanvas.classList.toggle('hovering', !!hoveredNode);
                        // Hide edge tooltip when showing node tooltip
                        if (hoveredNode) {
                            state.graph.hoveredEdge = null;
                            updateEdgeTooltip(null);
                        }
                    }

                    // Check for edge hover only if not hovering over a node
                    if (!hoveredNode) {
                        const hoveredEdge = findHoveredEdge(worldPos.x, worldPos.y);
                        if (hoveredEdge !== state.graph.hoveredEdge) {
                            state.graph.hoveredEdge = hoveredEdge;
                            updateEdgeTooltip(hoveredEdge, e.clientX, e.clientY);
                        } else if (hoveredEdge) {
                            // Update position while still hovering same edge
                            updateEdgeTooltip(hoveredEdge, e.clientX, e.clientY);
                        }
                    }
                }
            });

            finalCanvas.addEventListener('mouseleave', () => {
                // End any active drag
                if (state.graph.isDragging && state.graph.draggedNode) {
                    // Apply gentle stop (no momentum on mouse leave)
                    state.graph.draggedNode.vx = 0;
                    state.graph.draggedNode.vy = 0;
                    state.graph.isDragging = false;
                    state.graph.draggedNode = null;
                }

                // End any active pan
                if (state.graph.isPanning) {
                    state.graph.isPanning = false;
                    finalCanvas.style.cursor = 'default';
                }

                state.graph.hoveredNode = null;
                state.graph.hoveredEdge = null;
                updateTooltip(null);
                updateEdgeTooltip(null);
                finalCanvas.classList.remove('hovering', 'dragging');
            });

            finalCanvas.addEventListener('mousedown', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Middle mouse or Shift+Left mouse = always canvas pan
                // But not while auto-follow animation is active
                if (e.button === 1 || (e.button === 0 && e.shiftKey)) {
                    if (state.graph.followAnimation && state.graph.autoFollow) {
                        return; // Block panning during auto-follow
                    }
                    cancelPanAnimation();  // Cancel any ongoing camera animation
                    state.graph.isPanning = true;
                    state.graph.panStartX = mouseX;
                    state.graph.panStartY = mouseY;
                    state.graph.panStartOffsetX = state.graph.viewport.panX;
                    state.graph.panStartOffsetY = state.graph.viewport.panY;
                    finalCanvas.style.cursor = 'grabbing';
                    e.preventDefault();
                    return;
                }

                // Left mouse button = node drag or canvas pan
                if (e.button === 0) {
                    const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                    // Find node under mouse using world coordinates (visible nodes only)
                    const nodesForHitTest = state.graph.visibleNodes ?? state.graph.nodes;
                    const node = nodesForHitTest.find(n => {
                        const dx = worldPos.x - n.x;
                        const dy = worldPos.y - n.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= n.radius;
                    });

                    if (node) {
                        // Node found - drag the node
                        state.graph.draggedNode = node;
                        state.graph.isDragging = true;
                        state.graph.dragStartX = mouseX;
                        state.graph.dragStartY = mouseY;
                        state.graph.dragNodeStartX = node.x;
                        state.graph.dragNodeStartY = node.y;
                        state.graph.dragStartTime = Date.now();
                        state.graph.dragLastX = mouseX;
                        state.graph.dragLastY = mouseY;
                        finalCanvas.classList.add('dragging');
                        e.preventDefault();
                    } else {
                        // No node found - pan the canvas (but not during auto-follow animation)
                        if (state.graph.followAnimation && state.graph.autoFollow) {
                            return; // Block panning during auto-follow animation
                        }
                        // User is manually panning - stop following the node
                        state.graph.followingNodeId = null;
                        cancelPanAnimation();  // Cancel any ongoing camera animation
                        state.graph.isPanning = true;
                        state.graph.panStartX = mouseX;
                        state.graph.panStartY = mouseY;
                        state.graph.panStartOffsetX = state.graph.viewport.panX;
                        state.graph.panStartOffsetY = state.graph.viewport.panY;
                        finalCanvas.style.cursor = 'grabbing';
                        e.preventDefault();
                    }
                }
            });

            finalCanvas.addEventListener('mouseup', (e) => {
                // End canvas panning
                if (state.graph.isPanning) {
                    state.graph.isPanning = false;
                    finalCanvas.style.cursor = 'default';
                }

                // End node dragging
                if (state.graph.isDragging && state.graph.draggedNode) {
                    const rect = finalCanvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    // Calculate momentum from recent drag motion in screen space
                    // Velocity is in world units per frame, so scale by zoom
                    const zoom = state.graph.viewport.zoom;
                    const velocityX = (mouseX - state.graph.dragLastX) * 2.5 / zoom;
                    const velocityY = (mouseY - state.graph.dragLastY) * 2.5 / zoom;

                    state.graph.draggedNode.vx = velocityX;
                    state.graph.draggedNode.vy = velocityY;

                    // Clear drag state
                    state.graph.isDragging = false;
                    state.graph.draggedNode = null;
                    finalCanvas.classList.remove('dragging');

                    // Update hover state (mouse may still be over a node)
                    const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);
                    const nodesForHitTest = state.graph.visibleNodes ?? state.graph.nodes;
                    const hoveredNode = nodesForHitTest.find(n => {
                        const dx = worldPos.x - n.x;
                        const dy = worldPos.y - n.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        return distance <= n.radius;
                    });
                    state.graph.hoveredNode = hoveredNode;
                    updateTooltip(hoveredNode, e.clientX, e.clientY);
                    finalCanvas.classList.toggle('hovering', !!hoveredNode);
                }
            });

            finalCanvas.addEventListener('dblclick', (e) => {
                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldPos = screenToWorld(mouseX, mouseY, finalCanvas);

                // Find node under mouse using world coordinates (visible nodes only)
                const nodesForHitTest = state.graph.visibleNodes ?? state.graph.nodes;
                const node = nodesForHitTest.find(n => {
                    const dx = worldPos.x - n.x;
                    const dy = worldPos.y - n.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance <= n.radius;
                });

                if (node) {
                    // Toggle selection
                    if (state.graph.selectedNode === node) {
                        state.graph.selectedNode = null;
                    } else {
                        state.graph.selectedNode = node;
                    }
                } else {
                    // Click on empty space deselects
                    state.graph.selectedNode = null;
                }

                // Update info panel with current selection
                updateInfoPanel(state.graph.selectedNode);

                e.preventDefault();
            });

            // Mouse wheel zoom
            finalCanvas.addEventListener('wheel', (e) => {
                e.preventDefault();

                const rect = finalCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
                zoomCanvas(zoomDelta, mouseX, mouseY);
            }, { passive: false });
        }

        // Zoom button controls
        document.getElementById('zoom-in').addEventListener('click', () => {
            zoomCanvas(1.2);
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            zoomCanvas(0.8);
        });

        document.getElementById('zoom-reset').addEventListener('click', () => {
            state.graph.viewport.zoom = 1.0;
            state.graph.viewport.panX = 0;
            state.graph.viewport.panY = 0;
            updateZoomDisplay();
        });

        // Auto-follow toggle
        document.getElementById('auto-follow-switch').addEventListener('click', () => {
            state.graph.autoFollow = !state.graph.autoFollow;
            updateAutoFollowDisplay();
            // When enabling auto-follow, immediately snap to current active task
            if (state.graph.autoFollow) {
                snapToActiveTask();
            } else {
                // When disabling auto-follow, stop tracking
                state.graph.followingNodeId = null;
            }
        });

        function updateAutoFollowDisplay() {
            const switchEl = document.getElementById('auto-follow-switch');
            if (state.graph.autoFollow) {
                switchEl.classList.add('active');
            } else {
                switchEl.classList.remove('active');
            }
        }

        // Hide completed toggle
        document.getElementById('hide-completed-switch').addEventListener('click', () => {
            state.graph.hideCompleted = !state.graph.hideCompleted;
            updateHideCompletedDisplay();
        });

        function updateHideCompletedDisplay() {
            const switchEl = document.getElementById('hide-completed-switch');
            if (state.graph.hideCompleted) {
                switchEl.classList.add('active');
            } else {
                switchEl.classList.remove('active');
            }
        }

        function normalizeSearchQuery(query) {
            return (query || '').trim().toLowerCase();
        }

        function nodeMatchesSearch(node, normalizedQuery) {
            if (!normalizedQuery) return true;
            const haystack = `${node.id} ${(node.title || '')} ${(node.short_name || '')}`.toLowerCase();
            return haystack.includes(normalizedQuery);
        }

        function setGraphSearchQuery(query) {
            state.graph.searchQuery = query;

            const visibleIds = state.graph.visibleNodeIds ?? new Set(getVisibleNodes(state.graph.nodes).map(n => n.id));

            if (state.graph.hoveredNode && !visibleIds.has(state.graph.hoveredNode.id)) {
                state.graph.hoveredNode = null;
                updateTooltip(null);
            }

            if (state.graph.hoveredEdge) {
                // Clear edge tooltip; edge hover recalculates based on visibility
                state.graph.hoveredEdge = null;
                updateEdgeTooltip(null);
            }

            if (state.graph.selectedNode && !visibleIds.has(state.graph.selectedNode.id)) {
                state.graph.selectedNode = null;
                updateInfoPanel(null);
            }

            if (state.graph.followingNodeId && !visibleIds.has(state.graph.followingNodeId)) {
                state.graph.followingNodeId = null;
            }
        }

        function initializeGraphSearch() {
            const input = document.getElementById('graph-search');
            if (!input) return;

            input.addEventListener('input', () => {
                setGraphSearchQuery(input.value);
            });

            input.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    input.value = '';
                    setGraphSearchQuery('');
                    e.preventDefault();
                }
            });
        }

        // Find and pan to the first in_progress task, zooming to 100%
        function snapToActiveTask() {
            if (!state.tasks) return;
            const activeTask = state.tasks.find(t => t.status === 'in_progress');
            if (activeTask) {
                state.graph.followingNodeId = activeTask.id;
                panToNode(activeTask.id, true);  // Zoom to 100%
            } else {
                state.graph.followingNodeId = null;
            }
        }

        function zoomCanvas(zoomDelta, centerX, centerY) {
            const canvas = document.getElementById('graph-canvas');
            if (!centerX || !centerY) {
                // Default to canvas center
                centerX = canvas.width / 2;
                centerY = canvas.height / 2;
            }

            // World point under cursor before zoom
            const worldBefore = screenToWorld(centerX, centerY, canvas);

            // Update zoom
            const oldZoom = state.graph.viewport.zoom;
            state.graph.viewport.zoom = Math.max(
                state.graph.viewport.minZoom,
                Math.min(state.graph.viewport.maxZoom, oldZoom * zoomDelta)
            );

            // World point under cursor after zoom
            const worldAfter = screenToWorld(centerX, centerY, canvas);

            // Adjust pan to keep point stationary
            state.graph.viewport.panX += worldBefore.x - worldAfter.x;
            state.graph.viewport.panY += worldBefore.y - worldAfter.y;

            // Update zoom level display
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            const zoomLevelEl = document.getElementById('zoom-level');
            if (zoomLevelEl) {
                const percent = Math.round(state.graph.viewport.zoom * 100);
                zoomLevelEl.textContent = `${percent}%`;
            }
        }

        // Ease-in-out-cubic easing function
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Calculate adaptive pan duration based on distance
        function getPanDuration(distance) {
            // Doubled durations for smoother animation
            if (distance < 300) return 600;
            if (distance <= 800) return 1000;
            return 1600;
        }

        // Pan camera smoothly to center on a world position
        function panToWorldPosition(targetX, targetY, targetZoom = null) {
            const canvas = document.getElementById('graph-canvas');
            const { viewport } = state.graph;

            // Target pan values to center the position on screen
            // worldToScreen: screenX = (worldX + panX) * zoom + canvas.width / 2
            // To center targetX, we need: canvas.width / 2 = (targetX + panX) * zoom + canvas.width / 2
            // => 0 = (targetX + panX) * zoom
            // => panX = -targetX
            const targetPanX = -targetX;
            const targetPanY = -targetY;

            // Calculate distance in screen pixels for duration
            const startPanX = viewport.panX;
            const startPanY = viewport.panY;
            const startZoom = viewport.zoom;
            const dx = (targetPanX - startPanX) * viewport.zoom;
            const dy = (targetPanY - startPanY) * viewport.zoom;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Calculate zoom change for duration consideration
            const zoomChange = targetZoom !== null ? Math.abs(targetZoom - startZoom) : 0;

            // Skip animation if already centered (within 1 pixel) and no zoom change
            if (distance < 1 && zoomChange < 0.01) return;

            // Use longer duration if there's significant zoom change
            const baseDuration = getPanDuration(distance);
            const duration = zoomChange > 0.1 ? Math.max(baseDuration, 800) : baseDuration;

            // Start the animation
            state.graph.followAnimation = {
                startPanX,
                startPanY,
                targetPanX,
                targetPanY,
                startZoom,
                targetZoom: targetZoom !== null ? targetZoom : startZoom,
                startTime: performance.now(),
                duration
            };
        }

        // Pan camera smoothly to center on a node by ID, optionally zooming to 100%
        function panToNode(nodeId, zoomTo100 = false) {
            const node = state.graph.nodes.find(n => n.id === nodeId);
            if (node) {
                panToWorldPosition(node.x, node.y, zoomTo100 ? 1.0 : null);
            }
        }

        // Cancel any ongoing pan animation
        function cancelPanAnimation() {
            state.graph.followAnimation = null;
        }

        // Update pan animation (called from animateGraph)
        function updatePanAnimation() {
            const anim = state.graph.followAnimation;
            if (!anim) return;

            const now = performance.now();
            const elapsed = now - anim.startTime;
            const progress = Math.min(elapsed / anim.duration, 1);
            const easedProgress = easeInOutCubic(progress);

            // Interpolate pan values
            state.graph.viewport.panX = anim.startPanX + (anim.targetPanX - anim.startPanX) * easedProgress;
            state.graph.viewport.panY = anim.startPanY + (anim.targetPanY - anim.startPanY) * easedProgress;

            // Interpolate zoom if target differs from start
            if (anim.targetZoom !== anim.startZoom) {
                state.graph.viewport.zoom = anim.startZoom + (anim.targetZoom - anim.startZoom) * easedProgress;
                updateZoomDisplay();
            }

            // Animation complete
            if (progress >= 1) {
                state.graph.followAnimation = null;
            }
        }

        // Continuous follow: keep viewport centered on followed node as it moves
        function updateContinuousFollow(canvas) {
            // Skip if auto-follow is disabled or no node is being followed
            if (!state.graph.autoFollow || !state.graph.followingNodeId) return;
            
            // Skip if an animation is in progress (let it complete)
            if (state.graph.followAnimation) return;
            
            // Skip if user is panning or dragging
            if (state.graph.isPanning || state.graph.draggedNode) return;
            
            // Find the followed node
            const node = state.graph.nodes.find(n => n.id === state.graph.followingNodeId);
            if (!node) {
                // Node no longer exists, clear following
                state.graph.followingNodeId = null;
                return;
            }
            
            // Calculate target pan to center the node
            const targetPanX = -node.x;
            const targetPanY = -node.y;
            
            // Smoothly interpolate toward target (soft follow)
            const smoothing = 0.08; // Lower = smoother but slower to catch up
            state.graph.viewport.panX += (targetPanX - state.graph.viewport.panX) * smoothing;
            state.graph.viewport.panY += (targetPanY - state.graph.viewport.panY) * smoothing;
        }

        function updateTooltip(node, mouseX, mouseY) {
            const tooltip = document.getElementById('node-tooltip');
            const titleEl = document.getElementById('tooltip-title');
            const idEl = document.getElementById('tooltip-id');
            const metaEl = document.getElementById('tooltip-meta');

            if (!node) {
                tooltip.classList.remove('visible');
                return;
            }

            // Find full task data
            const task = state.tasks.find(t => t.id === node.id);
            if (!task) return;

            // Update tooltip content - show short_name if available, otherwise title
            titleEl.textContent = task.short_name || task.title;
            idEl.textContent = task.id;

            // Build metadata badges
            metaEl.innerHTML = `
                <span class="badge badge-priority-${task.priority}">P${task.priority}</span>
                <span class="badge badge-status-${task.status}">${task.status}</span>
                ${task.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
            `;

            // Position tooltip
            const offset = 15;
            tooltip.style.left = `${mouseX + offset}px`;
            tooltip.style.top = `${mouseY + offset}px`;

            // Adjust if tooltip goes off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (tooltipRect.right > viewportWidth) {
                tooltip.style.left = `${mouseX - tooltipRect.width - offset}px`;
            }
            if (tooltipRect.bottom > viewportHeight) {
                tooltip.style.top = `${mouseY - tooltipRect.height - offset}px`;
            }

            tooltip.classList.add('visible');
        }

        // Edge tooltip functions
        function getEdgeTypeName(edgeType) {
            const names = {
                'depends_on': 'Depends On',
                'blocks': 'Blocks',
                'related_to': 'Related To',
                'caused_by': 'Caused By',
                'duplicates': 'Duplicates',
                'supersedes': 'Supersedes',
                'fixes': 'Fixes',
                'tests': 'Tests',
                'parent_of': 'Parent Of',
                'child_of': 'Child Of'
            };
            return names[edgeType] || edgeType;
        }

        function distanceToEdge(px, py, edge) {
            // Get node positions
            const fromNode = state.graph.nodes.find(n => n.id === edge.from);
            const toNode = state.graph.nodes.find(n => n.id === edge.to);
            if (!fromNode || !toNode) return Infinity;

            // Calculate edge endpoints (at node boundaries, not centers)
            const dx = toNode.x - fromNode.x;
            const dy = toNode.y - fromNode.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < fromNode.radius + toNode.radius) return Infinity;

            const angle = Math.atan2(dy, dx);
            const x1 = fromNode.x + Math.cos(angle) * fromNode.radius;
            const y1 = fromNode.y + Math.sin(angle) * fromNode.radius;
            const x2 = toNode.x - Math.cos(angle) * toNode.radius;
            const y2 = toNode.y - Math.sin(angle) * toNode.radius;

            // Calculate distance from point to line segment
            const lineDx = x2 - x1;
            const lineDy = y2 - y1;
            const lineLen = Math.sqrt(lineDx * lineDx + lineDy * lineDy);
            if (lineLen === 0) return Infinity;

            // Project point onto line, clamped to segment
            const t = Math.max(0, Math.min(1, ((px - x1) * lineDx + (py - y1) * lineDy) / (lineLen * lineLen)));
            const projX = x1 + t * lineDx;
            const projY = y1 + t * lineDy;

            return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
        }

        function findHoveredEdge(worldX, worldY, threshold = 8) {
            // Adjust threshold for zoom level
            const adjustedThreshold = threshold / state.graph.viewport.zoom;
            
            let closestEdge = null;
            let closestDistance = adjustedThreshold;

            for (const edge of state.graph.edges) {
                // Skip edges that are filtered out
                if (!state.edgeFilters[edge.edge_type]) continue;

                // Skip edges where either endpoint is hidden
                if (state.graph.visibleNodeIds) {
                    if (!state.graph.visibleNodeIds.has(edge.from) || !state.graph.visibleNodeIds.has(edge.to)) {
                        continue;
                    }
                }
                
                const distance = distanceToEdge(worldX, worldY, edge);
                if (distance < closestDistance) {
                    closestDistance = distance;
                    closestEdge = edge;
                }
            }

            return closestEdge;
        }

        function updateEdgeTooltip(edge, mouseX, mouseY) {
            const tooltip = document.getElementById('edge-tooltip');
            const typeEl = document.getElementById('edge-tooltip-type');
            const idsEl = document.getElementById('edge-tooltip-ids');
            const reasonEl = document.getElementById('edge-tooltip-reason');
            const dateEl = document.getElementById('edge-tooltip-date');

            if (!edge) {
                tooltip.classList.remove('visible');
                return;
            }

            // Get the full edge data from state.edges (API data with created_at)
            const fullEdge = state.edges.find(e => 
                e.source === edge.from && e.target === edge.to && e.edge_type === edge.edge_type
            );

            // Get edge style for color
            const style = getEdgeStyle(edge.edge_type);
            
            // Update tooltip content
            typeEl.innerHTML = `
                <span class="edge-color-dot" style="background-color: ${style.color}"></span>
                ${getEdgeTypeName(edge.edge_type)}${edge.bidirectional ? ' (bidirectional)' : ''}
            `;
            idsEl.textContent = `${edge.from} ‚Üí ${edge.to}`;

            // Show/hide reason
            if (edge.reason) {
                reasonEl.textContent = `"${edge.reason}"`;
                reasonEl.style.display = 'block';
            } else {
                reasonEl.style.display = 'none';
            }

            // Show created date if available
            if (fullEdge && fullEdge.created_at) {
                const date = new Date(fullEdge.created_at);
                dateEl.textContent = `Created: ${date.toLocaleDateString()}`;
                dateEl.style.display = 'block';
            } else {
                dateEl.style.display = 'none';
            }

            // Position tooltip
            const offset = 15;
            tooltip.style.left = `${mouseX + offset}px`;
            tooltip.style.top = `${mouseY + offset}px`;

            // Adjust if tooltip goes off screen
            const tooltipRect = tooltip.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (tooltipRect.right > viewportWidth) {
                tooltip.style.left = `${mouseX - tooltipRect.width - offset}px`;
            }
            if (tooltipRect.bottom > viewportHeight) {
                tooltip.style.top = `${mouseY - tooltipRect.height - offset}px`;
            }

            tooltip.classList.add('visible');
        }

        function updateInfoPanel(node) {
            const panel = document.getElementById('info-panel');
            const idEl = document.getElementById('info-panel-id');
            const titleEl = document.getElementById('info-panel-task-title');
            const metaEl = document.getElementById('info-panel-meta');
            const descEl = document.getElementById('info-panel-description');
            const descSection = document.getElementById('info-panel-description-section');
            const depsSection = document.getElementById('info-panel-deps-section');
            const depsList = document.getElementById('info-panel-deps');
            const closedSection = document.getElementById('info-panel-closed-section');
            const closedReason = document.getElementById('info-panel-closed-reason');

            if (!node) {
                panel.classList.remove('visible');
                return;
            }

            // Find full task data
            const task = state.tasks.find(t => t.id === node.id);
            if (!task) return;

            // Update panel content
            idEl.textContent = task.id;
            titleEl.textContent = task.title;

            // Show short_name if set (after title)
            const shortNameEl = document.getElementById('info-panel-short-name');
            const shortNameRow = document.getElementById('info-panel-short-name-row');
            if (task.short_name) {
                shortNameEl.textContent = task.short_name;
                shortNameRow.style.display = 'block';
            } else {
                shortNameRow.style.display = 'none';
            }

            // Build metadata badges
            metaEl.innerHTML = `
                <span class="badge badge-priority-${task.priority}">P${task.priority}</span>
                <span class="badge badge-status-${task.status}">${task.status}</span>
                ${task.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
            `;

            // Description
            if (task.description) {
                descEl.textContent = task.description;
                descEl.classList.remove('empty');
                descSection.style.display = 'block';
            } else {
                descEl.textContent = 'No description provided';
                descEl.classList.add('empty');
                descSection.style.display = 'block';
            }

            // Dependencies
            if (task.depends_on && task.depends_on.length > 0) {
                depsList.innerHTML = task.depends_on.map(depId => `<li>${escapeHtml(depId)}</li>`).join('');
                depsSection.style.display = 'block';
            } else {
                depsSection.style.display = 'none';
            }

            // Closed reason
            if (task.status === 'done' && task.closed_reason) {
                closedReason.textContent = task.closed_reason;
                closedSection.style.display = 'block';
            } else {
                closedSection.style.display = 'none';
            }

            // Show panel
            panel.classList.add('visible');
        }

        // Info panel close button
        document.getElementById('info-panel-close').addEventListener('click', () => {
            state.graph.selectedNode = null;
            updateInfoPanel(null);
        });

        // Coordinate transformation functions
        function screenToWorld(screenX, screenY, canvas) {
            const { panX, panY, zoom } = state.graph.viewport;
            return {
                x: (screenX - canvas.width / 2) / zoom - panX,
                y: (screenY - canvas.height / 2) / zoom - panY
            };
        }

        function worldToScreen(worldX, worldY, canvas) {
            const { panX, panY, zoom } = state.graph.viewport;
            return {
                x: (worldX + panX) * zoom + canvas.width / 2,
                y: (worldY + panY) * zoom + canvas.height / 2
            };
        }

        /**
         * Build a set of "active" node IDs - nodes that are not in a completed state.
         * Active nodes include: pending, in_progress, blocked, reopened statuses.
         * For ideas: seed, germinating are active; promoted, discarded are not.
         */
        function buildActiveNodeSet() {
            const activeStatuses = ['pending', 'in_progress', 'blocked', 'reopened'];
            const activeIdeaStatuses = ['seed', 'germinating'];

            const activeNodes = new Set();

            state.tasks.forEach(task => {
                let isActive = false;

                if (task.type === 'idea') {
                    isActive = activeIdeaStatuses.includes(task.status);
                } else {
                    isActive = activeStatuses.includes(task.status);
                }

                if (isActive) {
                    activeNodes.add(task.id);
                }
            });

            return activeNodes;
        }

        /**
         * Check if a node is in an "active chain" - meaning it's either:
         * 1. An active node itself, OR
         * 2. Connected (transitively through edges) to an active node
         *
         * This allows completed nodes to remain visible if they're part of
         * a dependency chain with work that's still in progress.
         */
        function isInActiveChain(nodeId, activeNodes, edges) {
            // If the node itself is active, it's in an active chain
            if (activeNodes.has(nodeId)) {
                return true;
            }

            // Build adjacency list for traversal (both directions)
            const adjacency = new Map();
            edges.forEach(edge => {
                if (!adjacency.has(edge.from)) {
                    adjacency.set(edge.from, []);
                }
                if (!adjacency.has(edge.to)) {
                    adjacency.set(edge.to, []);
                }
                // Add bidirectional edges for traversal
                adjacency.get(edge.from).push(edge.to);
                adjacency.get(edge.to).push(edge.from);
            });

            // BFS to check if we can reach any active node from this node
            const visited = new Set();
            const queue = [nodeId];
            visited.add(nodeId);

            while (queue.length > 0) {
                const current = queue.shift();

                // If we reached an active node, this node is in an active chain
                if (activeNodes.has(current)) {
                    return true;
                }

                // Explore neighbors
                const neighbors = adjacency.get(current) || [];
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        visited.add(neighbor);
                        queue.push(neighbor);
                    }
                }
            }

            return false;
        }

        /**
         * Filter nodes based on hideCompleted setting.
         * Returns array of nodes that should be visible.
         *
         * When hideCompleted is true:
         * - Hide nodes with status 'done' or 'cancelled'
         * - EXCEPT those in active dependency chains
         */
        function getVisibleNodes(nodes) {
            const normalizedQuery = normalizeSearchQuery(state.graph.searchQuery);

            // If hideCompleted is not enabled, start with all nodes
            let visible = nodes;

            if (state.graph.hideCompleted) {
                // Build active node set and prepare edges for chain detection
                const activeNodes = buildActiveNodeSet();
                const edges = state.graph.edges;

                // Filter nodes: keep if not completed, or if in active chain
                visible = nodes.filter(node => {
                    const isCompleted = node.status === 'done' || node.status === 'cancelled';

                    // If not completed, always show it
                    if (!isCompleted) {
                        return true;
                    }

                    // If completed, only show if it's in an active chain
                    return isInActiveChain(node.id, activeNodes, edges);
                });
            }

            // Apply search filter (render-only; hides non-matching nodes)
            if (normalizedQuery) {
                visible = visible.filter(node => nodeMatchesSearch(node, normalizedQuery));
            }

            return visible;
        }

        function buildGraphData() {
            // Build a map of existing node positions to preserve them on reload
            const existingNodes = new Map();
            state.graph.nodes.forEach(node => {
                existingNodes.set(node.id, { x: node.x, y: node.y });
            });

            // Convert tasks to nodes - preserve positions or place in circular layout
            state.graph.nodes = state.tasks.map((task, index) => {
                const existing = existingNodes.get(task.id);

                if (existing) {
                    // Preserve existing position, but reset velocity to prevent oscillation
                    return {
                        id: task.id,
                        title: task.title,
                        short_name: task.short_name,
                        status: task.status,
                        priority: task.priority,
                        type: task.type || 'task',
                        x: existing.x,
                        y: existing.y,
                        vx: 0,
                        vy: 0,
                        radius: 30
                    };
                } else {
                    // New node - place in circular layout in world space
                    const totalNodes = state.tasks.length;
                    const angle = (index / totalNodes) * 2 * Math.PI;
                    const radius = 300; // Initial radius in world units

                    return {
                        id: task.id,
                        title: task.title,
                        short_name: task.short_name,
                        status: task.status,
                        priority: task.priority,
                        type: task.type || 'task',
                        x: Math.cos(angle) * radius,
                        y: Math.sin(angle) * radius,
                        vx: 0,
                        vy: 0,
                        radius: 30  // Node radius in world units
                    };
                }
            });

            // Build edges from API data with edge type metadata
            state.graph.edges = (state.edges || []).map(edge => ({
                from: edge.source,
                to: edge.target,
                edge_type: edge.edge_type,
                bidirectional: edge.bidirectional,
                reason: edge.reason
            }));
        }

        function animateGraph() {
            const canvas = document.getElementById('graph-canvas');
            const ctx = canvas.getContext('2d');
            const { nodes, edges, physics } = state.graph;

            // Update canvas size if window was resized
            const displayWidth = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
            }

            // Update camera pan animation if active
            updatePanAnimation();

            // Clear canvas
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary');
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Filter nodes based on hideCompleted + search setting
            const visibleNodes = getVisibleNodes(nodes);
            const visibleNodeIds = new Set(visibleNodes.map(n => n.id));
            state.graph.visibleNodes = visibleNodes;
            state.graph.visibleNodeIds = visibleNodeIds;

            if (visibleNodes.length === 0) {
                renderEmptyState(ctx, 'No matching nodes');
                if (state.currentView === 'graph') {
                    requestAnimationFrame(animateGraph);
                }
                return;
            }

            // Apply forces (circular gravity system) - only to visible nodes
            applyCircularGravity(visibleNodes, physics);
            applyRepulsionForces(visibleNodes, physics);
            applyEdgeAttraction(visibleNodes, edges, physics);
            updatePositions(visibleNodes, physics, canvas);

            // Continuous follow: track the followed node as it moves
            updateContinuousFollow(canvas);

            // Draw edges (filtered by edge type visibility and node visibility)
            edges.forEach(edge => {
                // Skip edges that are filtered out by type
                if (!state.edgeFilters[edge.edge_type]) return;

                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);

                // Skip edges where either endpoint is hidden
                if (!fromNode || !toNode || !visibleNodeIds.has(edge.from) || !visibleNodeIds.has(edge.to)) {
                    return;
                }

                const style = getEdgeStyle(edge.edge_type);
                drawArrow(ctx, fromNode.x, fromNode.y, toNode.x, toNode.y, canvas, fromNode.radius, toNode.radius, style, edge.bidirectional);
            });

            // Draw visible nodes only
            visibleNodes.forEach(node => {
                drawNode(ctx, node, canvas);
            });

            if (state.currentView === 'graph') {
                requestAnimationFrame(animateGraph);
            }
        }

        function applyCircularGravity(nodes, physics) {
            const draggedNode = state.graph.draggedNode;
            const { gravityCenter, gravityStrength } = physics;

            nodes.forEach(node => {
                // Don't apply forces to dragged nodes
                if (node === draggedNode) return;

                const dx = gravityCenter.x - node.x;
                const dy = gravityCenter.y - node.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    const force = gravityStrength;
                    node.vx += (dx / distance) * force;
                    node.vy += (dy / distance) * force;
                }
            });
        }

        function applyEdgeAttraction(nodes, edges, physics) {
            if (!physics.edgeAttractionEnabled) return;

            const draggedNode = state.graph.draggedNode;
            const { springStrength, springRestingLength } = physics;

            edges.forEach(edge => {
                const fromNode = nodes.find(n => n.id === edge.from);
                const toNode = nodes.find(n => n.id === edge.to);
                if (!fromNode || !toNode) return;

                // Don't apply to dragged nodes
                if (fromNode === draggedNode && toNode === draggedNode) return;

                const dx = toNode.x - fromNode.x;
                const dy = toNode.y - fromNode.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance === 0) return;

                // Bidirectional spring force: applies when compressed OR extended
                // Force increases linearly with deviation from resting length
                const deviation = distance - springRestingLength;
                const force = springStrength * deviation;

                // Spring pulls toward resting length:
                // - If compressed (distance < resting): deviation is negative, pushes apart
                // - If extended (distance > resting): deviation is positive, pulls together
                const fx = (dx / distance) * force;
                const fy = (dy / distance) * force;

                if (fromNode !== draggedNode) {
                    fromNode.vx += fx;
                    fromNode.vy += fy;
                }
                if (toNode !== draggedNode) {
                    toNode.vx -= fx;
                    toNode.vy -= fy;
                }
            });
        }

        function applyRepulsionForces(nodes, physics) {
            const draggedNode = state.graph.draggedNode;

            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const n1 = nodes[i];
                    const n2 = nodes[j];
                    const dx = n2.x - n1.x;
                    const dy = n2.y - n1.y;
                    const distanceSq = dx * dx + dy * dy;
                    if (distanceSq === 0) continue;

                    const force = physics.repulsionStrength / distanceSq;
                    const distance = Math.sqrt(distanceSq);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;

                    // Don't apply forces to dragged nodes
                    if (n1 !== draggedNode) {
                        n1.vx -= fx;
                        n1.vy -= fy;
                    }
                    if (n2 !== draggedNode) {
                        n2.vx += fx;
                        n2.vy += fy;
                    }
                }
            }
        }

        function updatePositions(nodes, physics, canvas) {
            const draggedNode = state.graph.draggedNode;
            const { damping, maxVelocity } = physics;

            nodes.forEach(node => {
                // Freeze dragged node
                if (node === draggedNode) {
                    node.vx = 0;
                    node.vy = 0;
                    return;
                }

                // Apply damping
                node.vx *= damping;
                node.vy *= damping;

                // Cap velocity to prevent extreme speeds
                const speed = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
                if (speed > maxVelocity) {
                    node.vx = (node.vx / speed) * maxVelocity;
                    node.vy = (node.vy / speed) * maxVelocity;
                }

                // Update position (NO BOUNDARY CLAMPING for infinite canvas)
                node.x += node.vx;
                node.y += node.vy;
            });
        }

        // Format node label with word wrap and truncation
        // Returns array of lines (max 2 lines, max 8 chars per line)
        // NOTE: Uses string length (UTF-16 code units), not grapheme clusters.
        // Emoji/complex Unicode may appear shorter visually than their length suggests.
        function formatNodeLabel(text, maxCharsPerLine = 8, maxLines = 2) {
            if (!text) return [];

            const maxTotal = maxCharsPerLine * maxLines;

            // If text fits on one line, return early
            if (text.length <= maxCharsPerLine) {
                return [text];
            }

            // Truncate if too long overall (with ellipsis)
            if (text.length > maxTotal) {
                text = text.substring(0, maxTotal - 1) + '‚Ä¶';
            }

            const lines = [];
            let remaining = text;

            while (remaining.length > 0 && lines.length < maxLines) {
                if (remaining.length <= maxCharsPerLine) {
                    lines.push(remaining);
                    break;
                }

                // Try to break at a reasonable point (space, hyphen, underscore)
                let breakPoint = maxCharsPerLine;
                for (let i = maxCharsPerLine - 1; i >= Math.floor(maxCharsPerLine / 2); i--) {
                    if (remaining[i] === ' ' || remaining[i] === '-' || remaining[i] === '_') {
                        breakPoint = i + 1;
                        break;
                    }
                }

                lines.push(remaining.substring(0, breakPoint).trim());
                remaining = remaining.substring(breakPoint).trim();
            }

            return lines;
        }

        function drawNode(ctx, node, canvas) {
            const isHovered = node === state.graph.hoveredNode;
            const isDragging = node === state.graph.draggedNode;
            const isSelected = node === state.graph.selectedNode;
            
            // Check if node matches current highlight filter
            const matchesFilter = nodeMatchesFilter(node);
            const isDimmed = state.graph.highlightFilter && !matchesFilter;

            // Transform world coordinates to screen coordinates
            const screenPos = worldToScreen(node.x, node.y, canvas);
            const zoom = state.graph.viewport.zoom;
            const radius = node.radius * zoom;

            // Node colors based on status
            const colors = {
                'pending': '#5bc0de',
                'in_progress': '#f0ad4e',
                'blocked': '#d9534f',
                'done': '#5cb85c'
            };
            
            // Bug colors (reddish tones) - use CSS variables
            const bugColors = {
                'pending': '#e07878',      // --bug-pending
                'in_progress': '#d95050',  // --bug-in-progress
                'blocked': '#b33a3a',      // --bug-blocked
                'done': '#8fbc8f'          // --bug-done
            };
            
            // Idea colors (deeper purple) - use CSS variables
            const ideaColors = {
                'pending': '#8b5fc9',      // --idea-pending
                'in_progress': '#7a4db8',  // --idea-in-progress
                'blocked': '#5c3a8a',      // --idea-blocked
                'done': '#8fbc8f'          // --idea-done
            };
            
            // Select color palette based on node type
            let colorPalette = colors;
            if (node.type === 'bug') {
                colorPalette = bugColors;
            } else if (node.type === 'idea') {
                colorPalette = ideaColors;
            }
            const color = colorPalette[node.status] || '#4a90e2';
            
            // Apply dimming for filtered-out nodes
            ctx.globalAlpha = isDimmed ? 0.3 : 1.0;

            // Draw selection highlight (persistent)
            if (isSelected) {
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, radius + 10 * zoom, 0, Math.PI * 2);
                ctx.strokeStyle = '#f0ad4e';
                ctx.lineWidth = 4;
                ctx.stroke();
                ctx.fillStyle = 'rgba(240, 173, 78, 0.15)';
                ctx.fill();
            }

            // Draw drag highlight (active)
            if (isDragging) {
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, radius + 8 * zoom, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(74, 144, 226, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#4a90e2';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            // Draw hover highlight
            else if (isHovered) {
                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, radius + 8 * zoom, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(74, 144, 226, 0.2)';
                ctx.fill();
                ctx.strokeStyle = '#6aa8f0';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // Draw circle
            ctx.beginPath();
            ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = (isHovered || isDragging) ? '#ffffff' : '#e8edf3';
            ctx.lineWidth = (isHovered || isDragging) ? 3 : 2;
            ctx.stroke();

            // Draw text - show short_name if set, with task ID below in smaller font
            ctx.fillStyle = '#1a2332';
            const baseFontSize = 12 * Math.max(0.8, Math.min(1.5, zoom));
            const smallFontSize = baseFontSize * 0.75;
            ctx.textAlign = 'center';

            if (node.short_name) {
                // Format short_name with word wrap
                const labelLines = formatNodeLabel(node.short_name, 8, 2);
                const lineHeight = baseFontSize * 1.2;
                
                // Calculate total height for centering
                const totalLines = labelLines.length + 1; // +1 for ID below
                const totalHeight = (totalLines - 1) * lineHeight;
                const startY = screenPos.y - totalHeight / 2 + baseFontSize / 2;
                
                // Draw short_name lines
                ctx.font = (isHovered || isDragging) ? `bold ${baseFontSize}px sans-serif` : `${baseFontSize}px sans-serif`;
                ctx.textBaseline = 'middle';
                labelLines.forEach((line, i) => {
                    ctx.fillText(line, screenPos.x, startY + i * lineHeight);
                });
                
                // Draw task ID below in smaller font
                ctx.font = `${smallFontSize}px sans-serif`;
                ctx.fillStyle = 'rgba(26, 35, 50, 0.7)';
                ctx.fillText(node.id, screenPos.x, startY + labelLines.length * lineHeight);
            } else {
                // No short_name - just show task ID centered
                ctx.font = (isHovered || isDragging) ? `bold ${baseFontSize}px sans-serif` : `${baseFontSize}px sans-serif`;
                ctx.textBaseline = 'middle';
                ctx.fillText(node.id, screenPos.x, screenPos.y);
            }
            
            // Reset globalAlpha after drawing
            ctx.globalAlpha = 1.0;
        }

        // Get edge style based on edge type
        function getEdgeStyle(edgeType) {
            const styles = getComputedStyle(document.documentElement);
            switch (edgeType) {
                case 'depends_on':
                case 'blocks':
                    return {
                        color: styles.getPropertyValue('--edge-blocking').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
                case 'related_to':
                case 'caused_by':
                case 'duplicates':
                case 'supersedes':
                    return {
                        color: styles.getPropertyValue('--edge-informational').trim(),
                        dashed: true,
                        lineWidth: 1.5
                    };
                case 'fixes':
                case 'tests':
                    return {
                        color: styles.getPropertyValue('--edge-fixes').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
                case 'parent_of':
                case 'child_of':
                    return {
                        color: styles.getPropertyValue('--edge-hierarchy').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
                default:
                    return {
                        color: styles.getPropertyValue('--edge-default').trim(),
                        dashed: false,
                        lineWidth: 2
                    };
            }
        }

        function drawArrow(ctx, x1, y1, x2, y2, canvas, fromRadius = 30, toRadius = 30, style = null, bidirectional = false) {
            // Calculate the angle of the line
            const dx = x2 - x1;
            const dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            const distance = Math.sqrt(dx * dx + dy * dy);

            // If nodes are overlapping, skip drawing
            if (distance < fromRadius + toRadius) return;

            // Calculate start point at edge of fromNode
            const startX = x1 + Math.cos(angle) * fromRadius;
            const startY = y1 + Math.sin(angle) * fromRadius;

            // Calculate end point at edge of toNode
            const endX = x2 - Math.cos(angle) * toRadius;
            const endY = y2 - Math.sin(angle) * toRadius;

            // Transform to screen coordinates
            const p1 = worldToScreen(startX, startY, canvas);
            const p2 = worldToScreen(endX, endY, canvas);

            // Apply style
            const defaultStyle = { color: getComputedStyle(document.documentElement).getPropertyValue('--edge-default').trim(), dashed: false, lineWidth: 2 };
            const edgeStyle = style || defaultStyle;
            ctx.strokeStyle = edgeStyle.color;
            ctx.fillStyle = edgeStyle.color;
            ctx.lineWidth = edgeStyle.lineWidth * state.graph.viewport.zoom;

            // Set dash pattern for informational edges
            if (edgeStyle.dashed) {
                ctx.setLineDash([6, 4]);
            } else {
                ctx.setLineDash([]);
            }

            // Calculate midpoint for arrow head
            const midX = (p1.x + p2.x) / 2;
            const midY = (p1.y + p2.y) / 2;

            const headLength = 10 * state.graph.viewport.zoom;
            const screenAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

            // Draw line from start to end
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();

            // Reset dash pattern for arrow heads
            ctx.setLineDash([]);

            // Arrow head at midpoint (pointing from source to target)
            ctx.beginPath();
            ctx.moveTo(midX, midY);
            ctx.lineTo(
                midX - headLength * Math.cos(screenAngle - Math.PI / 6),
                midY - headLength * Math.sin(screenAngle - Math.PI / 6)
            );
            ctx.lineTo(
                midX - headLength * Math.cos(screenAngle + Math.PI / 6),
                midY - headLength * Math.sin(screenAngle + Math.PI / 6)
            );
            ctx.closePath();
            ctx.fill();

            // Draw second arrow head for bidirectional edges (pointing from target to source)
            if (bidirectional) {
                const reverseAngle = screenAngle + Math.PI;
                ctx.beginPath();
                ctx.moveTo(midX, midY);
                ctx.lineTo(
                    midX - headLength * Math.cos(reverseAngle - Math.PI / 6),
                    midY - headLength * Math.sin(reverseAngle - Math.PI / 6)
                );
                ctx.lineTo(
                    midX - headLength * Math.cos(reverseAngle + Math.PI / 6),
                    midY - headLength * Math.sin(reverseAngle + Math.PI / 6)
                );
                ctx.closePath();
                ctx.fill();
            }
        }

        function renderReady() {
            const list = document.getElementById('ready-list');
            if (state.ready.length === 0) {
                list.innerHTML = '<div class="empty-state">No ready tasks</div>';
                return;
            }
            list.innerHTML = state.ready.map(task => `
                <div class="card">
                    <div class="card-title">${escapeHtml(task.title)}</div>
                    <div class="card-meta">
                        <span class="badge badge-priority-${task.priority}">P${task.priority}</span>
                        <span class="badge" style="background: var(--bg-tertiary)">${task.id}</span>
                        ${task.tags.map(tag => `<span class="badge badge-tag">${escapeHtml(tag)}</span>`).join('')}
                    </div>
                </div>
            `).join('');
        }

        function renderTests() {
            const list = document.getElementById('test-list');
            if (state.tests.length === 0) {
                list.innerHTML = '<div class="empty-state">No tests configured</div>';
                return;
            }
            list.innerHTML = state.tests.map(test => `
                <div class="card">
                    <div class="card-title">${escapeHtml(test.name)}</div>
                    <div class="card-meta">
                        <span class="badge" style="background: var(--bg-tertiary)">${test.id}</span>
                        <span class="badge ${test.last_status === 'passed' ? 'badge-status-done' : 'badge-status-blocked'}">
                            ${test.last_status || 'Not run'}
                        </span>
                    </div>
                </div>
            `).join('');
        }

        function renderLog() {
            const list = document.getElementById('log-list');
            if (state.log.length === 0) {
                list.innerHTML = '<div class="empty-state">No activity yet</div>';
                return;
            }
            list.innerHTML = state.log.slice(0, 50).map(entry => `
                <div class="card log-entry">
                    <div class="log-time">${new Date(entry.timestamp).toLocaleString()}</div>
                    <div class="card-title">${escapeHtml(entry.action || entry.message)}</div>
                </div>
            `).join('');
        }

        function renderEmptyState(ctx, message) {
            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary');
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(message, ctx.canvas.width / 2, ctx.canvas.height / 2);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Edge filter UI functions
        function getEdgeCategoryColor(category) {
            const styles = getComputedStyle(document.documentElement);
            switch (category) {
                case 'blocking': return styles.getPropertyValue('--edge-blocking').trim();
                case 'informational': return styles.getPropertyValue('--edge-informational').trim();
                case 'fixes': return styles.getPropertyValue('--edge-fixes').trim();
                case 'hierarchy': return styles.getPropertyValue('--edge-hierarchy').trim();
                default: return styles.getPropertyValue('--edge-default').trim();
            }
        }

        function initializeEdgeFilters() {
            const container = document.getElementById('edge-filter-group');
            const dropdownBtn = document.getElementById('edge-filters-btn');
            const filtersPanel = document.getElementById('edge-filters');
            
            // Create filter buttons for each edge type
            container.innerHTML = '';
            
            // Add "All" toggle button first
            const allBtn = document.createElement('button');
            allBtn.className = 'edge-filter-btn edge-filter-all';
            allBtn.textContent = 'All';
            allBtn.title = 'Toggle all edge types';
            
            const updateAllBtnState = () => {
                const allActive = Object.keys(EDGE_TYPES).every(type => state.edgeFilters[type]);
                allBtn.classList.toggle('active', allActive);
            };
            
            allBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const allActive = Object.keys(EDGE_TYPES).every(type => state.edgeFilters[type]);
                const newState = !allActive;
                
                for (const type of Object.keys(EDGE_TYPES)) {
                    state.edgeFilters[type] = newState;
                }
                
                // Update all button states
                container.querySelectorAll('.edge-filter-btn[data-edge-type]').forEach(btn => {
                    btn.classList.toggle('active', newState);
                });
                updateAllBtnState();
                saveEdgeFilters(state.edgeFilters);
            });
            
            container.appendChild(allBtn);
            
            for (const [type, info] of Object.entries(EDGE_TYPES)) {
                const btn = document.createElement('button');
                btn.className = 'edge-filter-btn' + (state.edgeFilters[type] ? ' active' : '');
                btn.dataset.edgeType = type;
                btn.title = `Toggle ${info.name} edges`;
                
                const dot = document.createElement('span');
                dot.className = 'edge-filter-dot';
                dot.style.backgroundColor = getEdgeCategoryColor(info.category);
                
                btn.appendChild(dot);
                btn.appendChild(document.createTextNode(info.name));
                
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    state.edgeFilters[type] = !state.edgeFilters[type];
                    btn.classList.toggle('active', state.edgeFilters[type]);
                    updateAllBtnState();
                    saveEdgeFilters(state.edgeFilters);
                });
                
                container.appendChild(btn);
            }
            
            updateAllBtnState();
            
            // Toggle dropdown open/close
            dropdownBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                filtersPanel.classList.toggle('open');
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!filtersPanel.contains(e.target)) {
                    filtersPanel.classList.remove('open');
                }
            });
        }

        // Initialize
        initializeEdgeFilters();
        initializeStatFilters();
        updateAutoFollowDisplay();
        updateHideCompletedDisplay();
        initializeGraphSearch();
        connectWebSocket();
    </script>
</body>
</html>
